;;;-*- Mode:COMMON-LISP; Package:INSTALLER; Distribution-Tape:RESTORE-FILE-2;Official-Title:"Rtms"; Release-Number:"3.0"; Part-Number:"2537112-0001" -*-


(DEFPARAMETER *STATIC-INFO*
   '((OFFICIAL-TITLE "RTMS") (RELEASE-NUMBER "3.0") (PATCH-LEVEL "3.0")
     (PART-NUMBER "2537112-0001") (LOADING-REFERENCE "2549850-0001") (TIME-TO-MAKE "30 min")))
;;; -*- Mode:Common-Lisp; Package:INSTALLER; Fonts:(MEDFNT HL12B); Base:10 -*-
;;; Copyright (c) 1985, 1986, 1987 Texas Instruments Incorporated.  All Rights Reserved.

;;; the above is a temporary file attribute line which is replaced on the tape


;;; Restore File for 1RTMS *Source and Object Product
(MT:DEF-LDT-1 (work-directory)
  ;; describe logical hosts
  (mt:ldt-translations-files '("RTMS" . "The file server host for the RTMS source/object files"))

  ;; create RTMS: RTMS; directory
  (mt:ldt-create-directory "RTMS: RTMS;")

  ;; create RTMS: RTMS-PATCH; directory
  (mt:ldt-create-directory "RTMS: RTMS-PATCH;")

  ;; restore remainder of tape
  (mt:ldt-restore-file      "SYS: SITE; RTMS.SYSTEM#>")
  (let ((restore-as-original-p (mt:restore-original-versionS-p)))
    (mt:ldt-no-more-prompts)
    (if restore-as-original-p
(progn
  (mt:ldt-restore-directory "RTMS: RTMS; *.*#*")
          (mt:ldt-restore-directory "RTMS: RTMS-PATCH; *.*#*"))
(progn
  (mt:ldt-restore-directory "RTMS: RTMS; *.*#>")
          (mt:ldt-restore-directory "RTMS: RTMS-PATCH; *.*#>")))
    );let
  (mt:ldt-restore-inp work-directory)


  ;; verify tape except for Restore File and TRANSLATIONS Files
  (mt:rewind); go back to the beginning again
  (mt:space-to-eof); skip over RESTORE-FILE
  (mt:space-to-eof); skip over TRANSLATION-FILE
  (mt:ldt-verify-or-throw "SYS: SITE; RTMS.SYSTEM#>")
  (mt:ldt-verify-or-throw "RTMS: RTMS; *.*#>")
  (mt:ldt-verify-or-throw "RTMS: RTMS-PATCH; *.*#>")
  (mt:ldt-verify-inp-or-throw work-directory)
  )



|/J"/L"/L"LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540621. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "TRANSLATIONS" :NAME "RTMS" :DIRECTORY ("SITE") :SOURCE-PATTERN "( :DIRECTORY (\"SITE\") :NAME \"RTMS\" :TYPE \"TRANSLATIONS\" :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2758818129. :AUTHOR "REL3" :LENGTH-IN-BYTES 537. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;;; -*- Mode:Common-Lisp; Package:FS; Fonts:(MEDFNT HL12B HL12BI); Base:10 -*-

;1;;; RTMS Logical Host Translations*

(fs:SET-logical-pathname-host "RTMS"
      :PHYSICAL-HOST (send (fs:get-pathname-host "SYS") :host)
      ;; The default translations are for a top level directory,
      ;; SYS:RTMS; If a different directory is used as the
      ;; main RTMS subdirectory, then the following translations
      ;; must be edited to point to that subdirectory.
;      :TRANSLATIONS '(("RTMS" "RTMS;"))
      )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540625. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "SYSTEM" :NAME "RTMS" :DIRECTORY ("SITE") :SOURCE-PATTERN "( :DIRECTORY (\"SITE\") :NAME \"RTMS\" :TYPE \"SYSTEM\" :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2758818071. :AUTHOR "REL3" :LENGTH-IN-BYTES 307. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;;;-*- Mode:Common-Lisp; Base:10 -*-

;;; THIS FILE LOADS THE TRANSLATIONS FOR RTMS, THEN SETS THE SYSTEM SOURCE FILE
;;; SO IT KNOWS WHERE TO FIND THE INFORMATION ABOUT HOW TO BUILD RTMS.

(load "SYS: SITE; RTMS TRANSLATIONS" :verbose nil)

(si:set-system-source-file "RTMS" "RTMS:RTMS;DEFSYSTEM LISP")
YTES 307. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540630. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "ATTACH-DETACH" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749845889. :AUTHOR "REL3" :LENGTH-IN-BYTES 22790. :LENGTH-IN-BLOCKS 23. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
1;;; ATTACH-DETACH
;;;
;;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp
;;; Reference
;;;     errset
;;;     dump-forms-to-file
;;;     fs:directory-list
;;;
;;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not
;;; effect the functionality of RTMS.
;;;     validate-attach-flavor-avl
;;;     validate-attach-flavor-heap
;;;     validate-attach-flavor-hash
;;;*

(defun attach-relation-load (relation-name pathname)
  (cond ((probe-file pathname)
 (load pathname :verbose (if *provide-status-messages* t nil))
 '*attach-detach-data*)
((and (not (pathname-type pathname)) (probe-file (string-append pathname ".XLD")))
 (load pathname :verbose (if *provide-status-messages* t nil)) '*attach-detach-data*)
(t
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - The file ~s does not exist" pathname)
(format *standard-output* "~%      - The relation ~s can not be attached." relation-name)))
 nil)))

(defun attach-relation (relation-name &rest keyword-list
&key &optional attributes directory documentation format implementation-type key memory
pathname storage-structure
&allow-other-keys
&aux attribute-descriptor dir end-index imp pathname1 (attr nil) relation-info sto mem
hold-warning (card 0) temp-card)
  "Attach some existing data to relation.

   RELATION-NAME - The name of the relation to which the data is to be attached.
   ATTRIBUTES    - A list that describes the attributes in this relation.
   DIRECTORY     - The directory in which RTMS saves the attached data.
   DOCUMENTATION - A string that describes the specified relation.
   FORMAT        - A list corresponding to the ATTRIBUTES specifying their print width.
   IMPLEMENTATION-TYPE - Name of the implementation type.
   KEY           - A list of attributes that are to form the key.
   MEMORY        - Specifies a variable where the data to be attached is stored.
   PATHNAME      - If the data is stored in a file, specify its name here.
   STORAGE-STRUCTURE - Name of the storage-structure type."

  attributes directory documentation format implementation-type key memory pathname storage-structure

  (block attach-relation
(multiple-value-setq (relation-name keyword-list relation-info)
  (initial-validation relation-name keyword-list '(att path imp sto key dir doc format mem)
      '(save-directory implementation-type storage-structure cardinality attributes)
      t))
(setf imp (or (nth 1 relation-info) (car (get-keyword-value '(imp) keyword-list)) *rel-imp*)
      sto (or (nth 2 relation-info) (car (get-keyword-value '(sto) keyword-list)) *rel-sto*)
      dir (or (nth 0 relation-info) (car (get-keyword-value '(dir) keyword-list)))
      card (or (nth 3 relation-info) 0)
      attribute-descriptor (or (nth 4 relation-info) (car (get-keyword-value '(att) keyword-list)))
      mem (car (get-keyword-value '(mem) keyword-list))
      pathname1 (or (car (get-keyword-value '(path) keyword-list))
    (concatenate 'string *save-directory* relation-name ".lisp")))
;1; Collect the names of the attributes. *
(if (car (get-keyword-value '(att) keyword-list))
    (mapc #'(lambda (attr-desc)
      (if (not (listp attr-desc))
  (push attr-desc attr)))
  (reverse attribute-descriptor))
    (setf attr attribute-descriptor))
(if (and (not mem) (not (car (get-keyword-value '(path) keyword-list))))
    (setf mem '*attach-detach-data*))
(if (not mem)
    (progn
      (if (setf end-index (search ";" pathname1))
  (setf dir (subseq pathname1 0 (+ end-index 1)))
  (setf pathname (concatenate 'string dir pathname1)))
      (cond ((not (search "pages used in" (third (caar (errset (fs:directory-list dir) nil)))
  ':test 'string-equal))
     (if *provide-error-messages*
 (format *standard-output* "~%ERROR - Directory ~s does not exist" dir))
     (return-from attach-relation nil)))))
(if (equal mem t)
    (setf mem '*attach-detach-data*))
;;
;;1  Attach the relation in the appropriate manner*
(cond (relation-info
       ;;
       ;;1  The relation exists, determine if it is empty*
       (cond ((relation-emptyp relation-name (nth 1 relation-info) (nth 2 relation-info))
      (if (not mem)
  (setf mem (attach-relation-load relation-name pathname1)))
      (if (car (errset (symbol-value mem) t))
  (return-from attach-relation (process-attach relation-name sto imp mem attr))
  (return-from attach-relation nil)))
     (t
      (if (not mem)
  (setf mem (attach-relation-load relation-name pathname1)))
      (if (car (errset (symbol-value mem) t))
  (progn
    (if
      (not (setf temp-card
 (validate-attach relation-name (string-upcase sto)
  (string-upcase imp) (symbol-value mem) attr)))
      (progn
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~S is not valid data."
    (symbol-value mem)))
(return-from attach-relation nil)))
    (modify 'system-relation
    'where `(string-equal relation-name (string-upcase ',relation-name))
    'attributes '(cardinality modifiedp) 'values (list (+ temp-card card) t))
    (if *provide-status-messages*
(format *standard-output* "~%Relation ~s has been successfully attached"
relation-name))
    (return-from attach-relation relation-name))
  (return-from attach-relation nil)))))
      (t
       ;;
       ;;1 -----> The keyword-list is not formed properly here  <-------*
       ;;
       (setf hold-warning *provide-warning-messages*
     *provide-warning-messages* nil
     keyword-list (get-keyword-value-prereq '(imp sto key dir doc format)  keyword-list)
     *provide-warning-messages* hold-warning)
       (if (not (define-relation relation-name attribute-descriptor keyword-list))
   (return-from attach-relation nil))
       (if (not mem)
   (setf mem (attach-relation-load relation-name pathname1)))
       (if (car (errset (symbol-value mem) t))
   (return-from attach-relation (process-attach relation-name sto imp mem attr))
   (return-from attach-relation nil))))))

(defun process-attach (relation-name sto imp mem attr)
  (let (card)
    (cond ((not (setf card (validate-attach relation-name (string-upcase sto) (string-upcase imp)
    (symbol-value mem)  attr)))
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - ~S is not valid data." (symbol-value mem)))
   (destroy-relation relation-name)
   nil)
  (t
   (modify 'system-relation 'where `(string-equal relation-name (string-upcase ',relation-name))
   'attributes '(cardinality modifiedp) 'values (list card t))
   (if *provide-status-messages*
       (format *standard-output* "~%Relation ~s has been successfully attached" relation-name))
   relation-name))))

(defun validate-attach (relation-name sto imp data attr)
  (funcall (find-symbol (concatenate 'string "VALIDATE-ATTACH" "-" imp "-" sto) *pkg-string*) relation-name
   attr data))


(defun validate-attach-list-heap (relation-name attr data &aux (len (length attr)))
  (cond (*validity-checking*
 (cond ((or (not (listp data))
    (apply 'or (mapcar #'(lambda (%data)
   (or (not (listp %data)) (not (equal (length %data) len))))
       data)))
nil)
       (t
;;1Later on, we will have to go through each tuple, call dom-check - just like INSERT.*
(putp relation-name (append (getp relation-name 'entry-point) data) 'entry-point)
(length data))))
(t
 (insert-list-heap relation-name attr data nil relation-name)
 (length data))))

(defun validate-attach-list-hash (relation-name attr data)
  (block validate-attach-list-hash
(let ((table (getp relation-name 'entry-point)) (card 0) (len (length attr)))
  (cond (*validity-checking*   ;1Some validation,like in Insert, needs to be done.*
 (if (not (hash-table-p data))
     (return-from validate-attach-list-hash nil))
 (progn
   (maphash #'(lambda (key tuples)
(if (or (not (listp tuples))
(apply 'or (mapcar #'(lambda (%data)
(or (not (listp %data))
    (not (equal (length %data) len))))
    tuples)))
    (return-from validate-attach-list-hash nil))
(puthash key tuples table)
(setf card (+ card (length tuples))))
    data)
   (return-from validate-attach-list-hash card)))
(t
 (maphash #'(lambda (key tuples)
      (puthash key tuples table)
      (setf card (+ card (length tuples))))
  data)
 (return-from validate-attach-list-hash card))))))

(defun validate-attach-list-avl (relation-name attr data)
  (let ((len (length attr)) list-data)
    (cond ((not (car (errset (setf list-data (avl-inorder-traversal data)) t)))
   nil)
  (t
   (cond (*validity-checking*
  (cond ((or (not (listp list-data))
     (apply 'or (mapcar #'(lambda (%data)
    (or (not (listp %data)) (not (equal (length %data) len))))
list-data)))
 nil)
(t
 (cond ((null (get relation-name 'entry-point))
(putp relation-name data 'entry-point))
       (t
(insert relation-name 'tuples list-data)))
 (length list-data))))
 (t
  (cond ((null (get relation-name 'entry-point))
 (putp relation-name data 'entry-point))
(t
 (insert relation-name 'tuples list-data)))
  (length list-data)))))))

(defun validate-attach-flavor-avl (relation-name attr data
   &aux temp list-data)
  (block validate-attach-flavor-avl
(cond ((not (car (errset (setf list-data (avl-inorder-traversal data)) t)))
       (return-from validate-attach-flavor-avl nil))
      (t
       (cond (*validity-checking*
      (cond ((not (member (read-from-string (concatenate 'string *pkg-name* relation-name))
  *all-flavor-names* :test 'string-equal))
     (return-from validate-attach-flavor-avl nil))
    (t
     (setf temp (send (make-instance (read-from-string (concatenate 'string *pkg-name*
    relation-name)))
      ':which-operations))
     (mapc #'(lambda (x)
       (if (not (member (read-from-string (concatenate 'string ":"
       (string-upcase x))) temp
:test 'string-equal))
   (return-from validate-attach-flavor-avl nil)))
   attr)
     (if (not (car (errset
     (mapc #'(lambda (%data)
       (if (not (equal temp (send %data ':which-operations)))
   (return-from validate-attach-flavor-avl nil)))
   list-data) t)))
 (return-from validate-attach-flavor-avl nil))
     (cond ((null (getp relation-name 'entry-point))
    (putp relation-name data 'entry-point))
   (t
    (insert relation-name
    'tuples (project-flavor list-data attr attr relation-name))))
     (return-from validate-attach-flavor-avl (length list-data)))))
     (t
      (cond ((null (getp relation-name 'entry-point))
     (putp relation-name data 'entry-point))
    (t
     (insert relation-name 'tuples (project-flavor list-data attr attr relation-name))))
      (return-from validate-attach-flavor-avl (length list-data))))))))

(defun validate-attach-flavor-heap (relation-name attr data &aux temp)
  (block validate-attach-flavor-heap
(cond ((not (listp data))
       (return-from validate-attach-flavor-heap nil)))
(cond (*validity-checking*
       (cond ((not (member (read-from-string (concatenate 'string *pkg-name* relation-name))
   *all-flavor-names* :test 'string-equal))
      (return-from validate-attach-flavor-heap nil))
     (t
      (setf temp (send (make-instance
 (read-from-string (concatenate 'string *pkg-name* relation-name)))
       ':which-operations))
      (mapc #'(lambda (x)
(if (not (member (read-from-string (concatenate 'string ":" (string-upcase x)))
 temp :test 'string-equal))
    (return-from validate-attach-flavor-heap nil)))
    attr)
      (if (not (car (errset (mapc #'(lambda (%data)
      (if (not (equal temp (send %data ':which-operations)))
  (return-from validate-attach-flavor-heap nil)))
  data) t)))
  (return-from validate-attach-flavor-heap nil))
      (putp relation-name (append (getp relation-name 'entry-point) data) 'entry-point)
      (return-from validate-attach-flavor-heap (length data)))))
      (t
       (putp relation-name (append (getp relation-name 'entry-point)  data) 'entry-point)
       (return-from validate-attach-flavor-heap (length data))))))

(defun validate-attach-flavor-hash (relation-name attr data
    &aux (table (getp relation-name 'entry-point)) (card 0) temp)
  (block validate-attach-flavor-hash
(if (not (hash-table-p data))
    (return-from validate-attach-flavor-hash nil))
(cond (*validity-checking*
       (cond ((not (member (read-from-string (concatenate 'string *pkg-name* relation-name))
   *all-flavor-names* :test 'string-equal))
      (return-from validate-attach-flavor-hash nil))
     (t (setf temp (send (make-instance
   (read-from-string (concatenate 'string *pkg-name* relation-name)))
 ':which-operations))
(mapc #'(lambda (x)
  (if (not (member (read-from-string (concatenate 'string ":"
  (string-upcase x))) temp
   :test 'string-equal))
      (Return-from validate-attach-flavor-hash nil)))
      attr)
(maphash
  #'(lambda
      (key tuples)
      (if (not (car (errset (mapc
      #'(lambda (%data)
  (if (not (equal temp (send %data ':which-operations)))
      (return-from validate-attach-flavor-hash nil)))
      tuples) t)))
  (return-from validate-attach-flavor-hash nil))
      (puthash key tuples table)
      (setf card (+ card (length tuples))))
  data)
(return-from validate-attach-flavor-hash card))))
      (t
       (maphash #'(lambda (key tuples)
    (puthash key tuples table)
    (setf card (+ card (length tuples))))
data)
       (return-from validate-attach-flavor-hash card)))))

(defun validate-attach-struct-avl (relation-name attr data
   &aux temp list-data)
  (block validate-attach-struct-avl
(cond ((not (car (errset (setf list-data (avl-inorder-traversal data)) t)))
       nil)
      (t
       (cond (*validity-checking*
      (cond ((not (setf temp (fourth (get (read-from-string
    (concatenate 'string *pkg-name* relation-name))
  'si:defstruct-description))))
     (return-from validate-attach-struct-avl nil))
    (t
     (mapc
       #'(lambda (x &aux data fn)
   (if (not (setf data (assoc
 (setf fn (read-from-string
    (concatenate 'string *pkg-name*
 relation-name
 (string-upcase x))))
 temp)))
       (return-from validate-attach-struct-avl nil)
       (if (not (equal (seventh data) fn))
   (return-from validate-attach-struct-avl nil))))
       attr)
     (cond ((null (get relation-name 'entry-point))
    (putp relation-name data 'entry-point))
   (t
    (insert relation-name
    'tuples (project-struct list-data attr attr relation-name))))
     (return-from validate-attach-struct-avl (length list-data)))))
     (t
      (cond ((null (get relation-name 'entry-point))
     (putp relation-name data 'entry-point))
    (t
     (insert relation-name 'tuples (project-struct list-data attr attr relation-name))))
      (return-from validate-attach-struct-avl (length list-data))))))))

(defun validate-attach-struct-heap (relation-name attr data
    &aux temp )
  (block validate-attach-struct-heap
(cond ((not (listp data))
       (return-from validate-attach-struct-heap nil)))
(cond (*validity-checking*
       (cond ((not (setf temp (fourth
       (get (read-from-string (concatenate 'string *pkg-name* relation-name))
    'si:defstruct-description))))
      (return-from validate-attach-struct-heap nil))
     (t
      (mapc
#'(lambda (x &aux data fn)
    (if (not (setf data (assoc
  (setf fn (read-from-string
     (concatenate 'string *pkg-name*  relation-name
  (string-upcase x))))
  temp)))
(return-from validate-attach-struct-heap nil)
(if (not (equal (seventh data) fn))
    (return-from validate-attach-struct-heap nil))))
attr)
      (putp relation-name (append (getp relation-name 'entry-point) data) 'entry-point)
      (return-from validate-attach-struct-heap (length data)))))
      (t
       (putp relation-name (append (getp relation-name 'entry-point) data)'entry-point)
       (return-from validate-attach-struct-heap (length data))))))

(defun validate-attach-struct-hash (relation-name attr data
    &aux (table (getp relation-name 'entry-point)) (card 0) temp)
  (block validate-attach-struct-hash
(if (not (hash-table-p data))
    (return-from validate-attach-struct-hash nil))
(cond (*validity-checking*
       (cond ((not (setf temp (fourth
(get (read-from-string (concatenate 'string *pkg-name* relation-name))
     'si:defstruct-description))))
      (return-from validate-attach-struct-hash nil))
     (t
      (mapc
#'(lambda (x &aux data fn)
    (if (not (setf data (assoc
 (setf fn (read-from-string
    (concatenate 'string *pkg-name* relation-name
 (string-upcase x))))
 temp)))
(return-from validate-attach-struct-hash nil)
(if (not (equal (seventh data) fn))
    (return-from validate-attach-struct-hash nil))))
attr)
      (maphash #'(lambda (key tuples)
   (if (not (listp tuples))
       (return-from validate-attach-struct-hash nil))
   (puthash key tuples table)
   (setf card (+ card (length tuples))))
       data)
      (return-from validate-attach-struct-hash card))))
      (t
       (maphash #'(lambda (key tuples)
    (puthash key tuples table)
    (setf card (+ card (length tuples))))
data)
       (return-from validate-attach-struct-hash card)))))

(defun detach-relation-save (relation-name pathname)
  (dump-forms-to-file pathname `((setf *attach-detach-data* ',(getp relation-name 'entry-point)))))

(defun detach-relation (relation-name &rest keyword-list
&key &optional disk memory pathname
&allow-other-keys
&aux dir end-index imp pathname1 sto mem)
  "Detach data in an existing relation into a variable or onto the disk.

   RELATION-NAME - The name of the relation from which the data is to be detached.
   DISK          - If T, RTMS stores the data in the file specified in the PATHNAME.
   MEMORY        - If set to T, the detached data is stored in the variable rtms:*attach-detach-data*.
                   If any variable name is supplied, the data will be stored in it.
   PATHNAME      - Name of the file in which the detached data is to be saved."
  disk memory pathname
  (block detach-relation
(if *parameter-checking*
    (if (or (not (active-database relation-name))
    (not (setf relation-name (validate-name relation-name))))
(return-from detach-relation nil)
(setf relation-name (string-upcase relation-name)))
    (setf relation-name (string-upcase relation-name)))
(setf keyword-list  (de-nest-keyword-list keyword-list))
;;
;;  1Must deteremine if the relation exists. May not detach a view*
;;
(cond ((not (setf dir (car (qtrieve 'system-relation *system-relation-attributes*
    '(save-directory implementation-type storage-structure)
    *system-relation-key*
    `(string-equal relation-name ,relation-name)))))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~S is not a relation in database ~s."
   relation-name *active-db*))
       (return-from detach-relation nil)))
(setf imp (nth 1 dir)
      sto (nth 2 dir)
      dir (nth 0 dir))
(if *parameter-checking*
    (setf keyword-list (get-keyword-value-prereq '(path disk mem) keyword-list)))
;;
;;1  Form the pathname where the file will be saved*
;;
(setf mem (car (get-keyword-value '(mem) keyword-list)))
(setf pathname1 (car (get-keyword-value '(path) keyword-list)))
(if (and (not mem) (not pathname1))
    (setf mem '*attach-detach-data*))
(setf keyword-list (append '(disk) (get-keyword-value '(disk) keyword-list)))
1;;*
;1;  Determine if the specified directory exists*
;1;*
(if pathname1
    (progn
      (cond ((setf end-index (search ";" pathname1))
     (setf dir (subseq pathname1 0 (+ end-index 1))))
    (t
     (setf pathname1 (concatenate 'string dir pathname1))))
      (cond ((not (search "pages used in" (third (caar (errset (fs:directory-list pathname1) nil)))))
     (if *provide-error-messages*
 (format *standard-output* "~%ERROR - Directory ~s does not exist" dir))
     (return-from detach-relation nil)))))
;;
;;  1Everything looks alright, get the data, write it out and then destroy the relation*
;;
(if *provide-status-messages*
    (format *standard-output* "~%Relation ~s will now be detached from the ~s database"
    relation-name *active-db*))
(cond ((relation-emptyp relation-name imp sto)
       (cond ((destroy-relation relation-name keyword-list)
      (if *provide-status-messages*
  (format *standard-output* "~%The relation ~s is empty, nothing to output"
  relation-name))
      (return-from detach-relation relation-name))
     (t
      (return-from detach-relation nil))))
      (t
       (if (or (not mem) (equal mem t))
   (setf *attach-detach-data* (getp relation-name 'entry-point))
   (set mem (getp relation-name 'entry-point)))
       (if pathname1
   (detach-relation-save relation-name pathname1))
       (cond ((destroy-relation relation-name keyword-list)
      (if *provide-status-messages*
  (format *standard-output* "~%Relation ~s has been sucessfully detached"
  relation-name))
      (return-from detach-relation relation-name))
     (t
      (return-from detach-relation nil)))))))

(defun relation-emptyp (relation-name implementation-type storage-structure)
  implementation-type
  (funcall (find-symbol (concatenate 'string "RELATION-" storage-structure "-EMPTYP") *pkg-string*)
   relation-name))

(defun relation-hash-emptyp (relation-name)
  (block relation-hash-emptyp
(maphash (function (lambda (key tuple)
     key tuple
     (return-from relation-hash-emptyp  (not tuple))))
 (getp relation-name 'entry-point))
(return-from relation-hash-emptyp  t)))

(defun relation-heap-emptyp (relation-name)
  (not (getp relation-name 'entry-point)))

(defun relation-avl-emptyp (relation-name)
  (not (getp relation-name 'entry-point)))
MNOPQRSTUVWXYZ[.\?]L^]_n`abcdefghijklmnopqrrasPt?u2v!wxyz{.|?}L~]n
raP?2!.?L]nraP?2!2Je}˴˘ˁeN22Je}˘˰ѴҘӁeN22Je}˘˰LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540633. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "ATTACH-DETACH" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360858. :AUTHOR "REL3" :LENGTH-IN-BYTES 7425. :LENGTH-IN-BLOCKS 15. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8ATTACH-DETACH\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPATTACH-RELATION-LOADKFF0$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAME*PATHNAMEB:B:\)MACROS-EXPANDED\PATHNAME-TYPE*PROVIDE-ERROR-MESSAGES*C*PROVIDE-STATUS-MESSAGES*jPROBE-FILE)VERBOSELOAD҃*ATTACH-DETACH-DATA*TYPEBapB4PARSE-PATHNAMEҬ.XLDpBTSTRING-APPENDTERPRIlERROR - The file WRITE-STRINGPRIN1, does not exist      - The relation  can not be attached.Q	QP	PQ
PQQQP	QPPQPPQPROyBPATTACH-RELATIONHH@F$B:BV]FB:B:B:BYFB^Bz\B`&RESTKEYWORD-LIST&KEYj&OPTIONALCATTRIBUTESjDIRECTORYDOCUMENTATIONFORMATIMPLEMENTATION-TYPEKEYÀMEMORYBaCSTORAGE-STRUCTUREj&ALLOW-OTHER-KEYSB:\BBBBBBBB
BaBATTRIBUTE-DESCRIPTORDIRCEND-INDEXIMPCPATHNAME1ATTRÁRELATION-INFOSTOMEMHOLD-WARNINGCARDCTEMP-CARDB:CATTR-DESCB:B:B:B:\Bc\pB\lXR-BQ-LISTpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETTHIRDPUSHPROGpZLC,DO-NAMEDSETFDOCUMENTATION|Attach some existing data to relation.

   RELATION-NAME - The name of the relation to which the data is to be attached.
   ATTRIBUTES    - A list that describes the attributes in this relation.
   DIRECTORY     - The directory in which RTMS saves the attached data.
   DOCUMENTATION - A string that describes the specified relation.
   FORMAT        - A list corresponding to the ATTRIBUTES specifying their print width.
   IMPLEMENTATION-TYPE - Name of the implementation type.
   KEY           - A list of attributes that are to form the key.
   MEMORY        - Specifies a variable where the data to be attached is stored.
   PATHNAME      - If the data is stored in a file, specify its name here.
   STORAGE-STRUCTURE - Name of the storage-structure type. plEH*CONDITION-HANDLERS*C*PROVIDE-WARNING-MESSAGES*BgBf*SAVE-DIRECTORY*C*REL-STO*C*REL-IMP*\	iATTRIBUTESiDIRECTORYBFORMATIMPLEMENTATION-TYPEKEYMEMORY)PATHNAMEiSTORAGE-STRUCTUREpB\STORE-KEYARGS\	ATTPATHBBBBDOCBB\ÁSAVE-DIRECTORYBBCARDINALITYBFCINITIAL-VALIDATION\BCGET-KEYWORD-VALUE\B\B\B\B\BSTRING.lispCONCATENATE*REVERSEBkl;pB\,SEARCH*SUBSEQpages used inp,G1673F"ERRORpB\ERRSET-HANDLERpB4DIRECTORY-LISTҪLISTҪSTRING-EQUALBrlERROR - Directory BtBu, does not existRELATION-EMPTYPBPpBG1682F[ÁPROCESS-ATTACHpBG1690FSTRING-UPCASEVALIDATE-ATTACH,ERROR -  is not valid data.SYSTEM-RELATIONÀWHEREB`BB8B\BCMODIFIEDPVALUESÀMODIFYlRelation , has been successfully attached\BBBBBBGET-KEYWORD-VALUE-PREREQDEFINE-RELATIONpBG1700F@@QPAT߀Q@QPPPPAP@PWP@QB
PMP[P@QB	PQPSP@QBKPQBJTJPQCP@QBJP@QBRP@QBPPQPNP@QJQVVSWW5WQO]OVJQORAP@QPRR8PNQLNQJLkKPKQNQH P!P"PT#P$P!PJCXPJCYKQ%&J!BJ!B\BB'P
()P*KQ+,P*RRQPRPQPWP[-'RQNQ.R/P0PT#P$P/PJCVPJCZRQC&J!BJ!B\QQQMQRQOQ1RRQNQ.R2P3PT#P$P2PJCXPJC[RQC&J!BJ!B\3QQQ4MQ4RQCOQ5U(6P*RQC+7P*R8P9P'P:P;P<PQ&&&=P>P?PUQTa&J@(AP*Q+BP*RPSCP@QD@SQQJQ@QERRQNQ.RFPGPT#P$PFPJCYPJCVRQC&J!BJ!B\vROBzBNADF4$B:BV]FB:B:B:BYFB^B\B`BBBBB:\B\Bc\BBBgBfBBBr,ERROR - BtBuҬ is not valid data.DESTROY-RELATIONBBBB`BB8BB\BBBBlRelation , has been successfully attachedQQQQCQ@P	QC
P	QRPPPPPPQPPP@QJP	Q
P	OBB	A	DF$B:BV]FB:B:B:BYFB^B\B`BBDATABB:B:B:*PKG-STRING*B,VALIDATE-ATTACHl-BҪFIND-SYMBOLPPPQPQP@QQQ@O(BCVALIDATE-ATTACH-LIST-HEAP
>@
F$$B:BV]FB:B:B:BYFB^B)\B`BB#B:\LENB:B:B:À%DATA\Bc\BBpBTINHIBIT-STYLE-WARNINGS*VALIDITY-CHECKING*jORENTRY-POINTGETPpB\,*APPEND҃PUTPINSERT-LIST-HEAPQC@'5AтQCBBQCSDD5?BDQC@'?BCBCCAQPDRQQPQPQCQQQۀQ	OAB)CVALIDATE-ATTACH-LIST-HASH=@F%$B:BV]FB:B:B:BYFB^BB\B`BB#B:\
B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGB:ÀTABLEBB3\INTERNAL-FEF-OFFSETS\F
FiVARIABLES-USED-IN-LEXICAL-CLOSURES\B3BBTExit block VALIDATE-ATTACH-LIST-HASHB9FHB;B<FBHASH-TABLE-P\F	F\)INTERNALBB*MAPHASH\BgBBFFFPUQPJQCIHGPUQ]GZJ	P
PCQHQ	PP]GZ\POlBBBf-@F$B:BV]FB:B:B:BYFB^Bf\BÀTUPLESB:\B:B:BMB:B:B:B4\Bc\BBBB8iLEXICAL-PARENT-DEBUG-INFOBHB:pBT,PUTHASH5CсQEDDQESFF5?BFQC&?BCDEECQPDPXQQPQC`O|BfBj@F	$B:BV]FB:B:B:BYFB^Bj\BBuB:\B:B:BM\Bc\BByBHB{QQPQC`OBjVALIDATE-ATTACH-LIST-AVL*d@F:$B:BV]FB:B:B:BYFB^B\B`BB#B:\B3CLIST-DATAB:B:B:B:B4\Bc\	BBB8BBBBBBBB9pBG1890F;BBÂAVL-INORDER-TRAVERSALBB:B;B?BuÀINSERTQC@PPTPPPJCBPJCCւQ	A
J!BJ!B\R-A5CCAQEDDQESFF5?BFQC@'?BCDEECQPDRQP8QQPQPAQAQCQP8OBCVALIDATE-ATTACH-FLAVOR-AVLC@Fa$B:BV]FB:B:B:BYFB^B\B`BB#B:\	TEMPBB:B:CXB:B:B:B4\Bc\
B8BBpBTSENDBBBBBBBpBTl*ALL-FLAVOR-NAMES*C*PKG-NAME*B9pBG1937FTBBBBBB*READ-FROM-STRINGBpB\MEMBER-TEST)WHICH-OPERATIONSpBTMAKE-INSTANCEl:BpBG1952FB;B<B?BuÁPROJECT-FLAVORBPPT	P
PPJCBPJCCւQAJ!BJ!B\RbPPQPPRPPPQ@QBBSDPPDQ@QPRBPPT	P
PPJCEPJCFAQGGSH@QPHr\GAQJ!BJ!B\RQPQQPQPAQQQQAQCQPOBVALIDATE-ATTACH-FLAVOR-HEAP/w@FH$B:BV]FB:B:B:BYFB^B\B`BB#B:\BB:BB:B:B:B4\Bc\
B8BBBBBBBBBBBBB9BBBBBBBl:BpBG2021FBBBB;B<B>B?5RNPPQ	P
PRPPPQ	@QAASBPPBQ	@Q
PRAPPTPPPJCCPJCDւQEESF@QPFr\EQJ!BJ!B\RQQPQPQCOBVALIDATE-ATTACH-FLAVOR-HASH W@F7$B:BV]FB:B:B:BYFB^B\B`BB#B:\B:B:BMBOBQBSBTBBB:B:B\Bc\BBBBBV\FFBZ\ÄExit block VALIDATE-ATTACH-FLAVOR-HASHBBBTBBB9B;B<FlB_BBBBBBBl:B\F	FF\BgB\BgBFBiQPFGIIPUQ	.&
PPQPPP
PPQHQJJSK
PPKQHQPJPPPPCQGQJ\POBB=@F$$B:BV]FB:B:B:BYFB^B\BBuB:\B:B:BMB:B:B:B4\Bc\
BBBBB8BBBBBByBBpBG2078F;BBBBB{PPTPPPJCCPJCDցQEESFPPFrPXEQ	J!BJ!B\QQP
QC`OBB@F	$B:BV]FB:B:B:BYFB^B\BBuB:\B:B:BM\Bc\BByBB{QQPQC`OBCVALIDATE-ATTACH-STRUCT-AVL/u@FF$B:BV]FB:B:B:BYFB^B\B`BB#B:\BBB:B:BB#CFN\Bc\
*SEVENTHBBFOURTHBBBBBBBBB9pBG2134FFBBBBBBBpB\DEFSTRUCT-DESCRIPTIONBpB\lASSOC-EQLB;B?BuÁPROJECT-STRUCTBPPTP	PPJCBPJCCւQ
AJ!BJ!B\R:PPQ^B@RQBBSDEFPPQDQF@QEREQBBF+RBQP8QQPQPAQQQQAQCQP8OBVALIDATE-ATTACH-STRUCT-HEAPE@F*$B:BV]FB:B:B:BYFB^B \B`BB#B:\BB:BB#B\Bc\BBBBBBB9BBBBBBB;B<B>B?5R&PPQ^B@RQAASBCDPPQBQ	D@Q
CRCQBBD+RAQQPQPQCO,B VALIDATE-ATTACH-STRUCT-HASH S@F3$B:BV]FB:B:B:BYFB^B-\B`BB#B:\B:B:BMBOBQBSBTBBB:B:BB#B\Bc\BBBBBBV\FFBZ\ÄExit block VALIDATE-ATTACH-STRUCT-HASHBBTBB9B;B<FdB_BBBBBB\F	F\BgB-\BgB-FBiQPFGIIPUQ.&	PPQ
^BHQJJSKLM	PPQKQ
MHQLLQBBM+JPPPPCQGQJ\POHB-BD@F$B:BV]FB:B:B:BYFB^BD\BBuB:\B:B:BM\Bc\BByB3B{5PXQQPQC`OTBDBF@F	$B:BV]FB:B:B:BYFB^BF\BBuB:\B:B:BM\Bc\BByB3B{QQPQC`O`BFDETACH-RELATION-SAVE
F
F$B:BV]FB:B:B:BYFB^Ba\B`BaB:B:\Bc\BBBkB8B;B<BpBTlDUMP-FORMS-TO-FILEQPPPQP	OnBaDETACH-RELATION>h`>pF$B:BV]FB:B:B:BYFB^Bo\	B`BBBBDISKB
BaBB:\BBxB
BaBBBBBBB:B:\Bc\BBBBBBBBB,Detach data in an existing relation into a variable or onto the disk.

   RELATION-NAME - The name of the relation from which the data is to be detached.
   DISK          - If T, RTMS stores the data in the file specified in the PATHNAME.
   MEMORY        - If set to T, the detached data is stored in the variable rtms:*attach-detach-data*.
                   If any variable name is supplied, the data will be stored in it.
   PATHNAME      - Name of the file in which the detached data is to be saved.BBkBgу*ACTIVE-DB*BfÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PARAMETER-CHECKING*\DISKBBBACTIVE-DATABASEÁVALIDATE-NAMEB҃DE-NEST-KEYWORD-LISTB\BBBBB`BQTRIEVEBr,ERROR - BtBu, is not a relation in database e.jWRITE-CHAR\BBxBB\BB\BBk\BxB>l;BBBBpages used inpBG2268FBBBlERROR - Directory , does not existlRelation , will now be detached from the l databaseBBThe relation  is empty, nothing to outputB;B<Ba has been sucessfully detached@@QPA
QQRQ@Q@P	PPPPPQBDPQPPPRDWFD[HDSD
P@Q@ P@Q!BI"P@Q!BGIG#PI$P$P@Q!%@G7&PGQ'EGQJEk(D)PDQGQ*G+P,P-PT.P/P,PJCJPJCKGQ0J!BJ!B\BB'
1PDQ2PR3PQ4PP5PQFQHQ6Q@Q7
8PQ9PRIIQQ:P;IQQ:P;GQGQ<Q@Q7
3PQ=PROBoB	@	F$B:BV]FB:B:B:BYFB^B\B`BBB:B:B:B$BlRELATION-,-EMPTYPBB'PPQPP@Q@
OBRELATION-HASH-EMPTYP	@	\F$B:BV]FB:B:B:BYFB^B\B`B:\B:B:BMBOBQBSB:\BV\FBZ\Exit block RELATION-HASH-EMPTYPF \F\BgBB;B<BiFFPUPPCQPJ\POBB@F$B:BV]FB:B:B:BYFB^B\BÀTUPLEB:\B:B:BM\ByBP?BXOBRELATION-HEAP-EMPTYP	F@F$B:BV]FB:B:B:BYFB^B\B`B:B:B:B;B<QP_OBRELATION-AVL-EMPTYP	F@F$B:BV]FB:B:B:BYFB^B\B`B:B:B:B;B<QP_OB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\Bx\B2=\BaM*\B8(̢\B[\B*j\B=#\B\B:}n\B-i\B~z\B<p\B`sN\B|\B.ً\Be<<elation-name
 (string-upcase x))))
 temp)))
       (return-from validate-attach-struct-avl nil)
       (if (not (equal (seventh data) fn))
   (return-from validate-attach-struct-avl nil))))
       attr)
     (cond ((null (get relation-name 'entry-point))
    (putp relation-name data 'entry-point))
   (t
    (insert relation-name
    'tuples (project-struct list-data attr attr relation-name))))
     (return-from validate-attach-struct-avl (length listLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540638. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749845915. :AUTHOR "REL3" :LENGTH-IN-BYTES 70839. :LENGTH-IN-BLOCKS 70. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
1;;; AVL
;;;
;;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp
;;; Reference
;;;     firstn
;;;     nleft
;;;     errset
;;;
;;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not
;;; effect the functionality of RTMS.
;;;     process-subtree-flavor
;;;     process-subtree-flavor-left
;;;     insert-flavor-avl
;;;     insert-avl-flavor
;;;     flavor-avl-key-traversal
;;;*
(defun process-subtree-list (sub-tree termination-clause temp-attribute-list mode
     &aux results tuples)
  (cond ((and (not (null sub-tree)) (not (string-equal mode "TERMINATE")))
 (cond ((super-fast-eval-where (first sub-tree) temp-attribute-list termination-clause)
(setf results (nconc (process-subtree-list-left (third sub-tree)) results))
(setf results (append (first sub-tree) results))
(multiple-value-setq (tuples mode)
  (process-subtree-list (fourth sub-tree) termination-clause temp-attribute-list mode))
(setf results (append tuples results)))
       (t
(multiple-value-setq (tuples mode)
  (process-subtree-list (third sub-tree) termination-clause temp-attribute-list mode))
(setf results (append tuples results))
(setf mode "2TERMINATE"*)))))
  (values results mode))

(defun process-subtree-flavor (sub-tree termination-clause temp-attribute-list mode
       &aux results tuples)
  (cond ((and (not (null sub-tree)) (not (string-equal mode "TERMINATE")))
 (cond ((super-fast-eval-where (project-flavor (first sub-tree) temp-attribute-list temp-attribute-list)
       temp-attribute-list termination-clause)
(setf results (nconc (process-subtree-flavor-left (third sub-tree) temp-attribute-list)
     results))
(setf results (append (project-flavor (first sub-tree) temp-attribute-list temp-attribute-list)
      results))
(multiple-value-setq (tuples mode)
     (process-subtree-flavor (fourth sub-tree) termination-clause
     temp-attribute-list mode))
(setf results (append tuples results)))
       (t
(multiple-value-setq (tuples mode)
     (process-subtree-flavor (third sub-tree) termination-clause
     temp-attribute-list mode))
(setf results (append tuples results))
(setf mode "2TERMINATE"*)))))
  (values results mode))

(defun process-subtree-struct (sub-tree termination-clause temp-attribute-list mode relation-name
       &aux results tuples)
  (cond ((and (not (null sub-tree))(not (string-equal mode "TERMINATE")))
 (cond ((super-fast-eval-where (project-struct (first sub-tree) temp-attribute-list temp-attribute-list
       relation-name)
       temp-attribute-list termination-clause)
(setf results (nconc (process-subtree-struct-left (third sub-tree) temp-attribute-list
  relation-name) results))
(setf results (append (project-struct (first sub-tree) temp-attribute-list temp-attribute-list
      relation-name)
      results))
(multiple-value-setq (tuples mode)
     (process-subtree-struct (fourth sub-tree) termination-clause
     temp-attribute-list mode relation-name))
(setf results (append tuples results)))
       (t
(multiple-value-setq (tuples mode)
     (process-subtree-struct (third sub-tree) termination-clause
     temp-attribute-list mode relation-name))
(setf results (append tuples results))
(setf mode "2TERMINATE"*)))))
  (values results mode))


(defun process-subtree-list-left (sub-tree &aux results)
  (cond ((car sub-tree)
 (if (third sub-tree)
     (setf results (append (process-subtree-list-left (third sub-tree)) results)))
 (setf results (append (first sub-tree) results))
 (if (fourth sub-tree)
     (setf results (append (process-subtree-list-left (fourth sub-tree)) results)))
 results)))

(defun process-subtree-flavor-left (sub-tree attribute-list &aux results)
  (cond ((car sub-tree)
 (cond ((third sub-tree)
(setf results (append (process-subtree-flavor-left (third sub-tree) attribute-list) results))))
 (setf results (append (project-flavor (first sub-tree) attribute-list attribute-list) results))
 (cond ((fourth sub-tree)
(setf results (append (process-subtree-flavor-left (fourth sub-tree) attribute-list) results))))
 results)))

(defun process-subtree-struct-left (sub-tree attribute-list relation-name &aux results)
  (cond ((car sub-tree)
 (cond ((third sub-tree)
(setf results (append (process-subtree-struct-left (third sub-tree) attribute-list
   relation-name) results))))
 (setf results (append (project-struct (first sub-tree) attribute-list attribute-list relation-name)
       results))
 (cond ((fourth sub-tree)
(setf results (append (process-subtree-struct-left (fourth sub-tree) attribute-list
   relation-name) results))))
 results)))

(defun retrieve-avl  (relation-name attribute-list project-list key where-clause key-value imp index-name
      &aux all-tuples (tuples nil) domains temp-attribute-list termination-condition mode
      results)
  ;;
  ;;1  Note that keyed retrieval from an AVL tree does not guarantee sorted order when there are multiple parts.*
  ;;
  (cond ((null key-value)
 (setf tuples (nreverse (eval-where (avl-inorder-traversal (getp index-name 'entry-point))
  attribute-list where-clause imp relation-name)))
 (setf temp-attribute-list attribute-list))
(t
 ;;
 ;;1  The key passed is of the form :*
 ;;1            (list-of-key-attributes-present-the-key*
 ;;1             list-of-starting-values*
 ;;1             list-of-ending-values)*
 ;;
 (setf domains (caar (funcall
       (find-symbol (concatenate 'string "RETRIEVE-"
 *system-relation-base-implementation*
 "-" *system-relation-storage-structure*) *pkg-string*)
       'system-relation *system-relation-attributes* '("DOMAINS") *system-relation-key*
       `(string-equal relation-name ,(string-upcase relation-name))
       nil 'system-relation)))
 (setf all-tuples (getp index-name 'entry-point)
       key (firstn (length (caar key-value)) key)
       domains (car (project-list (list domains) attribute-list key)))
 ;;
 ;;1  Take each key extracted from the WHERE clause and retrieve the tuples selected by the individual keys.*
 ;;
 ;;
 (do ((key% (first key-value) (cdr key%))
      (beginning-value% (second key-value) (cdr beginning-value%))
      (termination-clause% (third key-value) (cdr termination-clause%)))
     ((null key%) tuples)
   (cond ((equal (caar termination-clause%) t)
  (setf termination-condition t))
 (t
  (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
   ;;
   ;;1  Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
   ;;1 the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to FAST-EVAL-WHERE.*
   ;;
   (multiple-value-setq (termination-condition temp-attribute-list)
     (eval-where-prereq termination-condition attribute-list relation-name))
   (progv temp-attribute-list nil
     (multiple-value-setq (results mode)
       (funcall (find-symbol (concatenate 'string (string-upcase imp)2 "-AVL-KEY-TRAVERSAL"*)
     *pkg-string*)
all-tuples (car key%) domains (car beginning-value%) termination-condition "LOCATE"
temp-attribute-list relation-name)))
   (setf tuples (append (eval-where  results (convert-attributes temp-attribute-list) where-clause
     "2LIST"* relation-name)
tuples)))
 (setf tuples (nreverse tuples))))
  (setf tuples (project-list tuples temp-attribute-list (unconvert-attributes project-list)))
   tuples)


(defun extract-key-avl (attribute-list key-list domains where-clause package-name
 &aux key-domains (opt-func-list nil) result opt-func)
  ;1;*
  ;1;  This should be done before any of the extract key functions are called in retrieve*
  ;1;*
  (setf attribute-list (unconvert-attributes attribute-list package-name)
key-list (unconvert-attributes key-list package-name)
domains (unconvert-attributes domains package-name))
  (cond ((not (or (not (listp where-clause)) (equal where-clause '(t))))
 (setf key-domains (car (project-list (list domains) attribute-list key-list)))
 ;1;*
 ;1;  Determine if the controllin function of the subclause is one of the optimization function which RTMS is aquainted.*
 ;1;*
 (cond ((listp where-clause)
;1;*
;1;  Obtain a list of the optimization functions which are known to RTMS at this time. The values come back from*
;1; retrieve as a list of lists. Remove the extra set of lists from the values. This list will be used in all of the *
;1; optimization functions.*
;1;*
(setf opt-func-list
      (funcall
(find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation*
  "-" *system-relation-storage-structure*) *pkg-string*)
'system-optfunc *system-optfunc-attributes* '(symbol-name optimize-function)
*system-optfunc-key* (list 'string-equal 'storage-structure-type "AVL") nil
'system-optfunc)))
       (t
(setf opt-func-list nil)))
 (cond ((setf opt-func (cadr (assoc (car where-clause) opt-func-list :test 'string-equal)))
(cond ((string-equal opt-func "OPT-AVL-AND")
       (setf result (opt-avl-and attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-AVL-EQUAL")
       (setf result (opt-avl-equal attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-AVL-GT")
       (setf result (opt-avl-gt attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-AVL-LT")
       (setf result (opt-avl-lt attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-AVL-OR")
       (setf result (opt-avl-or attribute-list key-list where-clause opt-func-list)))
      (t
       (setf result (funcall (find-symbol opt-func *pkg-string*)
     attribute-list key-list where-clause opt-func-list))))
;1;*
;1;  Now that the key has been formed, further processing is required to identify any possible*
;1; overlapping in multiple keys*
;1;*
(cond ((string-equal (car result) "k")
       (setf result (append (list (second result)) (list (third result)) (list (fifth result))))
       (setf result (reduce-avl-key key-list key-domains (first result) (second result)
    (third result))))
      (t
       (setf result nil))))
       (t
(setf result nil))))
(t
 (setf result nil)))
  result)


(defun insert-list-avl (relation-name attribute-list tuples key-list index-name)
  (let (domain-key-list domain-list key new-element tree)
    (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
   (setf domain-key-list (eval (read-from-string (concatenate 'string *pkg-string* "2:*"*
      (string-upcase relation-name)
      "2-KEY-DOMAINS*"*)))))
  (t
   (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
    *system-relation-key*
    (list 'string-equal 'relation-name (string-upcase relation-name))))
 domain-key-list (car (project-list (list domain-list) attribute-list key-list)))))
    (setf key (project-list tuples attribute-list key-list)
  tree (getp index-name 'entry-point))
    (do ((tuple% tuples (cdr tuple%))
 (key% key (cdr key%)))
((null tuple%) t)
      (setf *bf* 1
    *node-inserted* nil
    *equal-inserted* nil)
      (setf new-element (cons (list (car tuple%)) (append (list 0) (list nil) (list nil)))
    tree (insert-avl-list new-element tree (car key%) key-list attribute-list domain-key-list nil
  index-name)))
    (putp index-name tree 'entry-point)
    tuples))

(defun insert-flavor-avl (relation-name attribute-list tuples key-list index-name)
  (let (domain-key-list domain-list flavor-tuples key new-element tree
(string-relation-name (string-upcase relation-name)))
    (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
   (setf domain-key-list (eval (read-from-string (concatenate 'string *pkg-string* "2:*"*
      string-relation-name "2-KEY-DOMAINS*"*)))))
  (t
   (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
    *system-relation-key*
    (list 'string-equal 'relation-name (string-upcase relation-name))))
 domain-key-list (car (project-list (list domain-list) attribute-list key-list)))))
    (setf key (project-list tuples attribute-list key-list)
  tree (getp index-name 'entry-point))
    ;;
    ;;1 Insert one tuple at a time into the AVL tree*
    ;;
    (setf attribute-list (unconvert-attributes attribute-list *pkg-name*)
  relation-name (read-from-string (concatenate 'string *pkg-name* string-relation-name)))
    (setf flavor-tuples (mapcar (function
  (lambda (tuple keyval &aux %tuple)
    ;;
    ;;1Insert the tuple into the hash table using heap formation for collisions.*
    ;;1Form the instance to be stored in the hash table.*
    ;;
    (setf %tuple (make-instance relation-name))
    (do ((tuple tuple (cdr tuple))
 (attribute-list attribute-list (cdr attribute-list)))
((null tuple) %tuple)
      (set-in-instance %tuple (car attribute-list) (car tuple)))
    (setf *bf* 1
  *node-inserted* nil
  *equal-inserted* nil)
    ;;
    ;;1  Form the new element in a form suitable for insertion*
    ;;
    (setf new-element (cons (list %tuple)
    (append (list 0) (list nil) (list nil)))
  tree (insert-avl-flavor new-element tree keyval key-list
  attribute-list domain-key-list nil
  index-name))
    %tuple))
tuples key))
    (putp index-name tree 'entry-point)
    flavor-tuples))

(defun insert-struct-avl (relation-name attribute-list tuples key-list index-name)
  (let (domain-key-list domain-list key new-element relation-macro struct-tuples tree
(string-relation-name (string relation-name)))
    (cond ((member string-relation-name *system-relations* :test 'string-equal)
   (setf domain-key-list (eval (read-from-string (concatenate 'string *pkg-string* "2:*"*
      string-relation-name
      "2-KEY-DOMAINS*"*)))))
  (t
   (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
    *system-relation-key*
    (list 'string-equal 'relation-name string-relation-name)))
 domain-key-list (car (project-list (list domain-list) attribute-list key-list)))))
    (setf key (project-list tuples attribute-list key-list)
  tree (getp index-name 'entry-point)
  relation-macro (read-from-string (concatenate 'string *pkg-name* "MAKE-" string-relation-name)))
    ;;
    ;;1 Insert one tuple at a time into the AVL tree*
    ;;
    (setf attribute-list (unconvert-attributes attribute-list *pkg-name*))
    (setf relation-name (read-from-string (concatenate 'string *pkg-name* string-relation-name)))
    (setf attribute-list
  (mapcar #'(lambda (attr)
      (read-from-string (concatenate 'string ":" string-relation-name (string-upcase attr))))
  attribute-list))
    (setf struct-tuples (mapcar (function
  (lambda (tuple keyval &aux %tuple attribute-value)
    ;;
    ;;1Insert the tuple into the hash table using heap formation for collissions.*
    ;;1Form the instance to be stored in the hash table.*
    ;;
    (do ((tuple tuple (cdr tuple))
 (attribute-list attribute-list (cdr attribute-list)))
((null tuple) %tuple)
      (push `(quote ,(car tuple)) attribute-value)
      (push (car attribute-list) attribute-value)
      (setf %tuple (eval `(,relation-macro ,@attribute-value))))
    (setf *bf* 1
  *node-inserted* nil
  *equal-inserted* nil)
    ;;
    ;;1  Form the new element in a form suitable for insertion*
    ;;
    (setf new-element (cons (list %tuple)
    (append (list 0) (list nil) (list nil)))
  tree (insert-avl-struct new-element tree keyval key-list
  attribute-list domain-key-list nil
  relation-name))
    %tuple))
tuples key))
    (putp index-name tree 'entry-point)
    struct-tuples))

(defun insert-avl-list (new-element tree key key-list attribute-list domain-key-list rebalancep relation-name
&aux comparison-operator current-node-key mod-tree)
  relation-name
  (cond ((equal tree nil)
  (setf rebalancep t
tree new-element))
 (t
  ;;
  ;;1  This next line is the only accessor dependant part of the entire function. This call needs to be moved*
  ;;1 into another function to prevent the calling of FUNCALL READ-FROM-STRING nonsence from occuring many times.*
  ;;
  (setf current-node-key (car (project-list (list (caar tree)) attribute-list key-list)))
  (setf comparison-operator (node-compare key current-node-key domain-key-list))
  (cond ((equal comparison-operator 'less-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-list new-element (caddr tree) key key-list attribute-list domain-key-list
    rebalancep relation-name))
 (rplaca (cddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (left-balance tree rebalancep)))))
((equal comparison-operator 'greater-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-list new-element (cadddr tree) key key-list attribute-list domain-key-list
    rebalancep relation-name))
 (rplaca (cdddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (right-balance tree rebalancep)))))
((equal comparison-operator 'equal)
 (multiple-value-setq (tree rebalancep)
   (insert-avl-equal tree new-element rebalancep))))))
  (values tree rebalancep))


(defun insert-avl-flavor (new-element tree key key-list attribute-list domain-key-list rebalancep relation-name
&aux comparison-operator current-node-key mod-tree)
  (cond ((equal tree nil)
  (setf rebalancep t
tree new-element))
 (t
  ;;
  ;;1  This next line is the only accessor dependant part of the entire function. This call needs to be moved*
  ;;1 into another function to prevent the calling of FUNCALL READ-FROM-STRING nonsence from occuring many times.*
  ;;
  (setf current-node-key (car (project-flavor (list (caar tree))attribute-list key-list relation-name)))
  (setf comparison-operator (node-compare key current-node-key domain-key-list))
  (cond ((equal comparison-operator 'less-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-flavor new-element (caddr tree) key key-list attribute-list domain-key-list
      rebalancep relation-name))
 (rplaca (cddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (left-balance tree rebalancep)))))
((equal comparison-operator 'greater-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-flavor new-element (cadddr tree) key key-list attribute-list domain-key-list
      rebalancep relation-name))
 (rplaca (cdddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (right-balance tree rebalancep)))))
((equal comparison-operator 'equal)
 (multiple-value-setq (tree rebalancep)
   (insert-avl-equal tree new-element rebalancep))))))
  (values tree rebalancep))

(defun insert-avl-struct (new-element tree key key-list attribute-list domain-key-list rebalancep relation-name
&aux comparison-operator current-node-key mod-tree)
  (cond ((equal tree nil)
  (setf rebalancep t
tree new-element))
 (t
  ;;
  ;;1  This next line is the only accessor dependant part of the entire function. This call needs to be moved*
  ;;1 into another function to prevent the calling of FUNCALL READ-FROM-STRING nonsence from occuring many times.*
  ;;
  (setf current-node-key (car (project-struct (list (caar tree)) attribute-list key-list
      relation-name))
comparison-operator (node-compare key current-node-key domain-key-list))
  (cond ((equal comparison-operator 'less-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-struct new-element (caddr tree) key key-list attribute-list domain-key-list
      rebalancep relation-name))
 (rplaca (cddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (left-balance tree rebalancep)))))
((equal comparison-operator 'greater-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-struct new-element (cadddr tree) key key-list attribute-list domain-key-list
      rebalancep relation-name))
 (rplaca (cdddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (right-balance tree rebalancep)))))
((equal comparison-operator 'equal)
 (multiple-value-setq (tree rebalancep)
   (insert-avl-equal tree new-element rebalancep))))))
  (values tree rebalancep))

(defun insert-avl-equal (tree new-element rebalancep)
  (rplaca tree (append (car new-element) (car tree)))
  (setf rebalancep nil)
  (values tree rebalancep))

(defun left-balance (tree rebalancep
     &aux left-branch right-branch)
  (cond ((equal (cadr tree) -1)
 (rplaca (cdr tree) 0)
 (setf rebalancep nil))
((equal (cadr tree) 0)
 (rplaca (cdr tree) 1))
((equal (cadr tree) 1)
 (setf left-branch (caddr tree))
 (cond ((equal (cadr left-branch) 1)
;;
;;1  LL rotation*
;;
(rplaca (cddr tree) (cadddr left-branch))
(rplaca (cdddr left-branch) tree)
(rplaca (cdr tree) 0)
(setf tree left-branch)
)
       (t
;;
;;1  LR rotation*
;;
(setf right-branch (cadddr left-branch))
(rplaca (cdddr left-branch) (caddr right-branch))
(rplaca (cddr right-branch) left-branch)
(rplaca (cddr tree) (cadddr right-branch))
(rplaca (cdddr right-branch) tree)
(cond ((equal (cadr right-branch) 1)
       (rplaca (cdr tree) -1))
      (t
       (rplaca (cdr tree) 0)))
(cond ((equal (cadr right-branch) -1)
       (rplaca (cdr left-branch) 1))
      (t
       (rplaca (cdr left-branch) 0)))
(setf tree right-branch)))
 (rplaca (cdr tree) 0)
 (setf rebalancep nil)))
  (values tree rebalancep))

(defun right-balance (tree rebalancep &aux left-branch right-branch)
  (cond ((equal (cadr tree) 1)
 (rplaca (cdr tree) 0)
 (setf rebalancep nil))
((equal (cadr tree) 0)
 (rplaca (cdr tree) -1))
((equal (cadr tree) -1)
 (setf right-branch (cadddr tree))
 (cond ((equal (cadr right-branch) -1)
(rplaca (cdddr tree) (caddr right-branch))
(rplaca (cddr right-branch) tree)
(rplaca (cdr tree) 0)
(setf tree right-branch))
       (t
(setf left-branch (caddr right-branch))
(rplaca (cddr right-branch) (cadddr left-branch))
(rplaca (cdddr left-branch) right-branch)
(rplaca (cdddr tree) (caddr left-branch))
(rplaca (cddr left-branch) tree)
(cond ((equal (cadr left-branch) -1)
       (rplaca (cdr tree) 1))
      (t
       (rplaca (cdr tree) 0)))
(cond ((equal (cadr left-branch) 1)
       (rplaca (cdr right-branch) -1))
      (t
       (rplaca (cdr right-branch) 0)))
(setf tree left-branch)))
 (rplaca (cdr tree) 0)
 (setf rebalancep nil)))
  (values tree rebalancep))


(defun avl-inorder-traversal (avl-tree &aux tuple-list)
  (cond ((car avl-tree)
 (if (third avl-tree)
     (setf tuple-list (append (avl-inorder-traversal (third avl-tree))tuple-list)))
 (setf tuple-list (append (first avl-tree) tuple-list))
 (if (fourth avl-tree)
     (setf tuple-list (append (avl-inorder-traversal (fourth avl-tree)) tuple-list)))
 tuple-list)))

(defun avl-node-traversal (avl-tree &aux tuple-list tuple)
  (cond ((null (car avl-tree)) avl-tree)
(t
 (setf tuple (avl-node-traversal (third avl-tree)))
 (if tuple
     (setf tuple-list (cons tuple tuple-list)))
 (if (first avl-tree)
     (setf tuple-list (cons (print (first avl-tree)) tuple-list)))
 (setf tuple (avl-node-traversal (fourth avl-tree)))
 (if tuple
     (setf tuple-list (cons tuple tuple-list)))
 tuple-list)))

(defun list-avl-key-traversal (all-tuples key-attributes domains beginning-value termination-clause mode
       temp-attribute-list relation-name
&aux comparison-operator current-node-key-value temp-results tuples results)
  ;1;*
  ;1;  Locate the node where the search will begin*
  ;1;*
  (cond ((and (not (equal all-tuples nil))
      (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)))
 (setf current-node-key-value (car (project-list (list (caar all-tuples)) temp-attribute-list
 key-attributes)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator(node-compare beginning-value  current-node-key-value domains))))
 (cond ((string-equal comparison-operator 'equal)
;1;*
;1;  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;1; node in the tree which is equivalent with the current key value. This is because the key used in the retrieval*
;1; may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;1; the node is no longer equal.*
;1;*
;1;*
;1;  The current node is equal to the beginning condition, continue down the left branch until this condition*
;1; no longer exists.*
;1;*
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (results mode)
  (list-avl-key-traversal (caddr all-tuples) key-attributes domains beginning-value
  termination-clause mode temp-attribute-list relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree -- must return mode, results*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (first all-tuples) temp-attribute-list
termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-list (fourth all-tuples) termination-clause
      temp-attribute-list mode))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (list-avl-key-traversal (caddr all-tuples) key-attributes domains beginning-value
  termination-clause mode temp-attribute-list relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (first all-tuples)
temp-attribute-list termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-list (fourth all-tuples) termination-clause temp-attribute-list
      mode))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (list-avl-key-traversal (cadddr all-tuples) key-attributes domains beginning-value
  termination-clause mode temp-attribute-list relation-name))
;1;*
;1;  Check the current node for satisfaction of the termination clause if it does process the right subtree else*
;1; terminate *
;1;*
(cond ((and (not (and (not (string-equal mode 'terminate))
      (super-fast-eval-where (first  all-tuples) temp-attribute-list
     termination-clause)))
    (first all-tuples))
       (setf mode "TERMINATE")))))))
  (values results mode))

(defun flavor-avl-key-traversal (all-tuples key-attributes domains beginning-value termination-clause mode
  temp-attribute-list relation-name
  &aux comparison-operator current-node-key-value temp-results tuples results )
  ;1;*
  ;1;  Locate the node where the search will begin*
  ;1;*
  (cond ((and (not (equal all-tuples nil))
      (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)))
 (setf current-node-key-value (car (project-flavor (list (caar all-tuples)) temp-attribute-list
   key-attributes relation-name)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator (node-compare beginning-value  current-node-key-value domains))))
 (cond ((string-equal comparison-operator 'equal)
;1;*
;1;  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;1; node in the tree which is equivalent with the current key value. This is because the key used in the retrieval*
;1; may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
1;; the node is no longer equal.*
;1;*
;1;*
;1;  The current node is equal to the beginning condition, continue down the left branch until this condition*
;1; no longer exists.*
;1;*
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (results mode)
  (flavor-avl-key-traversal (caddr all-tuples) key-attributes domains beginning-value
    termination-clause mode temp-attribute-list relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree -- must return mode, results*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (project-flavor (first all-tuples)
temp-attribute-list
temp-attribute-list
relation-name)
temp-attribute-list
termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-flavor (fourth all-tuples) termination-clause
temp-attribute-list mode))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (flavor-avl-key-traversal (caddr all-tuples) key-attributes domains beginning-value
    termination-clause mode temp-attribute-list relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (project-flavor (first all-tuples)
temp-attribute-list
temp-attribute-list
relation-name)
temp-attribute-list
termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-flavor (fourth all-tuples) termination-clause
temp-attribute-list mode))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (flavor-avl-key-traversal (cadddr all-tuples) key-attributes domains beginning-value
    termination-clause mode temp-attribute-list relation-name))
;1;*
;1;  Check the current node for satisfaction of the termination clause if it does process the right subtree else*
;1; terminate *
;1;*
(cond ((and (not (and (not (string-equal mode 'terminate))
      (super-fast-eval-where (project-flavor (first  all-tuples)
     temp-attribute-list
     temp-attribute-list
     relation-name)
       temp-attribute-list termination-clause)))
    (first all-tuples))
       (setf mode "TERMINATE")))))))
  (values results mode))


(defun struct-avl-key-traversal (all-tuples key-attributes domains beginning-value termination-clause mode
 temp-attribute-list relation-name
 &aux results string-temp-attributes)
  (multiple-value-setq (termination-clause temp-attribute-list)
    (eval-where-prereq termination-clause (convert-attributes temp-attribute-list) relation-name))
  (setf string-temp-attributes (convert-attributes temp-attribute-list))
  (progv temp-attribute-list nil
    (multiple-value-setq (results temp-attribute-list mode)
      (struct-avl-key-traversal-2 all-tuples (convert-attributes key-attributes) domains beginning-value
  termination-clause mode temp-attribute-list string-temp-attributes
  relation-name))))

(defun project-struct-fast (tuples attribute-list project-list relation-name)
  attribute-list relation-name
  (mapcar (function (lambda (tuple)
      (mapcar (function (lambda (attr)
  (funcall attr tuple)))
      project-list)))
  tuples))

(defun struct-avl-key-traversal-2 (all-tuples key-attributes domains beginning-value termination-clause mode
  temp-attribute-list string-temp-attributes relation-name
  &aux comparison-operator current-node-key-value temp-results tuples results )
  ;1;*
  ;1;  Locate the node where the search will begin*
  ;1;*
  (cond ((and (not (equal all-tuples nil))
      (or (string-equal mode 'locate)
  (string-equal mode 'locate-stage-2)))
 (setf current-node-key-value (car (project-struct (list (caar all-tuples)) string-temp-attributes
   key-attributes relation-name)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator
      (node-compare beginning-value  current-node-key-value domains))))
 (cond ((string-equal comparison-operator 'equal)
;1;*
;1;  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;1; node in the tree which is equivalent with the current key value. This is because the key used in the retrieval*
;1; may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;1; the node is no longer equal.*
;1;*
;1;*
;1;  The current node is equal to the beginning condition, continue down the left branch until this condition*
;1; no longer exists.*
;1;*
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (results mode)
  (struct-avl-key-traversal-2 (caddr all-tuples) key-attributes domains beginning-value
      termination-clause mode temp-attribute-list
      string-temp-attributes relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree -- must return mode, results*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (project-struct (first all-tuples)
string-temp-attributes
string-temp-attributes
relation-name)
temp-attribute-list termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-struct (fourth all-tuples) termination-clause
temp-attribute-list mode relation-name))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (struct-avl-key-traversal-2 (caddr all-tuples) key-attributes domains beginning-value
      termination-clause mode temp-attribute-list
      string-temp-attributes relation-name))
(cond ((not (string-equal mode 'terminate))
       ;1;*
       ;1;  Need to process the right subtree*
       ;1;*
       (cond ((setf temp-results (super-fast-eval-where (project-struct (first all-tuples)
string-temp-attributes
string-temp-attributes
relation-name)
temp-attribute-list termination-clause))
      (setf results (append temp-results results))
      (multiple-value-setq (tuples mode)
(process-subtree-struct (fourth all-tuples) termination-clause
temp-attribute-list mode relation-name))
      (setf results (append tuples results)))
     ((first all-tuples)
      (setf mode "TERMINATE"))))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (results mode)
  (struct-avl-key-traversal-2 (cadddr all-tuples) key-attributes domains beginning-value
      termination-clause mode temp-attribute-list
      string-temp-attributes relation-name))
;1;*
;1;  Check the current node for satisfaction of the termination clause if it does process the right subtree else*
;1; terminate *
;1;*
(cond ((and (not (and (not (string-equal mode 'terminate))
      (super-fast-eval-where (project-struct (first  all-tuples)
     string-temp-attributes
     string-temp-attributes
     relation-name)
       temp-attribute-list termination-clause)))
    (first all-tuples))
       (setf mode "TERMINATE")))))))
  (values results mode))


;1;*;1 This routine compares the two nodes which have the specified domains. It will return EQUAL, LESS-THAN or GREATER-THAN, indicating *
;1;; the relationship of the first node to the second.*
(defun node-compare (key-list-1 key-list-2 key-domain-list
     &aux comparison-operator val1 val2)
  (setf comparison-operator 'equal)
  ;1;*
  ;1;  It is assumed that the key lists are of the same length, this should*
  ;1; always be the case.*
  ;1;*
  (do ((key1 key-list-1 (cdr key1))
       (key2 key-list-2 (cdr key2))
       (domain key-domain-list (cdr domain)))
      ((or (null key1)
   (not (equal comparison-operator 'equal))) comparison-operator)
    ;;
    ;;1  This section of the code has been rewritten to handle the domains which are defined by
     *;;1 RTMS explicitly. This loss in generality was necessitated by the lack of speed caused*
    ;;1 by the FUNCALLing for each comparison.*
    ;;
    (cond ((string-equal (car domain) "NUMBERP")
   (cond ((= (car key1)(car key2))
  )
 ((< (car key1) (car key2))
  (setf comparison-operator 'less-than))
 (t
  (setf comparison-operator 'greater-than))))
  ((string-equal (car domain) "STRINGP")
   (cond ((string-equal (car key1) (car key2))
  )
 ((string-lessp (car key1) (car key2))
  (setf comparison-operator 'less-than))
 (t
  (setf comparison-operator 'greater-than))))
  ((string-equal (car domain) "ATOM")
   (setf val1 (car key1))
   (setf val2 (car key2))
   (cond ((and (numberp val1) (numberp val2))
  (cond ((= val1 val1)
 (setf comparison-operator 'equal))
((< val1 val2)
 (setf comparison-operator 'less-than))
(t
 (setf comparison-operator 'greater-than))))
 ((and (stringp val1) (stringp val2))
  (cond ((string-equal val1 val2)
 (setf comparison-operator 'equal))
((string-lessp val1 val2)
 (setf comparison-operator 'less-than))
(t
 (setf comparison-operator 'greater-than))))
 ((numberp val2)
  (setf comparison-operator 'greater-than))
 ((numberp val1)
  (setf comparison-operator 'less-than))
 (t
  (setf val1 (string val1)
val2 (string val2))
  (cond ((string-equal val1 val2)
 (setf comparison-operator 'equal))
((string-lessp val1 val2)
 (setf comparison-operator 'less-than))
(t
 (setf comparison-operator 'greater-than))))))
  ((string-equal (car domain) "2LISTP"*)
   (cond ((equal-listp (car key1) (car key2))
  )
 ((lt-listp (car key1) (car key2))
  (setf comparison-operator 'less-than))
 (t
  (setf comparison-operator 'greater-than))))
  ((string-equal (car domain) "2ANYP"*)
   (cond ((equal-anyp (car key1) (car key2))
  )
 ((lt-anyp (car key1) (car key2))
  (setf comparison-operator 'less-than))
 (t
  (setf comparison-operator 'greater-than))))
  ;1;*
  ;1;  This section can be made faster by having a function called COMPARE-domainname which will return EQUAL, LESS-THAn or*
  ;1; GREATER-THAN. This restricts the FUNCALLing to a single call.*
  ;;
  (t
   (cond ((not (funcall (find-symbol (concatenate 'string "EQUAL-" (string-upcase (car domain)))
     *pkg-string*) (car key1) (car key2)))
  (cond ((funcall (find-symbol (concatenate 'string "LT-" (string-upcase (car domain)))
       *pkg-string*) (car key1) (car key2))
 (setf comparison-operator 'less-than))
(t
 (setf comparison-operator 'greater-than))))))))
  comparison-operator)

'(defun compare-numberp (val1 val2)
  (block nil
  (cond ((= val1 val2)
 (return 'equal))
((< val1 val2)
 (return 'less-than))
(t
 (return 'greater-than)))))

;1;*;1 This function will process the rest of the where clause and determine if an avl key may be extracted. If so, the AVL key is returned.*
;1;*;1 The results returned from this function, as well as all* 1optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;;* 1list--of-lists-of-key-attributes-used*
;1;;*1 list-of-beginning-values*
;1;;*1 list-of-non-key-attributes-present*
;1;;*1 list-of-termination-predicates)*
;1;;*1  where*
;1;;*1stat-character - is one of the following :*
;1;;*1k - a valid key has been formed*
;1;;*1n - no key can be formed from where*
;1;;*1    clause (ever).*
;1;;*1p - it is still possible to form a*
;1;;*1    but this sub-clause will not*
;1;;*1    contribute to it.*
;1;;*1c - constant sub-clause - nothing to*
;1;;*1    add to the key.*
(defun opt-avl-and (attribute-list key-list where-clause opt-func-list
       &aux do-continue opt-func (result '("p" (nil) (nil) (nil) (nil))) (where-aux-list nil)
            (where-key-list nil) (where-val-list nil) (where-endval-list nil) element-index
    ref-endval ref-key ref-val resultant-endval resultant-key resultant-val
    temp-endval temp-key temp-val)
  ;;
  ;;1 Loop until all of the sub-clauses of the where-clause have been processed.*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond ((listp (car where-clause))
   ;;
   ;;1  The element is a list, must be a function call. Call the appropriate optimization function if one exists. Add the results from*
   ;1; the function to the current results. The optimization functions which are defined by RTMS initially are used as selections in*
   ;1; the following COND clause to improve the speed of calling these functions. If the function in the sub-clause is not from this*
   ;1; group, the function name must be formed before it can be invoked.*
   ;;
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-AVL-AND")
 (setf result (opt-avl-and attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-EQUAL")
 (setf result (opt-avl-equal attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-GT")
 (setf result (opt-avl-gt attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-LT")
 (setf result (opt-avl-lt attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-OR")
 (setf result (opt-avl-or attribute-list key-list (car where-clause) opt-func-list)))
(t
 (setf result (funcall (find-symbol opt-func *pkg-string*) attribute-list key-list
       (car where-clause) opt-func-list))))
  ;;
  ;;1  Add the results to the results lists*
  ;;
  (setf where-key-list (append where-key-list (car (second result)))
where-val-list (append where-val-list (car (third result)))
where-aux-list (append where-aux-list (car (fourth result)))
where-endval-list (append where-endval-list (car (fifth result)))))
 ;;
 ;;1  The function which drives this sub-clause is not defined to RTMS as a function which can be optimized, therefore*
 ;1; no key can be extracted and processing can be stopped.*
 ;;
 (t
  (setf result '("n" (nil) (nil) (nil) (nil))))))))
  ;;
  ;;1  The where-clause has been parsed, now let us see what we have*
  ;;
  (cond ((and where-key-list where-val-list)
 ;;
 ;;1  We have a possible key. Several things need to be tested before the final determination can be made.*
 ;;
 (setf result '(()()()()))
 (setf do-continue 't)
 ;;
 ;;1  Must determine if a key attribute is contained in the extracted key more than once. If so, must determine if this*
 ;;1 key is logically valid (i.e., (AND (< a1 100)(> a1 50))) and combine the occurances in a meaningful manner. *
 ;;1 (beginning value --> 50 and ending value --> 100) . The possible cases are given below :*
 ;;1                  1)  (AND (< a1 100)(> a1 50)) : begval --> 50 *
 ;;1                                                  endval --> 100*
 ;1;*1 2)  (AND (= a1 50)(> a1 100)) : Logically invalid. *
 ;1;*1 3)  (AND (> a1 50)(> a1 100)) : Logically weak but a key can be returned.*
 ;1;*1      begval --> 100*
 ;1;*1      endval --> T*
 ;1;*1 3)  (AND (< a1 50)(< a1 100)) : Logically weak but a key can be returned.*
 ;1;*1      begval --> T*
 ;1;*1      endval --> 100*
 ;1;*1 4) (AND (< a1 50) (> a1 100)) : Logically invalid. set key to NIL and return laughing.*
 ;1;*
 (setf do-continue t
       resultant-key nil
       resultant-val nil
       resultant-endval nil)
 (do ((key-list% where-key-list (cdr key-list%))
      (val-list% where-val-list (cdr val-list%))
      (endval-list% where-endval-list (cdr endval-list%)))
     ((or (null key-list%) (not do-continue)) t)
   (setf temp-key (first key-list%)
 temp-val (first val-list%)
 temp-endval (first endval-list%)
 ref-key (first key-list%)
 ref-val (first val-list%)
 ref-endval (first endval-list%))
   (do ((key% (cdr key-list%) (cdr key%))
(val% (cdr val-list%) (cdr val%))
(endval% (cdr endval-list%) (cdr endval%)))
       ((or (null key%) (not do-continue)) t)
     (cond ((string-equal temp-key (first key%))
    ;;
    ;;1  A multiple occurance of the same key attribute in the AND clause has been found, process accordingly*
    ;;
    (cond ((equal temp-val temp-endval)
   ;;
   ;;1  An equal key has occured, determine if the other key overlaps with it, if not then the user has*
   ;1; specified an invalid where clause. SInce one of the keys has the same value for the upper and lower*
   ;1; bounds the same, the other key can not modify the key values.*
   ;;
   (cond ((not (and (gep temp-val (first val%)) (lep temp-val (first endval%))))
  (setf do-continue nil
temp-key nil))))
  ;;
  ;;1  An equal key has occured, determine if the other key overlaps with it, if not then the user has*
  ;1; specified an invalid where clause. SInce one of the keys has the same value for the upper and lower*
  ;1; bounds the same, the other key can not modify the key values.*
  ;;
  ((equal (first val%) (first endval%))
   (cond ((and (gep (first val%) temp-val)
       (lep (first val%) temp-endval))
  (setf temp-val (first val%)
temp-endval (first endval%)))
 (t
  (setf do-continue nil
temp-key nil))))
  ;;
  ;;1  Both of the keys are less thans having no lower bound, use the smallest value as the upper limit*
  ;;
  ((and (rtms-equalp temp-val "T2"*)
(rtms-equalp (first val%) "T2"*))
   (cond ((lep (first endval%) temp-endval)
  (setf temp-endval (first endval%)))))
  ;
  ;;1  Both of the keys are greater thans having no upper bound, use the largest value as the upper limit*
  ;;
  ((and (rtms-equalp temp-endval "T2"*)
(rtms-equalp (first endval%) "T2"*))
   (cond ((gep (first val%) temp-val)
  (setf temp-val (first val%)))))
  ;;
  ;;1  The temp-key is a less than and the key% element is greater than, if they over lap set the value of*
  ;1; the key to that of the lower limit of the key% element and the upper limit to that of the temp-key*
  ;1; element*
  ;;
  ((rtms-equalp (first endval%) "2T"*)
   (cond ((rtms-equalp temp-val "2T"*)
  (cond ((gep temp-endval (first val%))
 (setf temp-val (first val%)))
(t
 (setf temp-key nil
       do-continue nil))))
 ((not (gep (first endval%) temp-val))
  (setf temp-key nil
do-continue nil))))
  ;;
  ;;1  The key% element is less than and the temp-key element is either greater than or a range, in either*
  ;1; case the test for overlap must be made. In the case that the temp-key element is greater than, the*
  ;1; upper limit of the key is set to that of the key% element. If the temp-key element is a range, the*
  ;1; upper limit becomes to smaller of the two upper limits.*
  ;;
  ((rtms-equalp (first val%) "2T"*)
   (cond ((rtms-equalp temp-endval "2T"*)
  (cond ((gep (first endval%) temp-val)
 (setf temp-endval (first endval%)))
(t
 (setf temp-key nil
       do-continue nil))))
 ((gep (first endval%) temp-val)
  (cond ((lep (first endval%) temp-endval)
 (setf temp-endval (first endval%)))))
 (t
  (setf temp-key nil
do-continue nil))))
  (t
   (setf temp-key nil
 do-continue nil)))
    ;;
    ;;1  Remove the element matched from further processing*
    ;;
    (setf element-index (- (length key-list%) (length key%))
  key-list% (append (firstn element-index key-list%) (cdr key%))
  val-list% (append (firstn element-index val-list%) (cdr val%))
  endval-list% (append (firstn element-index endval-list%) (cdr endval%))))))
   (setf resultant-key (append (list temp-key) resultant-key)
 resultant-val (append (list temp-val) resultant-val)
 resultant-endval (append (list temp-endval) resultant-endval))
   (cond ((and (equal (length key-list%) 1)
       (not (and (equal (first key-list%) ref-key)
 (equal (first val-list%) ref-val)
 (equal (first endval-list%) ref-endval))))
  (setf resultant-key (append key-list% resultant-key)
resultant-val (append val-list% resultant-val)
resultant-endval (append endval-list% resultant-endval)))))
 (setf where-key-list resultant-key
       where-val-list resultant-val
       where-endval-list resultant-endval)
 ;1;*
 ;1;  Determine which attributes which contigously form the key are present in the sub clause and accumulate the results.*
 ;;1 It is not required that all of the attributes which make the key are present in the sub clause for a key can be formed*
 ;;1 from the ones that are there as long as they are in continous order starting with the first attribute.*
 ;1;*
 (do ((key-list key-list (cdr key-list)))
     ((or (null key-list) (null do-continue)) do-continue)
   (if (setf do-continue (member (car key-list) where-key-list :test 'string-equal))
       ;;
       ;;1  The next attribute in the key list is contained in the sub clause, locate its associated results and add them to*
       ;;1 the results list. Proceed in the order given in the key-list until find an key attribute which is not present. At this*
       ;;1 point the processing stops.*
       ;;
       (setf result
     (do ((where-key-list where-key-list (cdr where-key-list))
  (where-val-list where-val-list (cdr where-val-list))
  (where-aux-list where-aux-list (cdr where-aux-list))
  (where-endval-list where-endval-list (cdr where-endval-list)))
 ((equal (car where-key-list) (car key-list))
  (if (car key-list)
      (list (append (car result) (list (car where-key-list)))
    (append (cadr result) (list (car where-val-list)))
    (append (caddr result) (list (car where-aux-list)))
    (append (cadddr result) (list (car where-endval-list))))))))))
 ;;
 ;;1  If the first attribute from the key is included in the results, then we have a key.*
 ;;
 (if (equal (caar result) (car key-list))
     (setf result (append (list "k") (list (list (first result))) (list (list (second result)))
  (list (list (third result))) (list (list (fourth result)))))
   (setf result '("n" (nil) (nil) (nil) (nil)))))
;;
;;1  Constant expression - nothing to add*
;;
((and (null where-key-list) (null where-aux-list))
 (setf result '("c" (nil) (nil) (nil) (nil))))
;;
;;1 A key is not possible from this where clause*
;;
(t
 (setf result '("n" (nil) (nil) (nil) (nil)))))
  result)


;1;*;1 This function will process the rest of the where clause and determine if an avl key may be extracted. If so, the AVL key is returned.*
;1;*;1 The results returned from this function, as well as all* 1optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;;* 1list--of-lists-of-key-attributes-used*
;1;;*1 list-of-beginning-values*
;1;;*1 list-of-non-key-attributes-present*
;1;;*1 list-of-termination-predicates)*
;1;;*1  where*
;1;;*1stat-character - is one of the following :*
;1;;*1k - a valid key has been formed*
;1;;*1n - no key can be formed from where*
;1;;*1    clause (ever).*
;1;;*1p - it is still possible to form a*
;1;;*1    but this sub-clause will not*
;1;;*1    contribute to it.*
;1;;*1c - constant sub-clause - nothing to*
;1;;*1    add to the key.*
(defun opt-avl-equal (attribute-list key-list where-clause opt-func-list
       &aux opt-func (result '("p" (nil) (nil) (nil) (nil))) (where-aux-list nil)
            (where-key-list nil) (where-val-list nil))
  ;;
  ;;1  Process for all sub-clauses of the where-clause*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond
      ;;
      ;;1  This clause determines if the current element is an atom constant, if present, it is considered a value*
      ;;
((and (listp (car where-clause))
      (equal 'quote (caar where-clause)))
 (if (null where-val-list)
     (setf where-val-list (cadar where-clause))
   (setf result (append (list "c") (cdr result)))))
;;
;;1  The element is a list, must be a function call. Call the appropriate optimization function if one exists. Add the result from the*
;1; function to the current results. Currently the return value must be a constant and ther are no optimization functions which are*
;1; currently supported which return a constant. This structure is supported on the chance that some function will be supported in*
;1; the future*
;;
((listp (car where-clause))
 (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
(cond ((string-equal opt-func "OPT-AVL-AND")
       (setf result (opt-avl-and attribute-list key-list (car where-clause) opt-func-list)))
      ((string-equal opt-func "OPT-AVL-EQUAL")
       (setf result (opt-avl-equal attribute-list key-list (car where-clause) opt-func-list)))
      ((string-equal opt-func "OPT-AVL-GT")
       (setf result (opt-avl-gt attribute-list key-list (car where-clause) opt-func-list)))
      ((string-equal opt-func "OPT-AVL-LT")
       (setf result (opt-avl-lt attribute-list key-list (car where-clause) opt-func-list)))
      ((string-equal opt-func "OPT-AVL-OR")
       (setf result (opt-avl-or attribute-list key-list (car where-clause) opt-func-list)))
      (t
       (setf result (funcall (find-symbol opt-func *pkg-string*) attribute-list key-list
     (car where-clause) opt-func-list))))
(if (null where-val-list)
    (setf where-val-list (car (third result))))
;;
;;1  No key may be formed if the key list or the aux list is non-nil. Also, all values returned must be single.*
;;
(if (or (car (second result)) (car (fourth result)) (cdr (third result)))
    (setf result '("n" (nil) (nil) (nil) (nil)))))
       (t
(setf result '("n" (nil) (nil) (nil) (nil))))))
;;
;;1 The element is a symbol, add the fact to the proper list*
;;
((symbolp (car where-clause))
 (if (member (car where-clause) attribute-list :test 'string-equal)
     ;;
     ;;1  Symbol is an attribute*
     ;;
     (if (member (car where-clause) key-list :test 'string-equal)
 ;;
 ;;1  Attribute is a key attribute*
 ;;
 (if (null where-key-list)
     (setf where-key-list (car where-clause)))
 ;;
 ;;1  Attribute is not a key attribute*
1  *;;
 (if (null where-aux-list)
     (setf where-aux-list (car where-clause))))
     ;;
     ;;1  The symbol is not an attribute, must return a value, so EVALuate the symbol*
     ;;
     (if (null where-val-list)
 (setf where-val-list (or (car (errset (eval (car where-clause)) nil)) (car where-clause)))
     (setf result (append (list "c") (cdr result))))))
;;
;;1  Not a symbol, must be a value.*
;;
(t
 (if (null where-val-list)
     (setf where-val-list (car where-clause))
   (setf result (append (list "c") (cdr result)))))))
  ;;
  ;;1  The where-clause has been parsed -- let us see what we have*
  ;;
  (cond ((string-equal (car result) "n"))
((string-equal (car result) "c"))
((and where-key-list where-val-list)
 ;;
 ;;1 We have a possible key. The termination condition is the sub-clause evaluated. Since the equal clause allows the inclusion of*
 ;1; only one attribute, it must be the first attribute in the key. Otherwise, it could be used as part of the key later on.*
 ;;
         (if (equal where-key-list (car key-list))
     (setf result (append (list "k") (list (list (list where-key-list)))
  (list (list (list where-val-list))) (list (list (list where-aux-list)))
  (list (list (list where-val-list)))))
   (setf result (append (list "p") (list (list (list where-key-list)))
(list (list (list where-val-list))) (list (list (list where-aux-list)))
(list (list (list where-val-list)))))))
;;
;;1  Determine if the where subclause was a constant*
;;
((and (null where-key-list) (null where-aux-list))
 (setf where-clause (append (list 'equal) where-clause))
 (setf where-val-list (eval where-clause))
 (setf result (append (list "c") (list (list (list where-key-list)))
(list (list (list where-val-list))) (list (list (list where-aux-list)))
(list (list (list where-val-list))))))
;;
;;1  Determine if two attributes were specified, if so this invalidates the possibility of there being a key*
;;
((or (and (null where-aux-list) (null where-val-list))
     (and where-key-list where-aux-list))
 (setf result '("n" (nil) (nil) (nil) (nil))))
(t
 (setf result '("p" (nil) (nil) (nil) (nil)))))
  result)

;1;*;1 This function will process the rest of the where clause and determine if an avl key may be extracted. If so, the AVL key is returned.*
;1;*;1 The results returned from this function, as well as all* 1optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;;* 1list--of-lists-of-key-attributes-used*
;1;;*1 list-of-beginning-values*
;1;;*1 list-of-non-key-attributes-present*
;1;;*1 list-of-termination-predicates)*
;1;;*1  where*
;1;;*1stat-character - is one of the following :*
;1;;*1k - a valid key has been formed*
;1;;*1n - no key can be formed from where*
;1;;*1    clause (ever).*
;1;;*1p - it is still possible to form a*
;1;;*1    but this sub-clause will not*
;1;;*1    contribute to it.*
;1;;*1c - constant sub-clause - nothing to*
;1;;*1    add to the key.*
(defun opt-avl-gt (attribute-list key-list where-clause opt-func-list
   &aux result)
  ;;
  ;;1  The functionality is the same between this routine and the OPT-AVL-EQUAL except for the termination condition. Therefore, call*
  ;1; OPT-AVL-EQUAL and then massage the termination condition.*
  ;;
  (setf result (opt-avl-equal attribute-list key-list where-clause opt-func-list))
  (cond ((and (car (second result))
      (or (equal (car result) "k") (equal (car result) "p")))
 (setf result (append (list (car result)) (list (second result)) (list (third result))
      (list (fourth result)) (list (list (list t)))))))
  result)

;1;*;1 This function will process the rest of the where clause and determine if an avl key may be extracted. If so, the AVL key is returned.*
;1;*;1 The results returned from this function, as well as all* 1optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;;* 1list--of-lists-of-key-attributes-used*
;1;;*1 list-of-beginning-values*
;1;;*1 list-of-non-key-attributes-present*
;1;;*1 list-of-termination-predicates)*
;1;;*1  where*
;1;;*1stat-character - is one of the following :*
;1;;*1k - a valid key has been formed*
;1;;*1n - no key can be formed from where*
;1;;*1    clause (ever).*
;1;;*1p - it is still possible to form a*
;1;;*1    but this sub-clause will not*
;1;;*1    contribute to it.*
;1;;*1c - constant sub-clause - nothing to*
;1;;*1    add to the key.*
(defun opt-avl-lt (attribute-list key-list where-clause opt-func-list
   &aux result)
  ;;
  ;;1  The functionality is the same between this routine and the OPT-AVL-EQUAL except for the beginning condition. Therefore, call*
  ;1; OPT-AVL-EQUAL and then massage the beginning condition.*
  ;;
  (setf result (opt-avl-equal attribute-list key-list where-clause opt-func-list))
  (cond ((or (equal (car result) "k") (equal (car result) "p"))
 (setf result (append (list (car result)) (list (second result)) (list (list (list t)))
      (list (fourth result)) (list (fifth result))))))
  result)

;1;*;1 This function will process the rest of the where clause and determine if an avl key may be extracted. If so, the AVL key is returned.*
;1;*;1 The results returned from this function, as well as all* 1optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;;* 1list--of-lists-of-key-attributes-used*
;1;;*1 list-of-beginning-values*
;1;;*1 list-of-non-key-attributes-present*
;1;;*1 list-of-termination-predicates)*
;1;;*1  where*
;1;;*1stat-character - is one of the following :*
;1;;*1k - a valid key has been formed*
;1;;*1n - no key can be formed from where*
;1;;*1    clause (ever).*
;1;;*1p - it is still possible to form a*
;1;;*1    but this sub-clause will not*
;1;;*1    contribute to it.*
;1;;*1c - constant sub-clause - nothing to*
;1;;*1    add to the key.*
(defun opt-avl-or (attribute-list key-list where-clause opt-func-list
       &aux result opt-func (a-result nil))
  ;;
  ;;1  Process all of the sub-clauses of the where-clause*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) a-result)
    (cond ((listp (car where-clause))
   ;;
   ;;1  The element is a list, must be a function call. Call the appropriate optimization function if one exists.*
   ;;
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-AVL-AND")
 (setf result (opt-avl-and attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-EQUAL")
 (setf result (opt-avl-equal attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-GT")
 (setf result (opt-avl-gt attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-LT")
 (setf result (opt-avl-lt attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-AVL-OR")
 (setf result (opt-avl-or attribute-list key-list (car where-clause) opt-func-list)))
(t
 (setf result (funcall (find-symbol opt-func *pkg-string*) attribute-list key-list
       (car where-clause) opt-func-list))))
  (cond ((string-equal (car result) "k")
 ;;
 ;;1  The sub-clause returned a valid key, add it to the list of keys formed.*
 ;;
 (setf a-result
       (list "k" (append (second result) (second a-result))
     (append (third result) (third a-result))
     (append (fourth result)(fourth a-result))
     (append (fifth result) (fifth a-result)))))
((string-equal (car result) "c"))
;;
;;1  Result returned from the optimization function was not a constant expression or a valid key, therefore no*
;1; key may be formed from this OR sub-clause*
;;
((or (string-equal (car result) "n") (string-equal (car result) "p"))
 (setf a-result '("n" (nil) (nil) (nil) (nil))))))
 (t
  (setf a-result '("n" (nil) (nil) (nil) (nil))))))
  ((symbolp (car where-clause)))))
  a-result)


(defun reduce-avl-key (key-attribute-list key-domains extracted-key-attribute-list beg-val-list end-val-list
       &aux (normalized-key-list nil) (normalized-begval-list nil) (normalized-endval-list nil)
       reduction-key-list reduction-begval-list reduction-endval-list result index
       begval1 begval2 endval1 endval2 reference-reductions)
  key-domains
  (block reduce-avl-key
    ;;
    ;;1   If there is only one element in the key, there is nothing which can be reduced.*
    ;;
    (cond ((<= (length beg-val-list) 1)
   (return-from reduce-avl-key (append (list extracted-key-attribute-list)
       (list beg-val-list)
       (list end-val-list)))))
    ;;
    ;;1  This is a test section of this function, it only looks at the first attribute of the key to determine the range of values which*
    ;1;will be selected.*
    ;;
    (do ((begval% beg-val-list (cdr begval%))
 (endval% end-val-list (cdr endval%)))
((null begval%) t)
      (setf normalized-key-list (append (list (list (car key-attribute-list))) normalized-key-list)
    normalized-begval-list (cons (list (caar begval%)) normalized-begval-list)
    normalized-endval-list (cons (list (caar endval%)) normalized-endval-list)))
    ;;
    ;;1  Begin the reduction process*
    ;;
    (do ((reductions 1 reductions))
((equal reductions 0) result)
      (setf reductions 0)
      ;;
      ;;1  This loop will take each key element and attempt to combine them with ONE other key element. If this can be done, the*
      ;1; new combined element is added to the reduction list and the two combining elements are removed from further consideration*
      ;1; in this pass. If the current element does not combine, it is added to the final results list.*
      ;;
      (setf reduction-key-list nil
    reduction-begval-list nil
    reduction-endval-list nil)
      ;;
      ;;1  The normalized lists are the current working lists*
      ;;
      (do ((key% normalized-key-list (cdr key%))
   (begval% normalized-begval-list (cdr begval%))
   (endval% normalized-endval-list (cdr endval%)))
  ((null begval%) t)
(setf reference-reductions reductions)
;1;*
;1;  See if the next element can be combined with any of the remaining key elements*
;1;*
;1;  1) is the beginning value between the beg and end point of the other or is the ending value between the begin and end*
;1;     point of the other, if so combine. T is less than all other values in the beg clause and greater than all other values in*
;1;     the end clause. Everything to the right of a T is a T.*
;1;  2) Have a domain comparison problem again...for now this will work only for numbers*
;1;  3) Does not handle multiple key attributes. *
;;
(do ((reference-begval% (cdr begval%) (cdr reference-begval%))
     (reference-endval% (cdr endval%) (cdr reference-endval%)))
    ((null reference-begval%) t)
  (setf begval1 (caar begval%)
begval2 (caar reference-begval%)
endval1 (caar endval%)
endval2 (caar reference-endval%))
  (cond ((and (or (equal begval1 't) (equal endval2 't) (lep begval1 endval2))
      (or (equal begval2 't) (equal endval1 't) (lep begval2 endval1)))
 (setf reductions (+ reductions 1))
 (cond ((equal begval1 't)
(setf reduction-begval-list (cons (car begval%) reduction-begval-list)))
       ((equal begval2 't)
(setf reduction-begval-list (cons (car reference-begval%) reduction-begval-list)))
       ((lep begval1 begval2)
(setf reduction-begval-list (cons (car begval%) reduction-begval-list)))
       (t
(setf reduction-begval-list (cons (car reference-begval%) reduction-begval-list))))
 (cond ((equal endval1 't)
(setf reduction-endval-list (cons (car endval%) reduction-endval-list)))
       ((equal endval2 't)
(setf reduction-endval-list (cons (car reference-endval%) reduction-endval-list)))
       ((gep endval2 endval1)
(setf reduction-endval-list (cons (car reference-endval%) reduction-endval-list)))
       (t
(setf reduction-endval-list (cons (car endval%) reduction-endval-list))))
 ;;
 ;;1  Remove the element matched. Can not use Remove to do this because it removes all occurances of the value*
 ;1; not just the first one found*
 ;;
 (cond ((equal (setf index (length reference-begval%)) 1)
(setf begval% (firstn (- (length begval%) 1) begval%)
      endval% (firstn (- (length endval%) 1) endval%)))
       (t
(setf begval% (append (firstn (- (length begval%) index 1) begval%)
      (nleft index begval%))
      endval% (append (firstn (- (length endval%) index 1) endval%)
      (nleft index endval%))))))))
;;
;;1  If the current key element does not match any of the other key element, insert into reduction list*
;;
(cond ((equal reference-reductions reductions)
       (setf reduction-begval-list (cons (car begval%) reduction-begval-list)
     reduction-endval-list (cons (car endval%) reduction-endval-list)))))
      ;;
      ;;1  Initialize for the next pass through the reduction loop, using the results from the last pass through the loop*
      ;;
      (setf normalized-begval-list reduction-begval-list
    normalized-endval-list reduction-endval-list)
      (if (equal (length normalized-begval-list) 1)
  (setf reductions 0)))
    (return-from reduce-avl-key (append (list (firstn (length normalized-begval-list) normalized-key-list))
(list normalized-begval-list) (list normalized-endval-list)))))


܁iiہj܁k܁l܁m܁nہnuہt܁s܁r܁q܁pہqځrځtځtفuفu؁tׁsrׁqׁpx߁xفxׁyׁzw܁z܁ہ܁܁~܁}܁|ہ|ځ|ف|؁}ׁ~ׁׁ߁߁܁ہ܁܁
܁܁ہہ܁܁܁܁ہځځہ܁܁܁܁ہځف؁ׁׁׁׁ܁ہ܁܁܁܁ہ߁فׁ܁SsSlSsYlYsYl^q]q\p\o\n\m]l^l_l`l`manao`p`q_q^qdqdldoeqfqgqhqhohlkskslsktkskqklnqnlnopqpqrqrqsoslzpyqxqwqvqupvowoynynzmzmylxlwlvlLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540642. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359881. :AUTHOR "REL3" :LENGTH-IN-BYTES 9058. :LENGTH-IN-BLOCKS 18. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8AVL\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPPROCESS-SUBTREE-LIST
<A
F#$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\SUB-TREECTERMINATION-CLAUSETEMP-ATTRIBUTE-LISTMODEB:\RESULTSÀTUPLES\)MACROS-EXPANDED\FOURTHTHIRDSETFFIRSTlTERMINATEpB\STRING-EQUAL*ÂSUPER-FAST-EVAL-WHERECPROCESS-SUBTREE-LIST-LEFTpB\,*APPENDFBP,QP(SQQ[@S@Q@QBQQQP	PAA@Q@[QQQP	PAA@P@QQOvBPÂPROCESS-SUBTREE-FLAVORCAF'$B:BV]FB:B:B:BYFB^Bw\B`BaBbBcB:\BeBf\Bh\BjBkBlBmlTERMINATEBpÁPROJECT-FLAVORBq҃PROCESS-SUBTREE-FLAVOR-LEFTBtFBw3QP/SQQQQ[Q@SQQ@Q@QBQQQ	P
PAA@Q@[QQQ	P
PAA@P@QQOBwÂPROCESS-SUBTREE-STRUCTIAHF*$B:BV]FB:B:B:BYFB^B\B`BaBbBcÁRELATION-NAMEB:\BeBf\Bh\BjBkBlBmlTERMINATEBpÁPROJECT-STRUCTBq҃PROCESS-SUBTREE-STRUCT-LEFTBtFB8QP4SQQQQQ[QQ@SQQQ@Q@QBQQQQ	P
PAA@Q@[QQQQ	P
PAA@P@QQOBBr@DF$B:BV]FB:B:B:BYFB^Br\B`B:\Be\Bh\BjBmBlBkBrBtQ[@S@Q@QQB@Q@@ROBrB$@F$B:BV]FB:B:B:BYFB^B\B`ÁATTRIBUTE-LISTB:\Be\Bh\BjBmBlBkBBtBQ[Q@SQQ@Q@QQBQ@Q@@ROBB(@F$B:BV]FB:B:B:BYFB^B\B`BBB:\Be\Bh\BjBmBlBkBBtBQ[QQ@SQQQ@Q@QQBQQ@Q@@ROBRETRIEVE-AVL&KB&4Fq$B:BV]FB:B:B:BYFB^B\BBPROJECT-LISTKEYWHERE-CLAUSECKEY-VALUEIMPCINDEX-NAMEB:\CALL-TUPLESBfDOMAINSBbÂTERMINATION-CONDITIONBcBeB:KEY%BEGINNING-VALUE%TERMINATION-CLAUSE%B:B:\Bh\UNLESSBkSECONDBmPROGpB\lXR-BQ-LISTBlÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*ENTRY-POINTGETPÂAVL-INORDER-TRAVERSALCEVAL-WHERE*NREVERSESTRINGlRETRIEVE-l-CONCATENATEҪFIND-SYMBOLSYSTEM-RELATION\,DOMAINSSTRING-EQUALBSTRING-UPCASEҪLISTpBTFIRSTNBBYLEPFCEVAL-WHERE-PREREQjMAKUNBOUNDl-AVL-KEY-TRAVERSALLOCATEFCCONVERT-ATTRIBUTESҬLISTBt҃UNCONVERT-ATTRIBUTESQP	
QQQQAQC~PPPPPPGPPPPPPQPJGBBQP	@QBCQBQQQBBSW[JIHKJQB&DPHQBJQBDDQQQPPACDCQGKCKKSCGSGKSKGPQPPL@QHSBQISDQ PCQQ!PLQAEFFQCQ"Q#PQAQ$AHIJHAQAAQCQQ%AAOBEXTRACT-KEY-AVL%FA%TFk$B:BV]FB:B:B:BYFB^B\BKEY-LISTBBʪPACKAGE-NAMEB:\KEY-DOMAINSÁOPT-FUNC-LISTÀRESULTOPT-FUNCB:\Bh\BmFIFTHBkBBl*SYSTEM-OPTFUNC-KEY*у*SYSTEM-OPTFUNC-ATTRIBUTES*BBBB\BYBBBlRETRIEVE-l-BBÁSYSTEM-OPTFUNC\SYMBOL-NAMECOPTIMIZE-FUNCTIONBÂSTORAGE-STRUCTURE-TYPEAVLpB\lASSOC-TESTҬOPT-AVL-ANDBp҃OPT-AVL-ANDOPT-AVL-EQUALÁOPT-AVL-EQUALlOPT-AVL-GTCOPT-AVL-GTlOPT-AVL-LTCOPT-AVL-LTlOPT-AVL-ORCOPT-AVL-ORlkAPPENDÁREDUCE-AVL-KEYQQQQQQ5|Q	*yQ
QQB@5PPPPPPDPPPPPPP
PJDAAۃSAQPBCQCQPQQQAQ1CQPQQQAQ'CQPQQQAQCQPQQQAQCQ PQQQAQ!	CQPDQQQAQDBBS"PBW
B[
BUB
#BQ@QBSBWB[$BBBBO+BINSERT-LIST-AVL)pA\FG$B:BV]FB:B:B:BYFB^B,\BBBfBBB:\DOMAIN-KEY-LISTDOMAIN-LISTBɃNEW-ELEMENTTREEÀTUPLE%B\Bh\BBl*EQUAL-INSERTED**NODE-INSERTED*у*BF*BBBC*SYSTEM-RELATIONS*BBpB\MEMBER-TESTBl:*-KEY-DOMAINS*B*READ-FROM-STRINGҪEVALB\BBBQTRIEVEBBBB)INSERT-AVL-LIST҃PUTPQ
	PP
PPPQ
PPPPPPPQ
BAQQB@QQQBQPDQBQFEJESJ
CCDQFSQQ@QۄQJDEFEQDQPOKB,CINSERT-FLAVOR-AVL#?#@Fb$B:BV]FB:B:B:BYFB^BL\BBBfBBB:\B6B7ÁFLAVOR-TUPLESBB8B9STRING-RELATION-NAMEB:B:B:B:ÀTUPLEÀKEYVALÀ%TUPLEBXB\Bh\BpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSBlB=B>B?C*PKG-NAME*BBBB@BBBBBl:*-KEY-DOMAINS*BBEBFB\BBBBHBBBBpBTMAKE-INSTANCEpBT,SET-IN-INSTANCEB)CINSERT-AVL-FLAVORBJQFQPP	P
PPFQPP	PPPPPQBAQQB@QQQCQPEQPPPFQGтQCQJIH5HQISJSLKMۀQMKQNQOMQOSNSNONJMQJ 
CDEQLQQQ@QۄQJ!EMQCHIJIJGQBQEQP"BOlBLCINSERT-STRUCT-AVL%Pņ%@Fu$B:BV]FB:B:B:BYFB^Bm\BBBfBBB:\B6B7BB8ÁRELATION-MACROÁSTRUCT-TUPLESB9BWB:B:B:ATTRB:B:BXBYBZATTRIBUTE-VALUEBXB\Bh\pB\lXR-BQ-CONSB۪PUSHBB_BaBlB=B>B?BcBBBB@BBBBBl:*-KEY-DOMAINS*BBEBFB\BBBBHBBBMAKE-Bl:BB8B)CINSERT-AVL-STRUCTBJQGPP	P
PPGQPP	PPPPPGQBAQQB@QQQBQPFPPPGQDQPPPGQHсQJIIQJSKPPGQKQ CIJJHQJJтQBQHML;LQMSHSONPQNQRQS!PRSQ]QSSQ]QDQQ]PRSRJPQJ"
CCFQOQQQ@QۀQJ#FPQCLMHMHJQEQFQP$EOBmBI(fBF>$B:BV]FB:B:B:BYFB^BI\B8B9BBBB6CREBALANCEPBB:\COMPARISON-OPERATORCURRENT-NODE-KEYMOD-TREE\Bh\BlBB҃NODE-COMPAREFBIFLEFT-BALANCEÁRIGHT-BALANCEFINSERT-AVL-EQUALFCLESS-THANGREATER-THANEQUALFFyF@FZFs݀QGQBQQBAQAQQ@rQ[QQQQQQPPABYBQ'QQP	PAQQBQQQQQQPPABQBBQQQP
PQQQPPQQOBIBk)hBF?$B:BV]FB:B:B:BYFB^Bk\B8B9BBBB6BBB:\BBB\Bh\BlBBBFBkFBBFBFBBBFFzFAF[Ft݀QHQBQQQBAQAQQ@rQ[QQQQQQPPABYBQ'QQP	PAQQBQQQQQQPPABQBBQQQP
PQQQPPQQOBkB)hBF?$B:BV]FB:B:B:BYFB^B\B8B9BBBB6BBB:\BBB\Bh\BlBBBFBFBBFBFBBBFFzFAF[Ft݀QHQBQQQBAQAQQ@rQ[QQQQQQPPABYBQ'QQP	PAQQBQQQQQQPPABQBBQQQP
PQQQPPQQOBBFF	$B:BV]FB:B:B:BYFB^B\B9B8BB:B:\Bh\BlBtQSSۀQQOBB#R@F/$B:BV]FB:B:B:BYFB^B\B9BB:\LEFT-BRANCHRIGHT-BRANCH\Bh\BlFFFFFZFFF#WrUJ;UJ7[@@WY@QB@QBQUJ@Q#@QBA@QBA[AY@QYAQBAQBQUAWLJ@UAWJJAQQQOBB"P@F.$B:BV]FB:B:B:BYFB^B\B9BB:\BB\Bh\BlFFFFFYFFF#WrUJ:UL6QBAAWQBA[AYQUJAQ"A[@AY@QB@QBAQQB@[@YQU@WJJAU@WLJ@QQQOBB@DF$B:BV]FB:B:B:BYFB^B\AVL-TREEB:\CTUPLE-LIST\Bh\BjBmBlBkBBtQ[@S@Q@QQB@Q@@ROBCAVL-NODE-TRAVERSAL@HF$B:BV]FB:B:B:BYFB^B\BB:\BBX\Bh\BjBmBkBlBPRINT[AAQC@S@]@QBAAQ@]@@O$BÂLIST-AVL-KEY-TRAVERSALGBF]$B:BV]FB:B:B:BYFB^B%\BÁKEY-ATTRIBUTESBBEGINNING-VALUEBaBcBbBB:\BÂCURRENT-NODE-KEY-VALUETEMP-RESULTSBfBe\Bh\BjBmBlÀLOCATEBpÁLOCATE-STAGE-2BBBYBBBLOCATE-STAGE-2FB%CTERMINATEBqBtFBPBlTERMINATEQPQPQBQQBAS&	PQAQQ
@P+P[QQQQQQQPPADQPYSQQBOBQDQDQBQQQPPACDQDA@Q	&QP[QQQQQQQPPADQP)SQQB@Q&QPQBQQQQQQQPPADQPSQQPDQQO<B%FLAVOR-AVL-KEY-TRAVERSALNBFd$B:BV]FB:B:B:BYFB^B=\BB.BB/BaBcBbBB:\BB1B2BfBe\Bh\BjBmBlB5BpB6BBBYBBBLOCATE-STAGE-2FB=B9BqBtFBwBlTERMINATEQPQPQBQQQBAS&	PQAQQ
@P/P[QQQQQQQPPADQPeSQQQQQBWBQDQDQBQQQPPACDQDI@Q	& QP[QQQQQQQPPADQP1SQQQQQB#@Q&#QPQBQQQQQQQPPADQP	SQQQQQPDQQOMB=STRUCT-AVL-KEY-TRAVERSAL	5B	F$B:BV]FB:B:B:BYFB^BN\BB.BB/BaBcBbBB:\BeÂSTRING-TEMP-ATTRIBUTESB:B:\Bh\BBlBFBBF	CSTRUCT-AVL-KEY-TRAVERSAL-2QQQPPAQAQBCBBSCCSCBSBCQQQQQQQAQQPPAO^BNPROJECT-STRUCT-FAST#AF$B:BV]FB:B:B:BYFB^B_\BfBBBB:\B:B:B:BXB:B:B:\Bh\BB_Ba@рQBAAQBSCDDтQFEEQCQFSCEFFDQCABB@OkB_B]PBTFf$B:BV]FB:B:B:BYFB^B]\	BB.BB/BaBcBbBXBB:\BB1B2BfBe\Bh\BjBmBlB5BpB6BBBYBBBLOCATE-STAGE-2F	B]B9BqBtFBBlTERMINATEQPQPQBQQQBAS&	PQAQQ
@P1P[QQQQQQQQPPADQPhSQQQQQBZBQDQDQBQQQQPPACDQDK@Q	&!QP[QQQQQQQQPPADQP2SQQQQQB$@Q&$QP QBQQQQQQQQPPADQP	SQQQQQPDQQO{B]BG@F`$B:BV]FB:B:B:BYFB^B\CKEY-LIST-1CKEY-LIST-2KEY-DOMAIN-LISTB:\BVAL1VAL2KEY1KEY2ÀDOMAINB:\Bh\BBlBޑB,NUMBERPBp,STRINGPSTRING-LESSPҬATOMBBLISTPEQUAL-LISTPLT-LISTPҬANYPCEQUAL-ANYPLT-ANYPBEQUAL-BBBҬLT-BP@QQQEDCESPCSDSzsCSDSxjESPCSDSgCSDS^ES	P+CSADSBA1
B1AQA!PQAQB%JA7B7
AQBQPDAQBQ<B1=A1
P:AQABQBESPCSDS,CSDS#ESPCSDS CSDSPPESPFCSDSFPPESPFCSDSF
PP@CDEC@Q&}@OBB"̺"F$B:BV]FB:B:B:BYFB^B\BBBBB:\DO-CONTINUEBBÁWHERE-AUX-LISTÁWHERE-KEY-LISTÁWHERE-VAL-LISTCWHERE-ENDVAL-LISTÁELEMENT-INDEXCREF-ENDVALREF-KEYREF-VALRESULTANT-ENDVALÁRESULTANT-KEYÁRESULTANT-VALTEMP-ENDVALTEMP-KEYTEMP-VALBB:CKEY-LIST%CVAL-LIST%ENDVAL-LIST%B҃VAL%ENDVAL%BBBBB\Bh\BmBBjBkBBlBBޑ\lp\B:\B:\B:\B:BBҬOPT-AVL-ANDBpBOPT-AVL-EQUALB!lOPT-AVL-GTB#lOPT-AVL-LTB%lOPT-AVL-ORB'BBt\ln\B:\B:\B:\B:ln\B:B:B:B:GEPBlTRTMS-EQUALPBBBBlkB)\lc\B:\B:\B:\B:PBUQ`QS5\QQBQPBARAQP	QQQSQ
1AQP	QQQSQ'AQP	QQQSQAQP	QQQSQAQP	QQQSQ	AQPRQQQSQRBDQBQ	BDEQBQBECQBUBCFQBUBBFPBQBSP	DrErPB@@LMKDQEQFQUTSSSOTSPUSNSSITSJUSHSUTUUUXWVOQVS	wPQN+PQWSPQXSU@ORWSXSrWSPQWSNQWSPXSNAPQP	WSPXSNQ5NQPXSPWSPQ(WSP%XSPPQPNQWSXSPQWSPNQPXSPQXSPQO@SQCVQCcGSQVUSGQTQWUTGQUQXUUVWXV@~OQL]LPQM]MNQK]KSQCSSI+TSJ+USH+SQLQLTQMQMUQKQKSTUS@BLQDMQEKQFQY0YSDQP@)DQZEQ[CQ\FQ]Z[\]ZSYSrYBSZSBW[SB[\SBQB]SBBY@BQBSrPBSBWB[BQB DC!PPBBOBB!#tA#$F$B:BV]FB:B:B:BYFB^B!\BBBBB:\	BBBBBBB:B:B:\Bh\
pBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETBjBBkBlBـplEH*CONDITION-HANDLERS*Bޑ\lp\B:\B:\B:\B:B8BBҬOPT-AVL-ANDBpBOPT-AVL-EQUALB!lOPT-AVL-GTB#lOPT-AVL-LTB%lOPT-AVL-ORB'B\ln\B:\B:\B:\B:BBp,G1612FERRORpB\ERRSET-HANDLERBFBlclnlklpB)BPAUEES5
EQB&DEQ
BDES5TEQBQPB@J@Q	P
QQESQ1@QP
QQESQ'@QP
QQESQ@QP
QQESQ@QP
QQESQ	@QPFQQESQFADAQBDAQ	AUAQ=P:E3ESQPESQPC-ESC*B(ESB%DPPTPPPJCGPJCHESJ!BJ!B\BESDDPAU
CAEASP
[ASP
8ASP
4CDSC+P PCQDQBQDQ!C	B"P]DPBDCBPPAAOB!B#&AF$B:BV]FB:B:B:BYFB^B#\BBBBB:\B\Bh\BjBkBBlB!lklpBB)QQQQ@	@S*@S*@S@W@[@QB@@OB#B%&AF$B:BV]FB:B:B:BYFB^B%\BBBBB:\B\Bh\BBjBBlB!lklpBB)QQQQ@@S*@S*@S@W@QB@UB@@O*B%B';AFT$B:BV]FB:B:B:BYFB^B'\BBBBB:\BBA-RESULTBB:\Bh\BBjBkBBlBـBޑBBҬOPT-AVL-ANDBpBOPT-AVL-EQUALB!lOPT-AVL-GTB#lOPT-AVL-LTB%lOPT-AVL-ORB'BlkBtBlclnlp\ln\B:\B:\B:\B:UCmCS5iCQBQPBA_AQPQQCSQ1AQ	PQQCSQ
'AQPQQCSQAQPQQCSQAQPQQCSQ	AQPDQQCSQD@@SPP@WBW@[B[@QBBQB@UBBUB@SP
@SP@SPPBC@SPBOFB'B*eՆ@Fp$B:BV]FB:B:B:BYFB^B*\CKEY-ATTRIBUTE-LISTB
EXTRACTED-KEY-ATTRIBUTE-LISTBEG-VAL-LISTEND-VAL-LISTB:\NORMALIZED-KEY-LISTÂNORMALIZED-BEGVAL-LISTÂNORMALIZED-ENDVAL-LISTCREDUCTION-KEY-LISTÂREDUCTION-BEGVAL-LISTÂREDUCTION-ENDVAL-LISTÀINDEXBEGVAL1BEGVAL2ENDVAL1ENDVAL2REFERENCE-REDUCTIONSBEGVAL%BCREDUCTIONSBCREFERENCE-BEGVAL%CREFERENCE-ENDVAL%\Bh\BBlBB)BBBpBTNLEFTBtQJQQQQQMLS@]@LQBA]AMQBB]BLMLJNNCDE@QAQBQMLONQKLUMUQPnLQBGPQBHMQBIQQBJGQJQGQJQTHQIQHQIQJNGQLS
HQGQHQLSPSD]DIQJQQSJQIQQSMSE]EPQCFLQCmLQLMQCmMQLQCFcmLQFQLQ	
LMQCFcmMQFQMQ	
MPQPKQN+LSD]DMSE]EOLML}DQAEQBAQCNJN'fAQC@QAQBQOiB*1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B-i\B솀~z\Bꆀ<p\B膀`sN\B憀|\B\B~\Ba(̢\B_*j\BZi\Bۆ.ً\Bن=#\B؆{\B׆6\Bmz(\Bl[\Bk:}n\Bjxement tree key key-list attribute-list domain-key-list rebalancep relation-name
&aux comparison-operator current-node-key mod-tree)
  (cond ((equal tree nil)
  (setf rebalancep t
tree new-element))
 (t
  ;;
  ;;1  This next line is the only accessor dependant part of the entire function. This call needs tLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540645. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DEFINE-ATT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749845955. :AUTHOR "REL3" :LENGTH-IN-BYTES 20269. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
1;;; DEFINE-ATT
;;;
;;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp
;;; Reference
;;;    deff
;;;
;;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not
;;; effect the functionality of RTMS.
;;;     destroy-att-flavor-hash
;;;     destroy-att-flavor-heap
;;;     destroy-att-flavor-avl
;;;     destroy-att-utility-redef-rel-flavor-heap
;;;     destroy-att-utility-redef-rel-flavor-hash
;;;     destroy-att-utility-redef-rel-flavor-avl
;;;*
(deff defattr 'define-attribute)

(defun define-attribute (relation-name attribute-descriptor &rest keyword-list
 &key &optional key &allow-other-keys
 &aux (relation-tuple nil) (result nil) attr? attribute-list key-value rel-owner-id
 save-dir rel-implementation-type status rel-storage-structure (new-attrs nil))
  "Add a new attribute to a relation.
2    *All its tuples will get the default value of the attribute for the attribute value.

   RELATION-NAME - Name of the relation.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   KEY           - If the key for this relation is to be changed, specify it."
  key
 (block define-attribute
       ;;
       ;;1 Verify that the user is logged into a database before proceeding *
       (if (not (active-database))
   (return-from define-attribute nil))
       ;;
       ;;1 Check the parameters for validity*
       ;;
       (cond ((null (setf relation-name (validate-sym relation-name t)))
      (return-from define-attribute nil)))
       (cond ((not (listp attribute-descriptor))
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - Illegally specified attribute descriptor list, expected a list --> ~s"
  attribute-descriptor))
      (return-from define-attribute nil)))1      *
       (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
      ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
       ;;
       ;;1 Get the system-relation tuple which defines the relation*
       (setf relation-tuple (cadr (get-relation relation-name '("OWNER-ID" "TUPLE-FORMAT" "ATTRIBUTES"
"DOMAINS" "KEY" "SAVE-DIRECTORY" "DOC"
"IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE")
t)))
       (cond ((not relation-tuple)
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
  relation-name *active-db*))
      (return-from define-attribute nil)))
       ;;1 later, verify here that the user owns this relation*
       (setf rel-owner-id (first relation-tuple)
     save-dir (sixth relation-tuple)
     ;;
     ;; 1Ignore attribute definition which attribute name already exists in the relation*
     attribute-list (third relation-tuple))
       (setf attribute-descriptor
     (do ((attr-des attribute-descriptor (cdr attr-des)))
 ((null attr-des)  result)
       (setf attr? (car attr-des))
       (if (and (listp attr?) (string-equal "QUOTE" (first attr?)))
   (setf attr? (validate-sym attr? t)))
       (cond ((or (stringp attr?)(atom attr?))
      (setf attr? (string-upcase attr?))
      (cond ((member attr? attribute-list :test 'string-equal) ;1e.g. attribute already defined*
     (if *provide-error-messages*
 (format *standard-output*
 "~%WARNING - The attribute ~S already exists. It will not be added."
 attr?)))
    (t
     (setf new-attrs (cons attr? new-attrs))
     (setf result (append result
  (cons attr?
(if (or (atom (cadr attr-des))
(string-equal "QUOTE" (first (cadr attr-des))))
    nil
    (list (cadr attr-des))))))))))))
       (cond ((null attribute-descriptor)
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - Legal attribute descriptor not provided"))
      (return-from define-attribute nil)))
       (cond ((car keyword-list)
      (setf keyword-list (get-keyword-value-prereq '(key) keyword-list))
      (setf key-value (convert-attributes (car (get-keyword-value '(key) keyword-list))))
      (cond ((or (not key-value) (not (car key-value))
 (and (stringp key-value)(string-equal key-value "NIL"))
 (string-equal (car key-value) "NIL"))
     (setf key-value (fifth relation-tuple)))
    ((not (listp key-value))
     (setf key-value (list key-value))))
      (if (null
    (do ((key% key-value (cdr key%)))
((null key%) t)
      (cond ((and (not (member (car key%) attribute-list :test 'string-equal))
  (not (member (car key%) new-attrs :test 'string-equal)))
     (cond (*provide-error-messages*
    (format *standard-output*
    "~%ERROR - ~s is not an attribute of the ~s relation"
    (car key%) relation-name)
    (format *standard-output*
    "~%         and it is included illegally in the key list")))
     (return-from define-attribute nil)))))
  (return-from define-attribute nil))
      (setf rel-implementation-type (nth 7 relation-tuple)
    rel-storage-structure (nth 8 relation-tuple))
      (setf status (not (funcall (find-symbol (concatenate 'string "DEFATT-UTILITY-REDEF-REL-"
   rel-implementation-type "-"
   rel-storage-structure) *pkg-string*)
 relation-name attribute-descriptor relation-tuple key-value)))
      (if status
  (return-from define-attribute nil)))
     (t
      (setf rel-implementation-type (nth 7 relation-tuple)
    rel-storage-structure (nth 8 relation-tuple))
      (setf status (not (funcall (find-symbol (concatenate 'string "DEFATT-" rel-implementation-type "-"
   rel-storage-structure) *pkg-string*)
 relation-name attribute-descriptor relation-tuple nil)))

      (if status
  (return-from define-attribute nil))))
       (cond (*auto-save*
      (save-system-relations)
      (save-relation relation-name (list 'dir save-dir))))
       (if *provide-status-messages*
   (format *standard-output* "~%Attribute definition complete"))
       (return-from define-attribute relation-name)))

(defun delete-index-tuples (relation-name relation-implementation
    &aux attributes domains indices)
  ;;
  ;;1  Must determine if there are any indices defined on this relation. If there are, the tuples must be deleted from the indices vefore they*
  ;1; are modified. After the modification is complete, the tuples modified are sent back. These must then be inserted.*
  ;;
  (cond ((setf indices (retrieve 'system-index 'tuples t 'project '("2INDEX-NAME" *"2KEY" *"2INDEX-TYPE"*)
 'where `(string-equal relation-name ,(string-upcase relation-name))))
 (setf attributes (car (funcall (find-symbol (concatenate 'string "2RETRIEVE-"*
  *system-relation-base-implementation*
  "2-"*
  *system-relation-storage-structure*)
     *pkg-string*)
'system-relation *system-relation-attributes* '("2ATTRIBUTES"* "2DOMAINS"*)
*system-relation-key*
`(string-equal relation-name ,(string-upcase relation-name))
nil 'system-relation)))
 (setf domains (second attributes)
       attributes (first attributes))
 (mapc (function (lambda (index-element)
   (funcall (find-symbol (concatenate 'string2 *"2DELETE-"* relation-implementation "2-"*
      (third index-element)) *pkg-string*)
    relation-name attributes (second index-element) domains t
    (first index-element))))
       indices)))
  indices)

(defun insert-index-tuples (relation-name relation-implementation relation-storage-structure indices
    &aux attributes tuples)
  (setf tuples (funcall (find-symbol (concatenate 'string "OBTAIN-TUPLES-2"* relation-storage-structure)
     *pkg-string*)
relation-name))
  (setf attributes (caar (funcall (find-symbol (concatenate 'string "2RETRIEVE-"*
    *system-relation-base-implementation*
    "2-"* *system-relation-storage-structure*)
       *pkg-string*)
 'system-relation *system-relation-attributes* '("2ATTRIBUTES"*)
 *system-relation-key*
 `(string-equal relation-name ,(string-upcase relation-name))
 nil 'system-relation)))
  (mapc (function (lambda (index-element)
    (funcall (find-symbol (concatenate 'string2 *"2INDEX-INSERT-"* relation-implementation "2-"*
       (third index-element)) *pkg-string*)
     (first index-element) tuples attributes (second index-element) relation-name)))
indices))


(defun defatt-array-hash (relation-name attribute-descriptor relation-tuple
  &aux array-name att-default-list)
  (block defatt-array-hash
;;
;;1  (i)   insert system-attribute tuples*
;;1  (ii)  modify system-relation tuple*
;;
  (setf att-default-list (defatt-utility-array-list relation-name attribute-descriptor relation-tuple))
  (if (not att-default-list)
      (return-from defatt-array-hash nil))
  ;;
  ;;1  (iii) modify relation-name tuples*
  ;;
  (multiple-value-setq (array-name)
     (intern (read-from-string (concatenate 'string relation-name "ARRAY"))))
  (maphash (function (lambda (key bucket)
       key
       (mapcar (function (lambda (row)
 (setf (aref (symbol-value array-name) row)
       (append (aref (symbol-value array-name) row) att-default-list))))
       bucket)))
   (getp relation-name 'entry-point))
  (return-from defatt-array-hash relation-name)))

(defun defatt-array-heap (relation-name attribute-descriptor relation-tuple
  &aux array-name att-default-list)
  (block defatt-array-heap
;;
;;1  (i)   insert system-attribute tuples*
;;1  (ii)  modify system-relation tuple*
  (setf att-default-list (defatt-utility-array-list relation-name attribute-descriptor relation-tuple))
  (if (not att-default-list)
      (return-from defatt-array-heap nil))
  ;;
  ;;1  (iii) modify relation-name tuples*
  (multiple-value-setq (array-name)
     (intern (read-from-string (concatenate 'string relation-name "ARRAY"))))
   (mapcar (function (lambda (row)
      (setf (aref (symbol-value array-name) row)
       (append (aref (symbol-value array-name) row) att-default-list))))
   (getp relation-name 'entry-point))

   (return-from defatt-array-heap relation-name)))

(defun defatt-flavor-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-flavor-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-flavor-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-list-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-list-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-list-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-struct-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-struct-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-struct-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))


(defun defatt-utility (relation-name attribute-descriptor relation-tuple system-attribute-list
       &aux default doc domain attribute global-attr att-default-list new-att-list
       attribute-list domain-list tuple-format-list temp-format)
  (setf new-att-list nil
att-default-list nil)
  (setf attribute-list (third relation-tuple)
domain-list (fourth relation-tuple)
tuple-format-list (second relation-tuple))
  (do ((att-des attribute-descriptor (if (listp (cadr att-des))
 (cddr att-des)
 (cdr att-des))))
      ((null att-des) (values t))
    (setf attribute (string-upcase (car att-des)))
    (cond ((member attribute new-att-list :test 'string-equal)
   (if *provide-warning-messages*
       (format *standard-output* "~%WARNING - The attribute ~S is defined more than once" attribute))
   (setf attribute nil)))
    (if attribute
(block defatt-utility
      (setf *domain-list*
    (mapcar (function (lambda (dom)
(car dom)))
    (qtrieve 'system-domain *system-domain-attributes* '("DOMAIN-NAME")
     *system-domain-key* t)))
      (cond ((listp (cadr att-des))
     ;;
     ;;1  Determine the domain of the attribute*
     ;;
     (setf domain (string-upcase (or (car (get-keyword-value '(dom) (cadr att-des))) "ANYP")))
     (cond ((not (member domain *domain-list* :test 'string-equal))
    (if *provide-error-messages*
(format *standard-output* "~%ERROR - ~s is an unrecognized domain" domain))
    (return-from defatt-utility nil)))
     (setf domain-list (append domain-list (list domain)))
     ;;
     ;;1  Add the print width of this attribute into the tuple format list*
     ;;
     (if (not (listp (setf temp-format (or (car (get-keyword-value '(format) (cadr att-des)))
   (default-tuple-format (list domain))))))
 (setf temp-format (list temp-format)))
     (cond ((<= (car temp-format) 0)
    (cond (*provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is not a legal format specification"
   (car temp-format))
   (format *standard-output* "~%         It must be a positive numeric value")))
    (return-from defatt-utility nil)))
     (setf tuple-format-list (append tuple-format-list temp-format))
     ;;
     ;;1  Determine the default value of the domain*
     ;;
     (setf default
   (cond ((setf default (car (get-keyword-value '(def) (cadr att-des))))
  (if *validity-checking*
      (cond ((funcall
       (if (setf global-attr (find-symbol (string-upcase domain)
  "GLOBAL"))
   global-attr
   (find-symbol (string-upcase domain) *pkg-string*))
       default)
     default)
    (t
     (if *provide-error-messages*
 (format *standard-output* "~%ERROR - The default value specified ~S is not in the domain ~S"
 default domain))
     (return-from defatt-utility nil)))
      default))
 (t
  (get-default-value domain))))
     ;;
     ;;1  Determine the documentation for the attribute*
     ;;
     (setf doc (car (get-keyword-value '(doc) (cadr att-des)))))
    (t
     (setf domain-list (append domain-list  (list "ANYP"))
   domain "ANYP"
   default "?"
   tuple-format-list (append tuple-format-list (default-tuple-format '("ANYP")))
   doc nil)))
      (setf new-att-list (append new-att-list (list attribute))
    attribute-list (append attribute-list (list attribute))
    att-default-list (append att-default-list (list default))
    system-attribute-list
      (append system-attribute-list (list (list (concatenate 'string relation-name)
(string (car att-des)) domain default doc
user-id)))))))
  (values att-default-list system-attribute-list tuple-format-list attribute-list domain-list))

(defun defatt-utility-array-list (relation-name attribute-descriptor relation-tuple
  &aux att-default-list attribute-list domain-list tuple-format-list
  sys-att-list system-attribute-list where-c
  (status? *provide-status-messages*))
  (block defatt-utility-array-list
;;
;;1 (i) system-attribute relation*
;;
;;1     -- Define the tuples for the system-attribute relation*
;;
(setf system-attribute-list nil)
(multiple-value-setq (att-default-list sys-att-list tuple-format-list attribute-list domain-list)
  (defatt-utility relation-name attribute-descriptor relation-tuple system-attribute-list))
(if (not att-default-list)(return-from defatt-utility-array-list nil))
;;
;;1     -- Insert the tuples in the system-attribute relation  *
;;
(setf *provide-status-messages* nil)
(insert  'system-attribute (list 'tuples sys-att-list))
(setf *provide-status-messages* status?)
;;
;;1  (ii) modify the system-relation tuple which defines this relation *
;;
(setf where-c (list 'string-equal 'relation-name `(quote ,relation-name)))
(delete-or-modify 'system-relation t where-c '("MODIFIEDP" "TUPLE-FORMAT" "ATTRIBUTES" "DOMAINS")
  (list 't `(quote ,tuple-format-list) `(quote ,attribute-list) `(quote ,domain-list)))
(return-from defatt-utility-array-list att-default-list)))

(defun defatt-utility-redef-rel (relation-name attribute-descriptor relation-tuple new-key
 &aux att-default-list system-attribute-list attribute-list tuple-format-list
 tuple-list dir imp ss key doc attr-des-pair)
  (block defatt-utility-redef-rel
(setf system-attribute-list
      (get-system-attribute-list relation-name))
(multiple-value-setq (att-default-list system-attribute-list tuple-format-list attribute-list)
  (defatt-utility relation-name attribute-descriptor relation-tuple system-attribute-list))
(if (not att-default-list)
    (return-from defatt-utility-redef-rel nil))
(setf dir (nth 5 relation-tuple)
      imp (nth 7 relation-tuple)
      ss (nth 8 relation-tuple)
      key (if new-key
      new-key
      (nth 4 relation-tuple))
      doc (nth 6 relation-tuple))
;;
;;1 Create the attribute-descriptor list to redefine the relation*
(setf attr-des-pair  (create-attr-descriptor attribute-list system-attribute-list)
      tuple-list nil)
(maptuple (function (lambda (tuple)
      (setf tuple-list (append (list (append tuple att-default-list)) tuple-list))))
  (read-from-string relation-name))
(redefine-rel relation-name attr-des-pair imp ss key tuple-format-list doc dir (nreverse tuple-list))
(return-from defatt-utility-redef-rel relation-name)))

(defun defatt-utility-redef-rel-list-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-list-heap relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-list-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-list-avl relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-list-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-flavor-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-flavor-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-flavor-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-struct-heap (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-struct-hash (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun defatt-utility-redef-rel-struct-avl (relation-name attribute-descriptor relation-tuple key-value)
  (defatt-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))
(node-compare key current-node-key domain-key-list))
  (cond ((equal comparison-operator 'less-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-struct new-element (caddr tree) key key-list aLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540648. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DEFINE-ATT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360677. :AUTHOR "REL3" :LENGTH-IN-BYTES 5616. :LENGTH-IN-BLOCKS 11. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lDEFINE-ATT\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPDEFINE-ATTRIBUTEOPDEFATTRBP222F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEATTRIBUTE-DESCRIPTOR&RESTKEYWORD-LIST&KEYj&OPTIONALKEYj&ALLOW-OTHER-KEYSB:\BdBgÁRELATION-TUPLEÀRESULTÀATTR?ÁATTRIBUTE-LISTCKEY-VALUEREL-OWNER-IDSAVE-DIRREL-IMPLEMENTATION-TYPEÀSTATUSÂREL-STORAGE-STRUCTURECNEW-ATTRSBdATTR-DESKEY%B:\)MACROS-EXPANDED\FIFTHTHIRDSIXTHFIRSTPROGSETFDOCUMENTATION,Add a new attribute to a relation.
    All its tuples will get the default value of the attribute for the attribute value.

   RELATION-NAME - Name of the relation.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   KEY           - If the key for this relation is to be changed, specify it.AC*PROVIDE-STATUS-MESSAGES*у*AUTO-SAVE*у*PKG-STRING*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*\KEYpB]STORE-KEYARGSACTIVE-DATABASE҃VALIDATE-SYMTERPRIҬERROR - Illegally specified attribute descriptor list, expected a list --> WRITE-STRINGPRIN1\	,OWNER-IDTUPLE-FORMATlATTRIBUTES,DOMAINSKEYSAVE-DIRECTORYDOCIMPLEMENTATION-TYPElSTORAGE-STRUCTUREGET-RELATIONERROR - The relation , is not defined in the database QUOTEpB]STRING-EQUAL*STRING-UPCASEҪSTRING-EQUALpB]MEMBER-TEST,WARNING - The attribute  already exists. It will not be added.LISTpB],*APPEND,ERROR - Legal attribute descriptor not provided\BgGET-KEYWORD-VALUE-PREREQCGET-KEYWORD-VALUECCONVERT-ATTRIBUTESҬNIL,ERROR -  is not an attribute of the l relation         and it is included illegally in the key listSTRINGlDEFATT-UTILITY-REDEF-REL-l-CONCATENATEҪFIND-SYMBOL,DEFATT-ÂSAVE-SYSTEM-RELATIONS҃DIRÁSAVE-RELATIONAttribute definition complete@@Q	PA
RQR5PQR@QMSMMS5MQ@QPBB	PQPPRBSGBYBHB[EQN6NSDD5PDSDQDD7D$DQDEQP
PDQPDQL]LCQDQNPNQ	BNW
CCNCQPR@YP@Q @P@Q!B"FF
F7FQ#PFS#PBUBF5FQFFQOOSEQPOSLQP$POS%PQ&P'PROJBQCIJBQCK(P)PIQ*PKQ+P,PQQBQFQP?BJRJBQCIJBQCK(P-PIQ*PKQ+P,PQQBQ.Q/PHQ01POBPDELETE-INDEX-TUPLES"^@F<$B:BW]FB:B:B:BZFB_B\BaRELATION-IMPLEMENTATIONB:\CATTRIBUTESDOMAINSINDICESB:B:ÁINDEX-ELEMENTB:\Bx\B{B~pZLC,DO-NAMEDB}SECONDpB]lXR-BQ-LISTBÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*Bу*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*SYSTEM-INDEXÀTUPLESPROJECT\lINDEX-NAMEKEYlINDEX-TYPEÀWHEREBBaBBRETRIEVEBlRETRIEVE-l-BBSYSTEM-RELATION\lATTRIBUTES,DOMAINS,DELETE-P	P
PPPPPQJB3PPPPPPCPPPPPPQPJCB@@WA@S@BQDDSEPPQPE[PFQ@QEWAQESFDBOBINSERT-INDEX-TUPLESOAF2$B:BW]FB:B:B:BZFB_B\BaBCRELATION-STORAGE-STRUCTUREBB:\BBB:B:BB:\Bx\BB}B{B~BpBUINHIBIT-STYLE-WARNINGSBBBBBBBBOBTAIN-TUPLES-BBlRETRIEVE-l-B\lATTRIBUTESBBaBBINDEX-INSERT-P	PQ
PBQBAPPPPP
PBPPPPPPQPJBB@QCCSDPPQPD[
PEDSAQ@QDWQECOBCDEFATT-ARRAY-HASH$@F$B:BW]FB:B:B:BZFB_B\BaBbBjB:\B:B:pB]lLEX-PARENT-ENV-REGpB]LEX-ENV-B-REGpB]LEX-CURRENT-VECTOR-REGpB]LEX-ALL-VECTORS-REGCARRAY-NAMEATT-DEFAULT-LIST\Bx\BINTERNAL-FEF-OFFSETS\F
iVARIABLES-USED-IN-LEXICAL-CLOSURES\BBCDEFATT-UTILITY-ARRAY-LISTBARRAYB*READ-FROM-STRINGINTERN\FFF\)INTERNALBENTRY-POINTGETP*MAPHASHQQQGRPQPF	P
PCQPO+BB%@F$B:BW]FB:B:B:BZFB_B%\BgÀBUCKETB:\B:B:BB:B:B:ROW\Bx\BB~BBiLEXICAL-PARENT-DEBUG-INFOBBCсQEDDQESFPCFQPCFQCPBCDEECO:B%CDEFATT-ARRAY-HEAP6@F!$B:BW]FB:B:B:BZFB_B;\BaBbBjB:\BBB:B:B:B6\Bx\B~BBBBBARRAYBBB B(B)BQQQARPQP@BрQ	P
DCCQDSE@QCEQ@QCEQCAQBCCDDOHB;CDEFATT-FLAVOR-AVL
F$B:BW]FB:B:B:BZFB_BI\BaBbBjBnB:B:B:DEFATT-UTILITY-REDEF-RELQQQQOSBICDEFATT-FLAVOR-HASH
F$B:BW]FB:B:B:BZFB_BT\BaBbBjBnB:B:B:BRQQQQO]BTCDEFATT-FLAVOR-HEAP
F$B:BW]FB:B:B:BZFB_B^\BaBbBjBnB:B:B:BRQQQQOgB^DEFATT-LIST-HASH
F$B:BW]FB:B:B:BZFB_Bh\BaBbBjBnB:B:B:BRQQQQOqBhDEFATT-LIST-HEAP
F$B:BW]FB:B:B:BZFB_Br\BaBbBjBnB:B:B:BRQQQQO{BrDEFATT-LIST-AVL
F$B:BW]FB:B:B:BZFB_B|\BaBbBjBnB:B:B:BRQQQQOB|CDEFATT-STRUCT-HASH
F$B:BW]FB:B:B:BZFB_B\BaBbBjBnB:B:B:BRQQQQOBCDEFATT-STRUCT-AVL
F$B:BW]FB:B:B:BZFB_B\BaBbBjBnB:B:B:BRQQQQOBCDEFATT-STRUCT-HEAP
F$B:BW]FB:B:B:BZFB_B\BaBbBjBnB:B:B:BRQQQQOBÁDEFATT-UTILITY-oA-<F$B:BW]FB:B:B:BZFB_B\BaBbBjÂSYSTEM-ATTRIBUTE-LISTB:\DEFAULTDOCÀDOMAINCATTRIBUTEGLOBAL-ATTRBNEW-ATT-LISTBmDOMAIN-LISTCTUPLE-FORMAT-LISTTEMP-FORMATATT-DESB:B:B:\Bx\BBB~BFOURTHB{BpBU,USER-IDBу*VALIDITY-CHECKING*BÁ*DOMAIN-LIST*у*SYSTEM-DOMAIN-KEY*C*SYSTEM-DOMAIN-ATTRIBUTES*C*PROVIDE-WARNING-MESSAGES*BBBB,WARNING - The attribute BBl is defined more than onceÁSYSTEM-DOMAIN\DOMAIN-NAMEQTRIEVE\DOMBҬANYP,ERROR - l is an unrecognized domainBB\FORMATDEFAULT-TUPLE-FORMATҬ is not a legal format specification         It must be a positive numeric value\pBUDEFGLOBALBҬERROR - The default value specified  is not in the domain CGET-DEFAULT-VALUE\Bl?\ANYPBBBFEۂ[GQBHWIQKSCFQP

PCQPCCLLP	PPPNMMQNSBCMNNLQKW5lPKWBPBPP
PBQPHQBQHPKWBBQJ5JQJJSvjPJSP P_IQJQI!PKWB@ BQ"P#DDQBQP#N@QNA$P@Q%PBQ7@QBQ&@'PKWBAHQPHPB(P@IQ)PIAFQCQFGQCQGEQ@QEQ*PQ+KS,BQ@QAQPKW5KYKUK4EQQIQGQHQOBBB@F)$B:BW]FB:B:B:BZFB_B\BaBbBjB:\BBmBBSYS-ATT-LISTBWHERE-CSTATUS?\Bx\BBBPBSYSTEM-ATTRIBUTEBBÀINSERTBBaB8B\lMODIFIEDPTUPLE-FORMATlATTRIBUTES,DOMAINSDELETE-OR-MODIFYPGEۀQQQEQPPABACD@RPPDQ	GQ
PPPQFPFQPPCQPAQPBQ@OBBR NF.$B:BW]FB:B:B:BZFB_BR\BaBbBjNEW-KEYB:\B:B:BBBBBBBmBCTUPLE-LISTBIMPCSSBgBÁATTR-DES-PAIR\Bx\BB\F	B\BBCGET-SYSTEM-ATTRIBUTE-LIST҆BÂCREATE-ATTR-DESCRIPTOR\FF
F\B&BRBMAPTUPLE*NREVERSE҃REDEFINE-RELQGQQQGQPPAHIGFRJQCKJQCLJQCMQJQCNJQCOHQGQPJP	PCQ
QPQLQMQNQIQOQKQJQ	JOBRB
@LF$B:BW]FB:B:B:BZFB_B\ÀTUPLEB:\B:B:B\Bx\BB9BBQP\O$BCDEFATT-UTILITY-REDEF-REL-LIST-HEAP
F$B:BW]FB:B:B:BZFB_B%\BaBbBjBnB:B:B:BrQQQQO.B%CDEFATT-UTILITY-REDEF-REL-LIST-AVL
F$B:BW]FB:B:B:BZFB_B/\BaBbBjBnB:B:B:B|QQQQO8B/CDEFATT-UTILITY-REDEF-REL-LIST-HASH
F$B:BW]FB:B:B:BZFB_B9\BaBbBjBnB:B:B:BRQQQQOBB9DEFATT-UTILITY-REDEF-REL-FLAVOR-HEAP
F$B:BW]FB:B:B:BZFB_BC\BaBbBjBnB:B:B:BRQQQQOLBCDEFATT-UTILITY-REDEF-REL-FLAVOR-HASH
F$B:BW]FB:B:B:BZFB_BM\BaBbBjBnB:B:B:BRQQQQOVBMDEFATT-UTILITY-REDEF-REL-FLAVOR-AVL
F$B:BW]FB:B:B:BZFB_BW\BaBbBjBnB:B:B:BRQQQQO`BWDEFATT-UTILITY-REDEF-REL-STRUCT-HEAP
F$B:BW]FB:B:B:BZFB_Ba\BaBbBjBnB:B:B:BRQQQQOjBaDEFATT-UTILITY-REDEF-REL-STRUCT-HASH
F$B:BW]FB:B:B:BZFB_Bk\BaBbBjBnB:B:B:BRQQQQOtBkDEFATT-UTILITY-REDEF-REL-STRUCT-AVL
F$B:BW]FB:B:B:BZFB_Bu\BaBbBjBnB:B:B:BRQQQQO~Bu1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\Bx\B(̢\Bֆ.ً\BԆ{\Bӆ*j\B[\B~=#\B}z(\B|{Ĳ\B{:}n\BzZiscriptor relation-tuple key-valuLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540651. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "DEFINE-DB" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2758811060. :AUTHOR "REL3" :LENGTH-IN-BYTES 20492. :LENGTH-IN-BLOCKS 21. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;1;; Copyright (c) by Texas Instruments, Incorporated*
;1;; All rights reserved.*
;1;; DEFINE-DB*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     deff*

(deff defdb 'define-database)

(defun define-database (db-name &rest keyword-list
&key &optional directory environment documentation
&allow-other-keys
&aux dir-keyword-list keyword-values temp-validity-checking)
  "2Define a new database.

   DB-NAME     - Name of the database.
   DIRECTORY   - Name of the directory in which this database is to be saved.
   ENVIRONMENT - Name of the environment to be associated with this database.
   DOCUMENTATION - A string describing this database.*"

  directory environment documentation
  (block define-database
;1;*
;1;  If there is an activedb, determine if any relation has been modified, if so do not do anything which would provoke those *
;1; relations, i.e. terminate the function.*
;1;*
  (cond ((and *parameter-checking* (active-database "defdb"))
 (cond ((car (funcall
       (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation*
 "-" *system-relation-storage-structure*) *pkg-string*)
       'system-relation *system-relation-attributes* '("RELATION-NAME") *system-relation-key*
       `(string-equal modifiedp "T") nil 'system-relation))
(cond (*provide-error-messages*
       (format *standard-output*
       "~%ERROR - ~s is the current database and it has modified relations" *active-db*)
       (format *standard-output*
       "~%        Please resolve this conflict by either saving or destroying this database")
       (format *standard-output* "~%        before defining a new one")))
(return-from define-database nil)))))
  (cond ((not *parameter-checking*)
 (setf db-name (string-upcase db-name)
       keyword-list (get-keyword-value-prereq '(dir doc env) (de-nest-keyword-list keyword-list))))
((null (setf db-name (validate-sym db-name t)))
 (return-from define-database nil)))
  ;1;*
  ;1;  Get the keyword values. NOTE : Do not change the order of the GET-KEYWORD-VALUE keyword*
  ;1; list. The code in this function depend on this positional relationship !!!*
  ;1;*
  (setf     ;1 *save-directory* nil  -- don't do this -- MRR 5.27.87*
*save-user-id* nil
keyword-values (get-keyword-value '(dir doc env) keyword-list)
*save-directory* (get-directory keyword-list))
  ;1;*
  ;1;  If an environment was specified, activate it. Otherwise set the value of all variables to the system default values.*
  ;1;*
  (cond ((equal *environment-name* (car (get-keyword-value '(env) keyword-list)))
 t)
((third keyword-values)
 (setf *environment-name* (third keyword-values))
 (cond ((listp *environment-name*)
(setf dir-keyword-list (append '(dir) (cdr *environment-name*)))
(setf *environment-name* (car *environment-name*))
(load-environment *environment-name* dir-keyword-list))
       (t
(load-environment *environment-name*))))
(t
 ;1;*
 ;1;  This part of the code needs to be redone as the following variables are no longer*
 ;1; part of the environment*
 ;1;*
 (setf *default-anyp-width* 20
       *default-atom-width* 10
       *default-listp-width* 20
       *default-numberp-width* 8
       *default-stringp-width* 10)))
  (setf *database-documentation* (second keyword-values))
  (cond ((string-equal user-id "")
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - You must be logged in before defining a database"))
 (return-from define-database nil)))
  (if *provide-status-messages*
      (format *standard-output* "~%Defining database ~s" db-name))
  ;1;*
  ;1;  Define the system relations. The first four system relations are needed to define all of the others, therefore their structures are*
  ;1; defined and the tuple for the system-relation relation is created but not inserted until all four have been defined. Then the tuples will*
  ;1; be inserted and the other system relations will be defined.*
  ;1;*
  (setf *active-db* db-name
        *save-user-id* user-id
user-id *pkg-string*
*domain-list* '("ANYP" "ATOM" "LISTP" "NUMBERP" "STRINGP")
;1;*
;1;  We will be needing this because all the information is not provided in the system-domain relation while we are defining the *
;1; database. We will reset this to nil so that the user defined relations will refer to the system-domain relation.*
;1;*
temp-validity-checking *validity-checking*
*validity-checking* nil)
  ;1;*
  ;1;  Define the SYSTEM-RELATION relation*
  ;1;*
  (cond ((null (define-system-relation))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-RELATION could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-ATTRIBUTE relation*
  ;1;*
  (cond ((null (define-system-attribute))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-ATTRIBUTE could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-DOMAIN relation*
  ;1;*
  (cond ((null (define-system-domain))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-DOMAIN could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-VIEW relation*
  ;1;*
  (cond ((null (define-system-view))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-VIEW could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-IMPLEMENTATION relation*
  ;1;*
  (cond ((null (define-system-implementation))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-IMPLEMENTATION could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-STORAGE-STRUCTURE relation*
  ;1;*
  (cond ((null (define-system-storage-structure))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-STORAGE-STRUCTURE could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-OPTFUNC relation*
  ;1;*
  (cond ((null (define-system-optfunc))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-OPTFUNC could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-WHEREOPT relation*
  ;1;*
  (cond ((null (define-system-whereopt))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-WHEREOPT could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  Define the SYSTEM-INDEX relation*
   ;1;*
  (cond ((null (define-system-index))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - SYSTEM-INDEX could not be defined"))
 (setf *active-db* nil)
 (return-from define-database nil)))
  ;1;*
  ;1;  All of the system relations have been defined, insert the tuples*
  ;1;*
  (if *provide-status-messages*
      (format *standard-output* "~%Insert the tuples into the system relations"))
  (setf user-id (or *save-user-id* user-id))
  (cond ((not *donot-commit*)
 (commit-system-relation)
 (init-where-opt)))
  (setf *validity-checking* temp-validity-checking)
  (if *provide-status-messages*
      (format *standard-output* "~%Definition of database ~s has been completed successfully" *active-db*))
  ;1;*
  ;1;  If the user has requested a save, then save the database*
  ;1;*
  (if (and (or *auto-save* (nth 3 keyword-values)) (not *donot-commit*))
      (save-database *active-db*))
  (return-from define-database *active-db*)))

(defun define-system-attribute ()
  (setf *system-attribute-key* '("RELATION-NAME" "ATTRIBUTE-NAME")
*system-attribute-key-domains* '("STRINGP" "STRINGP")
*system-attribute-attributes* '("RELATION-NAME" "ATTRIBUTE-NAME" "DOMAIN-FUNCTION" "DEFAULT-VALUE"
"DOC" "OWNER-ID")
*system-relations* (cons "SYSTEM-ATTRIBUTE" *system-relations*))
  (define-relation 'system-attribute
   '(relation-name (dom "STRINGP" doc "Name of the relation which the attribute belongs" def ""
    format 15)
     attribute-name (dom "STRINGP" doc "The name of the attribute" def "" format 15)
     domain-function (dom "STRINGP" doc "The membership domain predicate" def "" format 10)
     default-value (dom "ANYP" doc "the value to used if one is not specified" def "?"
format 10)
     doc (dom "STRINGP" doc "The attribute documentation string" def "" format 15)
     owner-id (dom "STRINGP" doc "The owner of the relation which contains the attr" def ""
   format 10))
    'imp *system-relation-base-implementation* 'key *system-attribute-key*
    'sto *system-relation-storage-structure*
    'doc "Contains one entry for each attribute in the database"))

(defun define-system-domain (&aux system-domain-list)
  (setf *system-domain-key*  '("DOMAIN-NAME")
*system-domain-key-domains* '("STRINGP")
*system-domain-attributes* '("DOMAIN-NAME" "OWNER-ID" "DEFAULT-PRINT-WIDTH" "DEFAULT-VALUE" "DOC")
*system-relations* (cons "SYSTEM-DOMAIN" *system-relations*))
  (define-relation 'system-domain
   '(domain-name (dom stringp doc "The name of the domain" def "" format 20)
     owner-id (dom "STRINGP" doc "The owner of the domain definition" def "" format 15)
     default-print-width (dom "NUMBERP"  doc "The print width of the domain" def 0 format 6)
     default-value (dom "ANYP" doc "The default value of the domain" def "?" format 10)
     doc (dom "STRINGP" doc "The attribute documentation string" def "" format 25))
    'imp *system-relation-base-implementation* 'sto *system-relation-storage-structure*
    'key *system-domain-key* 'doc "Contains one entry for each domain in the database")
  ;1;*
  ;1;  Define the tuples which will be inserted into the SYSTEM-DOMAIN relation*
  ;1;*
  (setf system-domain-list
`(("ANYP" "RTMS" ,*default-anyp-width* ,*default-anyp-value* "Always returns T")
  ("ATOM" "RTMS" ,*default-atom-width* ,*default-atom-value* "The Lisp ATOM function")
  ("LISTP" "RTMS" ,*default-listp-width* ,*default-listp-value* "The Lisp LISTP function")
  ("NUMBERP" "RTMS" ,*default-numberp-width* ,*default-numberp-value* "The Lisp NUMBERP function")
  ("STRINGP" "RTMS" ,*default-stringp-width* ,*default-stringp-value* "The Lisp STRINGP function")))
  (putp 'system-domain system-domain-list 'commit-tuples))

(defun define-system-implementation (&aux system-implementation-list)
  (setf *system-implementation-key* '("IMPLEMENTATION-NAME")
*system-implementation-key-domains* '("STRINGP")
*system-implementation-attributes* '("IMPLEMENTATION-NAME" "OWNER-ID" "DOC")
*system-relations* (cons "SYSTEM-IMPLEMENTATION" *system-relations*))
  (define-relation 'system-implementation
   '(implementation-name (dom "STRINGP" doc "The name of the storage structure being defined"
  def "" format 20)
     owner-id (dom "STRINGP" doc "The owner of the implementation definition" def "" format 20)
     doc (dom "STRINGP" doc "The implementation documentation string" def "" format 35))
    'imp *system-relation-base-implementation* 'key *system-implementation-key*
    'sto *system-relation-storage-structure*
    'doc "Contains one entry for each implementation in the database")
  ;1;*
  ;1;  Form the tuples which will be inserted into the SYSTEM-IMPLEMENTATION relation*
  ;1;*
  (setf system-implementation-list '(("FLAVOR" "RTMS" "Tuples are flavor instances")
     ("LIST" "RTMS" "Tuples are implemented as a list")
     ("STRUCT" "RTMS" "Tuples are structure instances")))
  (putp 'system-implementation system-implementation-list 'commit-tuples))

(defun define-system-index ()
  (setf *system-index-key* '("RELATION-NAME")
*system-index-key-domains* '("STRINGP")
*system-index-attributes* '("RELATION-NAME" "INDEX-NAME" "INDEX-TYPE" "KEY" "PRIORITY" "DOC")
*system-relations* (cons "SYSTEM-INDEX" *system-relations*))
  (define-relation 'system-index
   '(relation-name (dom "STRINGP" doc "The name of the relation upon which the index is being defined"
    def "" format 20)
   index-name (dom "STRINGP" doc "The name of the index which is defined on the relation"
       def "" format 20)
   index-type (dom "STRINGP" doc "The storage structure type of the index" def "AVL"
       format 20)
   key (dom "LISTP" def '() format 10
doc "A list containing the names of the attribute names which form the key")
   priority (dom "NUMBERP" def 2 format 8
     doc "A positive, non-zero number specifying the priority of the index which is used when attempting to extract a key. 1 is the highest priority.")
   doc (dom "STRINGP" doc "The index documentation string" def "" format 35))
    'imp *system-relation-base-implementation* 'key *system-index-key*
    'sto *system-relation-storage-structure* 'doc "Contains one entry for each index in the database"))

(defun define-system-optfunc (&aux system-optfunc-tuple-list)
  (setf *system-optfunc-key* '("SYMBOL-NAME" "STORAGE-STRUCTURE-TYPE")
*system-optfunc-key-domains* '("STRINGP" "STRINGP")
*system-optfunc-attributes* '("SYMBOL-NAME" "STORAGE-STRUCTURE-TYPE" "OPTIMIZE-FUNCTION" "OWNER-ID")
*system-relations* (cons "SYSTEM-OPTFUNC" *system-relations*))
  (define-relation 'system-optfunc
   '(symbol-name (dom "STRINGP" doc "The name of the symbol" def "" format 20)
 storage-structure-type (dom "STRINGP" def "" format 20
 doc "Optimizations are based on the ss type")
 optimize-function (dom "STRINGP" def "" format 25
    doc "The name of the optimization function for this symbol")
 owner-id (dom "STRINGP" def "" format 10
   doc "The originator of the optimization function" ))
    'imp *system-relation-base-implementation* 'key *system-optfunc-key*
    'sto *system-relation-storage-structure*
    'doc "Contains one entry for each defined function and storage structure")
  ;1;*
  ;1;  Define the tuples which will be inserted into the SYSTEM-OPTFUNC relation*
  ;1;*
  (setf system-optfunc-tuple-list
'(("=" "HASH" "OPT-HASH-EQUAL" "RTMS")
  ("=" "AVL" "OPT-AVL-EQUAL" "RTMS")
;1  ("+" "HASH" "OPT-HASH-PLUS" "RTMS")*
  ("<" "AVL" "OPT-AVL-LT" "RTMS")
  (">" "AVL" "OPT-AVL-GT" "RTMS")
  ("<=" "AVL" "OPT-AVL-LT" "RTMS")
  (">=" "AVL" "OPT-AVL-GT" "RTMS")
  ("AND" "HASH" "OPT-HASH-AND" "RTMS")
  ("AND" "AVL" "OPT-AVL-AND" "RTMS")
  ("EQUAL" "HASH" "OPT-HASH-EQUAL" "RTMS")
  ("EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS")
  ("LESSP" "AVL" "OPT-AVL-LT" "RTMS")
  ("STRING-LESSP" "AVL" "OPT-AVL-LT" "RTMS")
  ("GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
  ("STRING-GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
  ("OR" "HASH" "OPT-HASH-OR" "RTMS")
  ("OR" "AVL" "OPT-AVL-OR" "RTMS")
;1  ("PLUS" "HASH" "OPT-HASH-PLUS" "RTMS")*
  ("STRING-EQUAL" "HASH" "OPT-HASH-EQUAL" "RTMS")
  ("STRING-EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS")))
  (putp 'system-optfunc system-optfunc-tuple-list 'commit-tuples))

(defun define-system-relation ()
  (setf *system-relation-key* '("RELATION-NAME")
*system-relation-key-domains* '("STRINGP")
*system-relation-attributes* '("RELATION-NAME" "OWNER-ID" "MODIFIEDP" "CARDINALITY" "TUPLE-FORMAT"
       "ATTRIBUTES" "DOMAINS" "KEY" "SAVE-DIRECTORY" "DOC" "IMPLEMENTATION-TYPE"
       "STORAGE-STRUCTURE" "DISK")
        *system-relations* '("SYSTEM-RELATION"))
  (define-relation 'system-relation
     '(relation-name (dom "STRINGP" format (20) doc "The name of the relation" def "")
       owner-id (dom "STRINGP" doc "The owner of the relation" def "" format (10))
       modifiedp (dom "ANYP" format (3) doc "T if modified since last save" def "?")
       cardinality (dom "NUMBERP" doc "The number of tuples in the relation" format (6) def 0)
       tuple-format (dom "LISTP" doc "List of print widths of attributes" def '() format (20))
       attributes (dom "LISTP" doc "List of attribute descriptors" def '() format (20))
       domains (dom "LISTP" doc "List of the domains types of the attributes" def '() format (20))
       key (dom "LISTP" doc "List of secondary indicies" def '() format (20))
       save-directory (dom "STRINGP" doc "The directory where the relation will be saved"
       def "" format (20))
       doc (dom "STRINGP" doc "The documentation string" def "" format (20))
       implementation-type (dom "STRINGP" doc "The base implementation type" def "" format (6))
       storage-structure (dom "STRINGP" doc "The storage structure type of the relation" def ""
  format (6))
               disk (dom "ANYP" doc "T is the relation is on disk, else it is in memory" default '()
     format (4)))
    'imp *system-relation-base-implementation* 'sto *system-relation-storage-structure*
    'key *system-relation-key* 'doc "Contains one tuple for each relation in the database"))

(defun define-system-storage-structure (&aux system-storage-structure-list)
  (setf *system-storage-structure-key* '("STORAGE-STRUCTURE-NAME")
*system-storage-structure-key-domains* '("STRINGP")
*system-storage-structure-attributes* '("STORAGE-STRUCTURE-NAME" "OWNER-ID" "DOC")
*system-relations* (cons "SYSTEM-STORAGE-STRUCTURE" *system-relations*))
  (define-relation 'system-storage-structure
  '(storage-structure-name (dom "STRINGP" doc "The name of the storage structure being defined"
    def "" format 20)
    owner-id (dom "STRINGP" doc "The owner of the storage structure definition" def "" format 20)
    doc (dom "STRINGP" doc "The storage structure documentation string" def "" format 35))
    'imp *system-relation-base-implementation* 'sto *system-relation-storage-structure*
    'key *system-storage-structure-key*
    'doc "Contains one entry for each implementation in the database")
  ;1;*
  ;1;  Define the tuples to be inserted into the SYSTEM-STORAGE-STRUCTURE relation*
  ;1;*
  (setf system-storage-structure-list
'(("HEAP" "RTMS" "Tuples are stored in a list")
  ("HASH" "RTMS" "Tuples are stored in a hash table")
  ("AVL" "RTMS" "Tuples are stored in an avl height balanced binary tree")))
  (putp 'system-storage-structure system-storage-structure-list 'commit-tuples))

(defun define-system-view ()
  (setf *system-view-key* '("VIEW-NAME" "OWNER-ID")
*system-view-key-domains* '("STRINGP" "STRINGP")
*system-view-attributes* '("VIEW-NAME" "VIEW-DEFINITION" "OWNER-ID" "VIEW-DOCUMENTATION")
*system-relations* (cons "SYSTEM-VIEW" *system-relations*))
  (define-relation 'system-view '(view-name (dom "STRINGP" doc "the name of the view" def "" format 20)
         view-definition (dom "ANYP" doc "the definition of the view" def "?" format 30)
         owner-id (dom "STRINGP" doc "the owner of the view" def "" format 20)
        view-documentation (dom "STRINGP" doc "the documentation of the view" def "" format 10))
    'imp *system-relation-base-implementation* 'sto *system-relation-storage-structure*
    'key *system-view-key* 'doc "Contains an entry for each view."))

(defun define-system-whereopt ()
  (setf *system-whereopt-key* '("FUNCTION-NAME")
*system-whereopt-key-domains* '("STRINGP")
*system-whereopt-attributes*  '("FUNCTION-NAME" "DOCUMENTATION")
*system-relations* (cons "SYSTEM-WHEREOPT" *system-relations*))
  (define-relation 'system-whereopt
     '(function-name (dom stringp format 20 def ""
      doc "The name of the function which may be optimized for the where clause")
       documentation (dom "STRINGP" doc "The documentation string" def "" format 20))
    'imp *system-relation-base-implementation* 'sto *system-relation-storage-structure*
    'key *system-whereopt-key*
    'doc "Contains one tuple for each aggregate function in the database")
  ;1;*
  ;1;  Define the tuples which will be inserted into the SYSTEM-OPTFUNC relation*
  ;1;*
  (putp 'system-whereopt '(("AVERAGE" "RTMS average function")
   ("COUNT-RTMS" "RTMS count function")
   ("RTMS-COUNT" "RTMS count function")
   ("MAXIMUM" "RTMS maximum function")
   ("MINIMUM" "RTMS minimum function")
   ("SUM" "RTMS sum function"))
'commit-tuples))


t domain-key-list
      rebalancep relation-name))
 (rplaca (cddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (left-balance tree rebalancep)))))
((equal comparison-operator 'greater-than)
 (multiple-value-setq (mod-tree rebalancep)
   (insert-avl-struct new-element (cadddr tree) key key-list attribute-list domain-key-list
      rebalancep relation-name))
 (rplaca (cdddr tree) mod-tree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (right-balance tree rebalancep)))))
((equal comparison-operator 'equal)
 (multiple-value-setq (tree rebalancep)
   (insert-avl-equal tree new-element rebalancep))))))
  (values tree rebalancep))

(defun insert-avl-equal (tree new-element rebalancep)
  (rplaca tree (append (car new-element) (car tree)))
  (setf rebalancep nil)
  (values tree rebalancep))

(defun left-balance (tree rebalancep
     &aux left-branch right-branch)
  (cond ((equal (cadr tree) -1)
 (rplaca (cdr tree) 0)
 (LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540655. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "DEFINE-DB" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360375. :AUTHOR "REL3" :LENGTH-IN-BYTES 7476. :LENGTH-IN-BLOCKS 15. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lDEFINE-DB\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPDEFINE-DATABASEOPÀDEFDBBPUS`U`F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\	DB-NAME&RESTKEYWORD-LIST&KEYj&OPTIONALjDIRECTORYENVIRONMENTDOCUMENTATIONj&ALLOW-OTHER-KEYSB:\BcBfBgBhDIR-KEYWORD-LISTÁKEYWORD-VALUESÂTEMP-VALIDITY-CHECKINGB:\)MACROS-EXPANDED\SECONDTHIRDSETFDOCUMENTATION,Define a new database.

   DB-NAME     - Name of the database.
   DIRECTORY   - Name of the directory in which this database is to be saved.
   ENVIRONMENT - Name of the environment to be associated with this database.
   DOCUMENTATION - A string describing this database.*AUTO-SAVE*Á*DONOT-COMMIT*у*VALIDITY-CHECKING*Á*DOMAIN-LIST*C*PROVIDE-STATUS-MESSAGES*pBU,USER-ID*DATABASE-DOCUMENTATION**DEFAULT-STRINGP-WIDTH**DEFAULT-NUMBERP-WIDTH*Â*DEFAULT-LISTP-WIDTH*у*DEFAULT-ATOM-WIDTH*у*DEFAULT-ANYP-WIDTH*C*ENVIRONMENT-NAME**SAVE-DIRECTORY*Á*SAVE-USER-ID*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*у*PARAMETER-CHECKING*\iDIRECTORYENVIRONMENTBtpB]STORE-KEYARGSdefdbACTIVE-DATABASESTRINGlRETRIEVE-l-CONCATENATEҪFIND-SYMBOLSYSTEM-RELATION\RELATION-NAME\STRING-EQUALCMODIFIEDPlTTERPRI,ERROR - WRITE-STRINGPRIN1 is the current database and it has modified relationsl        Please resolve this conflict by either saving or destroying this databasel        before defining a new oneSTRING-UPCASE\DIRDOCENVDE-NEST-KEYWORD-LISTGET-KEYWORD-VALUE-PREREQ҃VALIDATE-SYMCGET-KEYWORD-VALUEÁGET-DIRECTORY\B\BpB],*APPENDLOAD-ENVIRONMENT,pB]STRING-EQUAL*,ERROR - You must be logged in before defining a databaselDefining database \ANYPATOMLISTP,NUMBERP,STRINGPÂDEFINE-SYSTEM-RELATIONҬERROR - SYSTEM-RELATION could not be definedDEFINE-SYSTEM-ATTRIBUTEERROR - SYSTEM-ATTRIBUTE could not be definedDEFINE-SYSTEM-DOMAINlERROR - SYSTEM-DOMAIN could not be definedCDEFINE-SYSTEM-VIEW,ERROR - SYSTEM-VIEW could not be definedDEFINE-SYSTEM-IMPLEMENTATIONlERROR - SYSTEM-IMPLEMENTATION could not be definedDEFINE-SYSTEM-STORAGE-STRUCTUREERROR - SYSTEM-STORAGE-STRUCTURE could not be definedÂDEFINE-SYSTEM-OPTFUNCҬERROR - SYSTEM-OPTFUNC could not be definedÂDEFINE-SYSTEM-WHEREOPTҬERROR - SYSTEM-WHEREOPT could not be definedDEFINE-SYSTEM-INDEXlERROR - SYSTEM-INDEX could not be definedInsert the tuples into the system relationsÂCOMMIT-SYSTEM-RELATIONÁINIT-WHERE-OPT,Definition of database , has been completed successfullyÁSAVE-DATABASE@@QPA)P$PPP PP!P"G#PP$PP%P#PJG&'P(P)*P(&+P(&,P(R	Q-.P@Q/0@Q1R.P@Q2E@Q3P4P@Q2BrEQE[4	5PT6DRDQ7P7
J
JJJ
J
EW	P8P9&:P(R&;P(Q)QPP<PPF=&>P(R?&@P(RA&BP(RC&DP(RE&FP(RG&HP(RI&JP(RK&LP(RM&NP(R&OP(PPPQFQ&RP(P)SP(EQPTOBPB+FF $B:BW]FB:B:B:BZFB_BB:B:B:\Bo\BsBBC*SYSTEM-RELATIONS*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*Ã*SYSTEM-ATTRIBUTE-KEY-DOMAINS*Â*SYSTEM-ATTRIBUTE-KEY*\RELATION-NAMEATTRIBUTE-NAME\,STRINGP,STRINGP\RELATION-NAMEATTRIBUTE-NAME,DOMAIN-FUNCTIONDEFAULT-VALUEDOC,OWNER-ID,SYSTEM-ATTRIBUTESYSTEM-ATTRIBUTE\ÁRELATION-NAME\DOM,STRINGPB,Name of the relation which the attribute belongspBUDEF,FORMATFÁATTRIBUTE-NAME\B,STRINGPBlThe name of the attributeB,BFDOMAIN-FUNCTION\B,STRINGPB,The membership domain predicateB,BF
ÁDEFAULT-VALUE\BANYPBlthe value to used if one is not specifiedBl?BF
B\B,STRINGPBlThe attribute documentation stringB,BFOWNER-ID\B,STRINGPBlThe owner of the relation which contains the attrB,BF
IMPKEYSTOBContains one entry for each attribute in the databaseDEFINE-RELATION	P
PPP\PPPPPPPPPP
JO$BB.h@.FK$B:BW]FB:B:B:BZFB_BB:B:\CSYSTEM-DOMAIN-LIST\Bo\pB]XR-BQ-LIST*pB]lXR-BQ-LISTBs*DEFAULT-STRINGP-VALUE*B~*DEFAULT-NUMBERP-VALUE*BÂ*DEFAULT-LISTP-VALUE*Bу*DEFAULT-ATOM-VALUE*Bу*DEFAULT-ANYP-VALUE*BBBBC*SYSTEM-DOMAIN-ATTRIBUTES*у*SYSTEM-DOMAIN-KEY-DOMAINS*у*SYSTEM-DOMAIN-KEY*\DOMAIN-NAME\,STRINGP\DOMAIN-NAME,OWNER-IDDEFAULT-PRINT-WIDTHDEFAULT-VALUEDOCSYSTEM-DOMAINÁSYSTEM-DOMAIN\
DOMAIN-NAME\B*STRINGPBThe name of the domainB,BFB\B,STRINGPBlThe owner of the domain definitionB,BFDEFAULT-PRINT-WIDTH\B,NUMBERPBThe print width of the domainBBFB\BANYPB,The default value of the domainBl?BF
B\B,STRINGPBlThe attribute documentation stringB,BFBB!B BlContains one entry for each domain in the databaseB#ҬANYPRTMS\,Always returns TLIST*ҬATOM\The Lisp ATOM functionLISTP\,The Lisp LISTP function,NUMBERP\lThe Lisp NUMBERP function,STRINGP\lThe Lisp STRINGP functionLISTÁCOMMIT-TUPLESPUTPPPPP\PPPPPPPPPP
JP PPP!P"#P P
P	P$P"%P PPP&P"'P PPP(P")P PPP*P"+@P@Q,P-OyBB4@F&$B:BW]FB:B:B:BZFB_BB:B:\CSYSTEM-IMPLEMENTATION-LIST\Bo\BsBBBC*SYSTEM-IMPLEMENTATION-ATTRIBUTES*у*SYSTEM-IMPLEMENTATION-KEY-DOMAINS*у*SYSTEM-IMPLEMENTATION-KEY*\IMPLEMENTATION-NAME\,STRINGP\IMPLEMENTATION-NAME,OWNER-IDDOCSYSTEM-IMPLEMENTATIONÂSYSTEM-IMPLEMENTATION\IMPLEMENTATION-NAME\B,STRINGPB,The name of the storage structure being definedB,BFB\B,STRINGPBlThe owner of the implementation definitionB,BFB\B,STRINGPB,The implementation documentation stringB,BF#BB B!BlContains one entry for each implementation in the databaseB#\\FLAVORRTMSTuples are flavor instances\LISTRTMS,Tuples are implemented as a list\STRUCTRTMSTuples are structure instancesBwBx	P
PPP\PPPPPPPPPP
JP@P@QPOBB+FF $B:BW]FB:B:B:BZFB_BB:B:B:\Bo\BsBBBC*SYSTEM-INDEX-ATTRIBUTES*C*SYSTEM-INDEX-KEY-DOMAINS*C*SYSTEM-INDEX-KEY*\RELATION-NAME\,STRINGP\RELATION-NAMElINDEX-NAMElINDEX-TYPEKEY,PRIORITYDOCSYSTEM-INDEXSYSTEM-INDEX\B\B,STRINGPBThe name of the relation upon which the index is being definedB,BFCINDEX-NAME\B,STRINGPBThe name of the index which is defined on the relationB,BFCINDEX-TYPE\B,STRINGPB,The storage structure type of the indexBAVLBFB \BLISTPB\B8B:BF
BA list containing the names of the attribute names which form the keyPRIORITY\B,NUMBERPBFBFBA positive, non-zero number specifying the priority of the index which is used when attempting to extract a key. 1 is the highest priority.B\B,STRINGPBThe index documentation stringB,BF#BB B!BlContains one entry for each index in the databaseB#	P
PPP\PPPPPPPPPP
JOBB4@F&$B:BW]FB:B:B:BZFB_BB:B:\CSYSTEM-OPTFUNC-TUPLE-LIST\Bo\BsBBBу*SYSTEM-OPTFUNC-ATTRIBUTES*у*SYSTEM-OPTFUNC-KEY-DOMAINS*у*SYSTEM-OPTFUNC-KEY*\SYMBOL-NAMESTORAGE-STRUCTURE-TYPE\,STRINGP,STRINGP\SYMBOL-NAMESTORAGE-STRUCTURE-TYPElOPTIMIZE-FUNCTION,OWNER-IDSYSTEM-OPTFUNCÁSYSTEM-OPTFUNC\SYMBOL-NAME\B,STRINGPBThe name of the symbolB,BFÂSTORAGE-STRUCTURE-TYPE\B,STRINGPB,BFBOptimizations are based on the ss typeCOPTIMIZE-FUNCTION\B,STRINGPB,BFBThe name of the optimization function for this symbolB\B,STRINGPB,BF
BThe originator of the optimization functionBB B!BlContains one entry for each defined function and storage structureB#\\l=HASHOPT-HASH-EQUALRTMS\l=AVLOPT-AVL-EQUALRTMS\l<AVLlOPT-AVL-LTRTMS\l>AVLlOPT-AVL-GTRTMS\l<=AVLlOPT-AVL-LTRTMS\l>=AVLlOPT-AVL-GTRTMS\ANDHASHOPT-HASH-ANDRTMS\ANDAVLOPT-AVL-ANDRTMS\EQUALHASHOPT-HASH-EQUALRTMS\EQUALAVLOPT-AVL-EQUALRTMS\LESSPAVLlOPT-AVL-LTRTMS\STRING-LESSPAVLlOPT-AVL-LTRTMS\,GREATERPAVLlOPT-AVL-GTRTMS\,STRING-GREATERPAVLlOPT-AVL-GTRTMS\lORHASHOPT-HASH-ORRTMS\lORAVLlOPT-AVL-ORRTMS\STRING-EQUALHASHOPT-HASH-EQUALRTMS\STRING-EQUALAVLOPT-AVL-EQUALRTMSBwBx	P
PPP\PPPPPPPPPP
JP@P@QPO~BB
)FF$B:BW]FB:B:B:BZFB_BB:B:B:\Bo\BsBBBBÃ*SYSTEM-RELATION-KEY-DOMAINS*B\RELATION-NAME\,STRINGP\RELATION-NAME,OWNER-IDlMODIFIEDPCARDINALITYTUPLE-FORMATlATTRIBUTES,DOMAINSKEYSAVE-DIRECTORYDOCIMPLEMENTATION-TYPElSTORAGE-STRUCTUREDISK\,SYSTEM-RELATIONB\B\B,STRINGPB\FB,The name of the relationB,B\B,STRINGPBlThe owner of the relationB,B\F
B\BANYPB\FBT if modified since last saveBl?CARDINALITY\B,NUMBERPBThe number of tuples in the relationB\FBTUPLE-FORMAT\BLISTPBlList of print widths of attributesB\B8B:B\FCATTRIBUTES\BLISTPBList of attribute descriptorsB\B8B:B\FDOMAINS\BLISTPBList of the domains types of the attributesB\B8B:B\FB \BLISTPBlList of secondary indiciesB\B8B:B\FÁSAVE-DIRECTORY\B,STRINGPBThe directory where the relation will be savedB,B\FB\B,STRINGPB,The documentation stringB,B\FIMPLEMENTATION-TYPE\B,STRINGPBThe base implementation typeB,B\FCSTORAGE-STRUCTURE\B,STRINGPBlThe storage structure type of the relationB,B\FDISK\BANYPBlT is the relation is on disk, else it is in memoryDEFAULT\B8B:B\FBB!B BContains one tuple for each relation in the databaseB#	P
PPPPPPPPPPPPP
JOBB4@F&$B:BW]FB:B:B:BZFB_BB:B:\ÃSYSTEM-STORAGE-STRUCTURE-LIST\Bo\BsBBBÄ*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*Ä*SYSTEM-STORAGE-STRUCTURE-KEY-DOMAINS*Ã*SYSTEM-STORAGE-STRUCTURE-KEY*\STORAGE-STRUCTURE-NAME\,STRINGP\STORAGE-STRUCTURE-NAME,OWNER-IDDOC,SYSTEM-STORAGE-STRUCTURESYSTEM-STORAGE-STRUCTURE\ÂSTORAGE-STRUCTURE-NAME\B,STRINGPB,The name of the storage structure being definedB,BFB\B,STRINGPBThe owner of the storage structure definitionB,BFB\B,STRINGPBlThe storage structure documentation stringB,BF#BB!B BlContains one entry for each implementation in the databaseB#\\HEAPRTMSTuples are stored in a list\HASHRTMSlTuples are stored in a hash table\AVLRTMS,Tuples are stored in an avl height balanced binary treeBwBx	P
PPP\PPPPPPPPPP
JP@P@QPO.BB+FF $B:BW]FB:B:B:BZFB_BB:B:B:\Bo\BsBBB*SYSTEM-VIEW-ATTRIBUTES*C*SYSTEM-VIEW-KEY-DOMAINS*C*SYSTEM-VIEW-KEY*\lVIEW-NAME,OWNER-ID\,STRINGP,STRINGP\lVIEW-NAME,VIEW-DEFINITION,OWNER-IDlVIEW-DOCUMENTATIONSYSTEM-VIEWSYSTEM-VIEW\CVIEW-NAME\B,STRINGPBthe name of the viewB,BFVIEW-DEFINITION\BANYPBlthe definition of the viewBl?BFB\B,STRINGPBthe owner of the viewB,BFpBUlVIEW-DOCUMENTATION\B,STRINGPBthe documentation of the viewB,BF
BB!B B,Contains an entry for each view.B#	P
PPP\PPPPPPPPPP
JObBB2FF%$B:BW]FB:B:B:BZFB_BB:B:B:\Bo\BsBBBу*SYSTEM-WHEREOPT-ATTRIBUTES*Ã*SYSTEM-WHEREOPT-KEY-DOMAINS*Â*SYSTEM-WHEREOPT-KEY*\FUNCTION-NAME\,STRINGP\FUNCTION-NAMEDOCUMENTATION,SYSTEM-WHEREOPTSYSTEM-WHEREOPT\pBUFUNCTION-NAME\BBKBFB,BThe name of the function which may be optimized for the where clauseBh\B,STRINGPB,The documentation stringB,BFBB!B BContains one tuple for each aggregate function in the databaseB#\\,AVERAGERTMS average function\lCOUNT-RTMSRTMS count function\lRTMS-COUNTRTMS count function\,MAXIMUMRTMS maximum function\,MINIMUMRTMS minimum function\SUMlRTMS sum functionBwBx	P
PPP\PPPPPPPPPP
JPPPOB1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\B3.ً\B1N\Bs[\Br:}n\Bq{ "RTMS")
  ("STRING-LESSP" "AVL" "OPT-AVL-LT" "RTMS")
  ("GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
  ("STRING-GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
  ("OR" "HASH" "OPT-HASH-OR" "RTMS")
  ("OR" "AVL" "OPT-AVL-OR" "RTMS")
;1  ("PLUS" "HASH" "OPT-HASH-PLUS" "RTMS")*
  ("STRING-EQUAL" "HASH" "OPT-HASH-EQUAL" "RTMS")
  ("STRING-EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS")))
  (putp 'system-optfunc system-optfunc-LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540658. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DEFINE-DESTROY" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749845989. :AUTHOR "REL3" :LENGTH-IN-BYTES 37613. :LENGTH-IN-BLOCKS 37. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
1;;; DEFINE-DESTROY
;;;
;;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp
;;; Reference
;;;     fdefinedp
;;;     errset
;;;     deff*
(deff defdom 'define-domain)

(defun define-domain (domain-name &rest keyword-list
      &key &optional default documentation format
      &allow-other-keys
      &aux def width1 doc status? pred)
  "Define new domain. Corresponding predicate is expected to be defined prior to this operation.

   DOMAIN-NAME     - Name of the domain to be defined.
   DOCUMENTATION   - Describes the new domain.
   FORMAT          - Print width for attributes belonging to this domain."
  default documentation format
  (block define-domain
(cond (*parameter-checking*
       (if (not (active-database domain-name))
   (return-from define-domain nil))))
(cond ((not (setf domain-name (validate-sym domain-name t)))
       (return-from define-domain nil)))
(if (null (fdefinedp (setf pred (read-from-string (string-append *pkg-name* domain-name)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The predicate ~S has not been defined yet." pred))
      (return-from define-domain nil)))
(if (member domain-name (mapcar (function (lambda (dom)
    (car dom)))
(qtrieve 'system-domain *system-domain-attributes* '(domain-name)
 *system-domain-key* t)) :test 'string-equal)
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The domain ~s already exists and may not be redefined."
  domain-name))
      (return-from define-domain nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
(if *provide-status-messages*
    (format *standard-output* "~%Define domain ~s" domain-name))
(setf keyword-list (get-keyword-value-prereq '("DEF" "FORMAT" "DOC") keyword-list))
(if (setf width1 (car (get-keyword-value '(format) keyword-list)))
    (validate-format (setf width1 (if (not (listp width1)) width1 (car width1))))
    (setf width1 *default-anyp-width*))
(setf def (car (get-keyword-value '(def) keyword-list)))
(cond (*validity-checking*
       (cond ((null (car (errset (funcall pred def) nil)))
      (cond (*provide-warning-messages*
     (format *standard-output*
     "~%WARNING - The default value ~S does not satisfy the domain ~S"
     def domain-name)
     (format *standard-output*
     "~%          Other values will be tested for validity")))
      (setf def nil)))))
(cond ((null def)
       (mapc (function (lambda (existing-def)
 (if (car (errset (funcall pred (car existing-def)) nil))
     (setf def (car existing-def)))))
     (qtrieve 'system-domain *system-domain-attributes* '(default-value) *system-domain-key*
      t))))
(if (null def)
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - None of the existing default values are valid for ~S."
  domain-name))
      (return-from define-domain nil)))
(if (setf doc (car (get-keyword-value '(doc) keyword-list)))
    doc
    (setf doc nil))
(setf status? *provide-status-messages*
      *provide-status-messages* nil)
(insert 'system-domain 'tuples (list (list domain-name user-id width1 def doc)))
(setf *provide-status-messages* status?)
(if *provide-status-messages*
    (format *standard-output* "~%Definition of domain ~s completed." domain-name))
(return-from define-domain domain-name)))

(deff defenv 'define-environment)

(defun define-environment (environment &rest keyword-list
   &key &optional auto-save directory errors parameter-checking
   relation-implementation relation-storage-structure status system-implementation
   system-storage-structure validity warnings
   &allow-other-keys
   &aux all-key-values
   keyword-list-2 (legal-imp nil) (legal-sto nil) (sys-imp nil) (sys-sto nil)
   (keywords '("AUTO" "DIR" "ERR" "PARA" "REL-IMP" "REL-STO" "STAT" "SYS-IMP" "SYS-STO"
       "VAL" "WARN")))
  "Global variables defining an environment can be set using this function.

   ENVIRONMENT  - Name of the environment.
   AUTO-SAVE    - If T, RTMS saves the database whenever a relation is modified.
   DIRECTORY    - Name of the default directory in which the database is to be saved.
   ERRORS       - If T, error messages are generated.
   PARAMETER-CHECKING - If T, extensive parameter validity checking is done.
   RELATION-IMPLEMENTATION - The default implementation type for the user relations.
   RELATION-STORAGE-STRUCTURE -The default storage structure type for the user relations.
   STATUS       - If T, status messages are generated.
   SYSTEM-IMPLEMENTATION - If there is no active database, this value will be used as the implementation
                           type for implementing system-relations.
   SYSTEM-STORAGE-STRUCTURE - If there is no active database, this value will be used as the storage structure
                              for implementing system-relations.
   VALIDITY     - If T, extensive validity checking is done for user-supplied data.
   WARNINGS     - If T, warning messages are generated."
  auto-save directory errors parameter-checking relation-implementation relation-storage-structure status
  system-implementation system-storage-structure validity warnings
  (block define-environment
  (cond ((null (setf environment (validate-sym environment t)))
 (return-from define-environment nil)))
  (setf *environment-name* environment)
  (setf keyword-list (de-nest-keyword-list keyword-list))
  ;;
  ;;1  Obtain the names of the domains which are currently defined in the current database. Form the names of all of the possible*
  ;1; combinations of domain widths and domain default values and add them to the keyword list. Only the system defined domains may be *
  ;1; set before there is an active database.*
  ;;
  ;;
  ;;1  Obtain the values of only the keywords specified*
  ;;
  (setf keyword-list-2 (get-keyword-value-prereq keywords keyword-list))
  (setf keyword-list '())
  (do ((keywords keyword-list-2 (cddr keywords)))
      ((null keywords) t)
    (setf keyword-list (cons (string-upcase (car keywords)) keyword-list)))
  (setf all-key-values (get-keyword-value keywords keyword-list-2))
  ;;
  ;;1  Have determined which environment variables have been specified and their values, now process the list and set the proper variables *
  ;1; after checking for validity of the specified values*
  ;;
  (do ((keyword keyword-list (cdr keyword)))
      ((null keyword) t)
    (cond ((equal (search "AUTO" (car keyword)) 0)
   (setf *auto-save* (car (get-keyword-value '(auto) keyword-list-2))))
  ((equal (search "DIR" (car keyword)) 0)
   (setf *save-directory* (get-directory keyword-list-2)))
  ((equal (search "ERR" (car keyword)) 0)
   (setf *provide-error-messages* (car (get-keyword-value '(err) keyword-list-2))))
  ((equal (search "PARA" (car keyword)) 0)
   (setf *parameter-checking* (car (get-keyword-value '(para) keyword-list-2))))
  ((and (string-equal (car keyword) "REL-IMP")(null *active-db*))
   (setf sys-imp (string-upcase (car (get-keyword-value '(rel-imp) keyword-list-2)))
 *rel-imp* sys-imp)
   (setf *relation-implementation*
 (string-append sys-imp (subseq *relation-implementation*
(position "-" *relation-implementation*
  :test 'string-equal)))))
  ((string-equal (car keyword) "REL-IMP")
   (if (not legal-imp)
       (setf legal-imp (qtrieve 'system-implementation *system-implementation-attributes*
'(implementation-name) *system-implementation-key* t)))
   (setf sys-imp (string-upcase (car (get-keyword-value '(rel-imp) keyword-list-2)))
 *rel-imp* sys-imp)
   (cond ((member (list sys-imp) legal-imp :test 'equal)
  (setf *relation-implementation* (string-append sys-imp
 (subseq  *relation-implementation*
  (position "-"
    *relation-implementation*
    :test 'string-equal)))))
 (*provide-error-messages*
  (format *standard-output* "~%ERROR - ~s is an unrecognized implementation type" sys-imp))))
  ((and (string-equal (car keyword) "REL-STO") (null *active-db*))
   (setf sys-sto (string-upcase (car (get-keyword-value '(rel-sto) keyword-list-2)))
 *rel-sto* sys-sto)
   (setf *relation-implementation* (string-append (subseq *relation-implementation* 0
  (search "-" *relation-implementation*))
  "-" sys-sto)))
  ((string-equal (car keyword) "REL-STO")
   (if (not legal-sto)
       (setf legal-sto (qtrieve 'system-storage-structure *system-storage-structure-attributes*
   '(storage-structure-name) *system-storage-structure-key* t)))
   (setf sys-sto (string-upcase (car (get-keyword-value '(rel-sto) keyword-list-2)))
 *rel-sto* sys-sto)
   (cond ((member (list sys-sto) legal-sto :test 'equal)
  (setf *relation-implementation*
(string-append (subseq *relation-implementation* 0
  (search "-" *relation-implementation*))
       "-" sys-sto)))
 (*provide-error-messages*
  (format *standard-output* "~%ERROR - ~s is an unrecognized storage-structure" sys-sto))))
  ((equal (search "STAT" (car keyword)) 0)
   (setf *provide-status-messages* (car (get-keyword-value '(stat) keyword-list-2))))
  ((and (string-equal (car keyword) "SYS-IMP") *active-db* *provide-warning-messages*)
   (format *standard-output* "~%WARNING - Can not change system relation implementation")
   (format *standard-output* "~%          while there is an active database"))
  ((and (string-equal (car keyword) "SYS-IMP") (not *active-db*))
   (setf sys-imp (string-upcase (car (get-keyword-value '(sys-imp) keyword-list-2))))
   (setf *system-relation-base-implementation* sys-imp))
  ((and (string-equal (car keyword) "SYS-STO") *active-db* *provide-warning-messages*)
   (format *standard-output* "~%WARNING - Can not change system relation storage structure")
   (format *standard-output* "~%          while there is an active database"))
  ((and (string-equal (car keyword) "SYS-STO") (not *active-db*))
   (setf sys-sto (string-upcase (car (get-keyword-value '(sys-sto) keyword-list-2))))
   (setf *system-relation-storage-structure* sys-sto))
  ((equal (search "VAL" (car keyword)) 0)
   (setf *validity-checking* (car (get-keyword-value '(val) keyword-list-2))))
  ((equal (search "WARN" (car keyword)) 0)
   (setf *provide-warning-messages* (car (get-keyword-value '(warn) keyword-list-2))))))
  (if *provide-status-messages*
      (format *standard-output* "~%Environment ~s defined" *environment-name*))
  (return-from define-environment *environment-name*)))


(deff defview 'define-view)
(defun define-view (viewname view-def &rest keyword-list
    &key &optional documentation
    &allow-other-keys
    &aux doc temp-status)
  "Define views on the relations.

   VIEW-NAME - Name of the view.
   VIEW-DEF  - Definition of the view.
   DOCUMENTATION - Describes the view."
  documentation
  (block define-view
(if (not (active-database))
    (return-from define-view nil))
(cond ((null (setf viewname (validate-sym viewname t)))
       (return-from define-view nil)))
(if (relationp viewname)
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - A relation with the name ~S already exists in the ~s database."
  viewname *active-db*))
      (return-from define-view nil)))
(if (member viewname (mapcar (function (lambda (dom)
 (car dom)))
     (qtrieve 'system-view *system-view-attributes* '(view-name)
      *system-view-key* t)) :test 'string-equal)
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The view ~s already exists in the ~s database"
   viewname *active-db*))
      (return-from define-view nil)))
(setf temp-status *provide-status-messages*
      *provide-status-messages* nil)
(setf keyword-list (get-keyword-value-prereq '(doc) keyword-list)
      doc (car (get-keyword-value '(doc) keyword-list)))
(insert 'system-view 'tuples (list (list viewname view-def (string-upcase user-id) doc)))
(setf *provide-status-messages* temp-status)
(if *provide-status-messages*
    (format *standard-output* "~%The ~s view has been defined in the ~s database" viewname *active-db*))
(return-from define-view viewname)))

(defun modify-view (view-name &rest keyword-list
    &key &optional view-definition view-documentation
    &allow-other-keys
    &aux temp1 temp2)
  "Modify a view definition or its documentation.

   VIEW-NAME       - Name of the view.
   VIEW-DEFINITION - New definition of the view.
   VIEW-DOCUMENTATION - New description of the view."
  view-definition view-documentation
  (block modify-view
(cond (*parameter-checking*
       (if (not (active-database view-name))
   (return-from modify-view nil))
       (if (not (setf view-name (validate-sym view-name t)))
   (return-from modify-view nil))))
(if (not (member view-name (mapcar (function (lambda (dom)
       (car dom)))
   (qtrieve 'system-view *system-view-attributes* '(view-name)
    *system-view-key* t)) :test 'string-equal))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The view ~s does not exist." view-name))
      (return-from modify-view nil)))
(if (not (caar (qtrieve 'system-view *system-view-attributes* '("OWNER-ID") *system-view-key*
`(and (string-equal view-name ,view-name) (string-equal owner-id ,user-id)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - The owner of the view ~s is not the same as the current user-id ~S."
  view-name user-id))
      (return-from modify-view nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
;;
;;  Determine if the user wants a memory only destroy
;;
(setf keyword-list (get-keyword-value-prereq '(view-def view-doc doc) keyword-list))
(setf temp1 (car (get-keyword-value '(view-def) keyword-list))
      temp2 (or (car (get-keyword-value '(view-doc) keyword-list))
(car (get-keyword-value '(doc) keyword-list))))
(if (not (or temp1 temp2))
    (return-from modify-view nil))
(modify 'system-view 'where
`(string-equal view-name ',view-name)
'attributes (cond ((and temp1 temp2)
   (list 'view-definition 'view-documentation))
  (temp1 (list 'view-definition))
  (temp2 (list 'view-documentation)))
'values (cond ((and temp1 temp2)
       (list `(quote ,temp1) `(quote ,temp2)))
      (temp1 (list `(quote ,temp1)))
      (temp2 (list `(quote ,temp2)))))
(return-from modify-view view-name)))

(deff destroy-db 'destroy-database)

;;
;;1  RTMS will now look first for xfasl extensions for relation names.  9/24/85 SMC*
;;
(defun destroy-database (database &rest keyword-list
 &key &optional disk &allow-other-keys
 &aux memory-only path pathname)
  "Delete the specified database from memory and all the corresponding files from
   disk if the keyword DISK is T.

   DATABASE - Name of the database to be destroyed.
   DISK     - If T, all the relevant files will be deleted."
  disk
  (block destroy-database
  (cond ((null (setf database (validate-sym database t)))
 (return-from destroy-database nil)))
  (cond ((null *active-db*)
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - Only the active database may currently be destroyed")
(format *standard-output* "~%        and there is currently no active database")))
 (return-from destroy-database nil))
((not (string-equal *active-db* database))
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - Only the active database may currently be destroyed")
(format *standard-output* "~%        The active database is ~s" *active-db*)))
 (return-from destroy-database nil)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  ;;
  ;;  1Determine if the user wants a memory only destroy*
  ;;
  (setf keyword-list (get-keyword-value-prereq '(disk) keyword-list))
  (cond ((setf memory-only (not (car (get-keyword-value '(disk) keyword-list))))
 (if *provide-status-messages*
     (format *standard-output* "~%The database ~s will be deleted from memory" database)))
(t
 (if *provide-status-messages*
     (format *standard-output* "~%Destroying the ~s database" database))))

  ;1;*
  ;;1Right now the name database is not used. But we need it to delete files on the disk*
  ;;1and when the system relations have the database name as prefix or whatever.*
  ;1;*
  ;;Delete the file for the database definition.
  (if (not memory-only)
      (progn
(setf pathname (string-append (get-save-directory) database))
;;
;;  1This was added to handle the change in the extensions used by RTMS*
;;
(cond ((probe-file (setf path (string-append pathname ".lisp")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname ".xld")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname ".xfasl")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname ".qfasl")))
       (delete-file (string-append path "#*")))
      (t
       (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The ~s database does not exist in the directory ~s"
  database (get-directory keyword-list)))
      (return-from destroy-database nil)))))
  (if (not memory-only)
      (mapt
(function
  (lambda (tuple &aux temp pathname path dir)
  (setf temp (read-from-string
       (caar (project-list (list tuple) *system-relation-attributes*
   '("RELATION-NAME")))))
  (setf dir (caar (project-list (list tuple) *system-relation-attributes*
'("SAVE-DIRECTORY"))))
  ;;1DELETE all the files for each relation.*
  (setf pathname (string-append dir *active-db* "-" temp "."))
  (cond-every ((probe-file (setf path (string-append pathname "XLD")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname "XFASL")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname "QFASL")))
       (delete-file (string-append path "#*")))
      ((probe-file (setf path (string-append pathname "LISP")))
       (delete-file (string-append path "#*"))))))
  ;;
  ;;  1If the relation is a flavor, must use the new undef-flavor. This will be done at a *
  ;; 1later time*
  ;;
    'system-relation))
  (recover-all)
  (if *provide-status-messages*
      (format *standard-output* "~%The ~s database has been destroyed" database))
  (return-from destroy-database database)))

(defun get-save-directory ()
  (caar (qtrieve 'system-relation *system-relation-attributes* '("SAVE-DIRECTORY") *system-relation-key*
 '(string-equal relation-name "SYSTEM-RELATION"))))

(deff destroy-rel 'destroy-relation)

;
;1  RTMS will now look first for xfasl extensions for relation names.  9/24/85 SMC*
;

(defun destroy-relation (relation &rest keyword-list
 &key &optional disk &allow-other-keys
 &aux indices qtrieve-var pathname path memory-only)
  "Deletes the specified relation from the active database.
   Deletes all the files on disk if keyword DISK is t.

   RELATION - Name of the relation to be destroyed.
   DISK     - If T, the relevant files will be deleted."
  disk
  (block destroy-relation
  (if (not (active-database))
      (return-from destroy-relation nil))
  (cond ((null (setf relation (validate-sym relation t)))
 (return-from destroy-relation nil)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes*
  '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "SAVE-DIRECTORY")
  *system-relation-key*
  (list 'string-equal 'relation-name (string-upcase relation)))))
  (if (null qtrieve-var)
      (progn
(if *provide-error-messages*
    (format *standard-output* "~%ERROR -2 *The relation ~S is not defined in the database ~s."
    (read-from-string relation) (read-from-string *active-db*)))
(return-from destroy-relation nil)))
  ;;
  ;;1  Determine if the user wants a memory only destroy*
  ;;
  (setf keyword-list (get-keyword-value-prereq '(disk) keyword-list))
  (cond ((setf memory-only (not (car (get-keyword-value '(disk) keyword-list))))
 (if *provide-status-messages*
     (format *standard-output* "~%The relation ~s will be deleted from memory" relation)))
(t
 (if *provide-status-messages*
     (format *standard-output* "~%Destroying the ~s relation" (read-from-string relation)))))
  ;;
  ;;1Delete the system-relation tuple.*
  ;;
    (delete-or-modify 'system-relation nil (list 'string-equal 'relation-name relation))
  ;;1Since the following modification is not done for system-relation in delete-or-modify we have to make an explicit call.*
    (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-RELATION")
      '("CARDINALITY" "MODIFIEDP") (list '(- cardinality 1) t))
  ;;
  ;;1Delete the system-attribute tuples.*
  ;;
  (mapcar (function
    (lambda (attr)
      (delete-or-modify 'system-attribute nil
(list 'and (list 'string-equal 'relation-name (string-upcase (string relation)))
      (list 'string-equal 'attribute-name  (string-upcase attr))))))
  (car qtrieve-var))
  (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-ATTRIBUTE")
    '("CARDINALITY" "MODIFIEDP")  (list (list '- 'cardinality (length (car qtrieve-var))) t))
  ;;
  ;;1  Determine if there are any indices defined for this relation, if so they must also be removed.*
  ;;
  (cond ((and (not (member relation *system-relations* :test 'string-equal))
      (setf indices (qtrieve 'system-index *system-index-attributes* '("2INDEX-NAME"*)
     *system-index-key* `(string-equal relation-name ,relation))))
 (mapc (function (lambda (index-name)
   (putp (car index-name) nil 'entry-point)))
       indices)
 (delete-or-modify 'system-2index* nil `(string-equal relation-name ,relation))
 (delete-or-modify 'system-relation t '(string-equal relation-name "SYSTEM-2INDEX*")
   '("CARDINALITY" "MODIFIEDP") (list (list '- 'cardinality (length indices)) t)))
(t
1   *;;
  ;;1 Later, if the relation is defined but not restored yet, delete the disk file. If the relation is restored and also on disk, delete the file.*
  ;1; And if the optional parameter is T, then expunge the file. We can expunge the whole directory, but that is not what we want.*
  ;1; It will be nice if we can undefine flavor-definition, get rid of array etc.*
  ;;
 (putp relation nil 'entry-point)))
  ;1;*
  ;1;Delete all the files on the disk.*
  ;1;*
  (cond ((not memory-only)
 (setf pathname (string-append (fourth qtrieve-var) *active-db* "-" relation "."))
 (cond-every ((probe-file (setf path (string-append pathname "XLD")))
      (delete-file (string-append path "#*")))
     ((probe-file (setf path (string-append pathname "2X*FASL")))
      (delete-file (string-append path "#*")))
     ((probe-file (setf path (string-append pathname "QFASL")))
      (delete-file (string-append path "#*")))
     ((probe-file (setf path (string-append pathname "LISP")))
      (delete-file (string-append path "#*"))))))
  (return-from destroy-relation relation)))

(defun destroy-domain (domain-name &aux status?)
  "Destroys the domain definition but keeps the domain predicate to handle previously defined data."
  (block destroy-domain
(cond (*parameter-checking*
       (if (not (active-database domain-name))
   (return-from destroy-domain nil))
       (if (not (setf domain-name (validate-sym domain-name t)))
   (return-from destroy-domain nil)))
      (t
       (setf domain-name (string domain-name))))
(if (not (member domain-name
 (mapcar (function (lambda (dom)
     (car dom)))
 (qtrieve 'system-domain *system-domain-attributes* '(domain-name)
   *system-domain-key* t)) :test 'string-equal))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The domain ~s does not exist." domain-name))
      (return-from destroy-domain nil)))
(if (not (equal user-id
(caar (qtrieve 'system-domain *system-domain-attributes* '("OWNER-ID")
   *system-domain-key* `(string-equal domain-name ,domain-name)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - The owner of the domain ~s is not the same as the current user-id ~S."
  domain-name user-id))
      (return-from destroy-domain nil)))
(setf status? *provide-status-messages*
      *provide-status-messages* nil)
(delete-tuples 'system-domain 'where `(string-equal domain-name ',domain-name))
(setf *provide-status-messages* status?)
(setf *domain-list* (remove domain-name *domain-list* :test 'string-equal))
(if *provide-status-messages*
    (format *standard-output* "~%Destruction of domain ~s completed." domain-name))
(return-from destroy-domain domain-name)))

(defun destroy-implementation (implementation-name &aux temp-status)
  "Destroys implementation type definition but keeps the accessor functions to handle previously defined relations using this implementation."
  (block destroy-implementation
(cond (*parameter-checking*
       (if (not (active-database implementation-name))
   (return-from destroy-implementation nil))
       (if (not (setf implementation-name (validate-sym implementation-name t)))
   (return-from destroy-implementation nil)))
      (t
       (setf implementation-name (string implementation-name))))
(if (not (member implementation-name
 (mapcar (function (lambda (dom) (car dom)))
 (qtrieve 'system-implementation *system-implementation-attributes*
  '(implementation-name) *system-implementation-key* t))
 :test 'string-equal))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The implementation ~s does not exist."
  implementation-name))
      (return-from destroy-implementation nil)))
(if (not (equal user-id
(caar (qtrieve 'system-implementation *system-implementation-attributes*
   '("OWNER-ID") *system-implementation-key*
   `(string-equal implementation-name ,implementation-name)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - The owner of the implementation ~s is not the same as the current user-id ~S."
  implementation-name user-id))
      (return-from destroy-implementation nil)))
(setf temp-status *provide-status-messages*
      *provide-status-messages* nil)
(delete-tuples 'system-implementation 'where `(string-equal implementation-name ',implementation-name))
(setf *provide-status-messages* temp-status)
(if *provide-status-messages*
    (format *standard-output* "~%The ~s implementation has been removed from the ~s database"
    implementation-name *active-db*))
(return-from destroy-implementation implementation-name)))

(defun destroy-storage-structure (storage-structure-name &aux temp-status)
  "Destroys storage structure definition but keeps the accessor functions to handle previously defined relations using this structure."
  (block destroy-storage-structure
(cond (*parameter-checking*
       (if (not (active-database storage-structure-name))
   (return-from destroy-storage-structure nil))
       (if (not (setf storage-structure-name (validate-sym storage-structure-name t)))
   (return-from destroy-storage-structure nil)))
      (t
       (setf storage-structure-name (string storage-structure-name))))
(if (not (member storage-structure-name
 (mapcar (function (lambda (dom)
     (car dom)))
 (qtrieve 'system-storage-structure *system-storage-structure-attributes*
  '(storage-structure-name) *system-storage-structure-key* t))
 :test 'string-equal))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The storage-structure ~s does not exist."
  storage-structure-name))
      (return-from destroy-storage-structure nil)))
(if (not (equal user-id
(caar (qtrieve 'system-storage-structure *system-storage-structure-attributes*
   '("OWNER-ID") *system-storage-structure-key*
   `(string-equal storage-structure-name ,storage-structure-name)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - The owner of the storage structure ~s is not the same as the current user-id ~S."
  storage-structure-name user-id))
      (return-from destroy-storage-structure nil)))
(setf temp-status *provide-status-messages*
      *provide-status-messages* nil)
(delete-tuples 'system-storage-structure
       'where `(string-equal storage-structure-name ',storage-structure-name))
(setf *provide-status-messages* temp-status)
(if *provide-status-messages*
    (format *standard-output* "~%The ~s storage-structure has been removed from the ~s database"
    storage-structure-name *active-db*))
(return-from destroy-storage-structure storage-structure-name)))

(defun destroy-view (view-name &aux temp-status)
  "Destroys the view from memory."
  (block destroy-view
(cond (*parameter-checking*
       (if (not (active-database view-name))
   (return-from destroy-view nil))
       (if (not (setf view-name (validate-sym view-name t)))
   (return-from destroy-view nil))))
(if (not (member view-name (mapcar (function (lambda (dom)
       (car dom)))
   (qtrieve 'system-view *system-view-attributes* '(view-name)
    *system-view-key* t)) :test 'string-equal))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The view ~s does not exist." view-name))
      (return-from destroy-view nil)))
(if (not (caar (qtrieve 'system-view *system-view-attributes* '("OWNER-ID") *system-view-key*
`(and (string-equal view-name ,view-name) (string-equal owner-id ,user-id)))))
    (progn
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - The owner of the view ~s is not the same as the current user-id ~S."
  view-name user-id))
      (return-from destroy-view nil)))
(setf temp-status *provide-status-messages*
      *provide-status-messages* nil)
(delete-tuples 'system-view 'where `(string-equal view-name ',view-name))
(setf *provide-status-messages* temp-status)
(if *provide-status-messages*
    (format *standard-output* "~%The ~s view has been removed from the ~s database"
    view-name *active-db*))
(return-from destroy-view view-name)))


(deff envstat 'environment-status)

(defun environment-status (&rest ignore &aux output-to-window)
  (setf output-to-window (car (errset (send  *output-window* ':exposed-p) nil)))
  (setf *environment-name* (read-from-string (string-upcase *environment-name*)))
  (cond (output-to-window
 (send *output-window* ':append-item (format nil ""))
 (send *output-window* ':append-item (format nil "Environment name --> ~s" *environment-name*))
 (send *output-window* ':append-item (format nil "Save directory --> ~s" *save-directory*))
 (send *output-window* ':append-item (format nil ""))
 (send *output-window* ':append-item
       (format nil "Provide warning messages --> ~s" *provide-warning-messages*))
 (send *output-window* ':append-item
       (format nil "Provide status messages --> ~s" *provide-status-messages*))
 (send *output-window* ':append-item
       (format nil "Provide error messages --> ~s" *provide-error-messages*))
 (send *output-window* ':append-item
       (format nil "Validity checking --> ~s" *validity-checking*))
 (send *output-window* ':append-item
       (format nil "Auto save --> ~s" *auto-save*))
 (send *output-window* ':append-item
       (format nil "Parameter-checking --> ~s" *parameter-checking*))
 (send *output-window* ':append-item (format nil ""))
 (send *output-window* ':append-item
       (format nil "Relation implementation --> ~s" *relation-implementation*))
 (send *output-window* ':append-item
       (format nil "System relation implementation --> ~s" *system-relation-base-implementation*))
 (send *output-window* ':append-item
       (format nil "System relation storage structure --> ~s" *system-relation-storage-structure*))
 (send *output-window* ':append-item (format nil "")))
(t
 (format *standard-output* "~%Environment name --> ~s" *environment-name*)
 (format *standard-output* "~%Save directory --> ~s" *save-directory*)
 (format *standard-output* "~%~%Provide warning messages --> ~s" *provide-warning-messages*)
 (format *standard-output* "~%Provide status messages --> ~s" *provide-status-messages*)
 (format *standard-output* "~%Provide error messages --> ~s" *provide-error-messages*)
 (format *standard-output* "~%Validity checking --> ~s" *validity-checking*)
 (format *standard-output* "~%Auto save --> ~s" *auto-save*)
 (format *standard-output* "~%Parameter-checking --> ~s" *parameter-checking*)
 (format *standard-output* "~%~%Relation implementation --> ~s" *relation-implementation*)
 (format *standard-output* "~%System relation implementation --> ~s"
 *system-relation-base-implementation*)
 (format *standard-output* "~%System relation storage structure --> ~s"
 *system-relation-storage-structure*)
 (format *standard-output* "~%")))
  *environment-name*)

(defun modify-domain (domain-name &rest keyword-list
      &key &optional format default doc &allow-other-keys
      &aux attribute-list default-value doc-value domain format-value value-list)
  "Modify the default format, value, and documentation of a domain.

   DOMAIN-NAME - Name of the domain to be modified.
   FORMAT      - New format, i.e the print width, for this domain.
   DEFAULT     - New default value for this domain.
   DOC         - New description of this domain."
  format default doc
  (block modify-domain
  (if (not (active-database))
      (return-from modify-domain nil))
  (if (null (setf domain-name (validate-sym domain-name t)))
      (return-from modify-domain nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf domain (car (qtrieve 'system-domain *system-domain-attributes* '("DOMAIN-NAME") *system-domain-key*
     (list 'string-equal 'domain-name domain-name))))
  (cond ((null domain)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is not a domain which is defined in the current database"
     domain-name))
 (return-from modify-domain nil)))
  (setf keyword-list (get-keyword-value-prereq '(format def doc) keyword-list)
attribute-list nil
value-list nil
*doc* "RTMS-NO-VALUE")
  (cond-every ((setf format-value (car (get-keyword-value '(format) keyword-list)))
       (cond ((numberp format-value)
      (cond ((validate-format format-value)
     (setf attribute-list (cons 'default-print-width attribute-list)
   value-list (cons format-value value-list)))))
     ((numberp (car format-value))
      (cond ((validate-format (car format-value))
     (setf attribute-list (cons 'default-print-width attribute-list)
   value-list (cons (car format-value) value-list)))))
     (t
      (if *provide-warning-messages*
  (format *standard-output*
  "~%WARNING - The value for the FORMAT keyword, ~s is not a positive numeric value"
  format-value)))))
      ((setf default-value (car (get-keyword-value '(def) keyword-list)))
       (cond (*validity-checking*
      (cond ((funcall (find-symbol (car domain) *pkg-string*) default-value)
     (setf attribute-list (cons 'default-value attribute-list)
   value-list (cons (list 'quote default-value) value-list)))
    (*provide-warning-messages*
     (format *standard-output* "~%WARNING - ~s is not a value of the domain ~s"
     default-value domain)
     (format *standard-output* "~%         It may not be used as the default value"))))
     (t
      (setf attribute-list (cons 'default-value attribute-list)
    value-list (cons (list 'quote default-value) value-list)))))
      ((not (string-equal "RTMS-NO-VALUE"
  (setf doc-value (string (car (get-keyword-value '(doc) keyword-list))))))
       (setf attribute-list (cons 'doc attribute-list)
     value-list (cons doc-value value-list))))
  ;;
  ;; 1 The value and attribute list have been formed, modify the system-domain function*
  ;;
  (setf *doc* nil)
  (delete-or-modify 'system-domain t (list 'string-equal 'domain-name domain-name)
    (convert-attributes attribute-list) value-list)
  (return-from modify-domain domain-name)))

(defun validate-format (format-value)
  (cond ((<= format-value 0)
 (if *provide-warning-messages*
     (format *standard-output*
     "~%WARNING - The FORMAT value specified, ~s, is not a positive numeric value"
     format-value))
 nil)
(t
 t)))
erator val1 val2)
  (setf comparison-operator 'equal)
  ;1;*
  ;1;  It is assumed that the key lists are of the same length, this should*
  ;1; always be the case.*
  ;1;*
  (do ((key1 key-list-1 (cdr key1))
       (key2 key-list-2 (cdr key2))
       (domain key-domaLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540661. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DEFINE-DESTROY" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360471. :AUTHOR "REL3" :LENGTH-IN-BYTES 9980. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pp2\COMPILE-DATA\SW-MFG,GODZILLA(FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8DEFINE-DESTROY\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPÁDEFINE-DOMAINOPÀDEFDOMBP<x,<@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\	DOMAIN-NAME&RESTKEYWORD-LIST&KEYj&OPTIONALDEFAULTDOCUMENTATIONFORMATj&ALLOW-OTHER-KEYSB:\BcBfBgBhpBUDEFÀWIDTH1DOCSTATUS?PREDB:B:B:BcB:EXISTING-DEFB:B:\)MACROS-EXPANDED\	pBUlCONDITION-BIND-IFpBUCONDITION-BINDpBUCATCH-CONTINUATION-IFpBUlCATCH-CONTINUATIONpBUERRSETPROGpZLC,DO-NAMEDpBUINHIBIT-STYLE-WARNINGSSETFDOCUMENTATIONDefine new domain. Corresponding predicate is expected to be defined prior to this operation.

   DOMAIN-NAME     - Name of the domain to be defined.
   DOCUMENTATION   - Describes the new domain.
   FORMAT          - Print width for attributes belonging to this domain. plEH*CONDITION-HANDLERS*pBU,USER-IDC*PROVIDE-WARNING-MESSAGES*у*VALIDITY-CHECKING*у*DEFAULT-ANYP-WIDTH*C*PROVIDE-STATUS-MESSAGES*у*SYSTEM-DOMAIN-KEY*C*SYSTEM-DOMAIN-ATTRIBUTES**PROVIDE-ERROR-MESSAGES*C*PKG-NAME*у*PARAMETER-CHECKING*\)DEFAULTBFORMATpB]STORE-KEYARGSACTIVE-DATABASE҃VALIDATE-SYMpBUSTRING-APPEND*READ-FROM-STRINGpBUlFDEFINEDPTERPRIERROR - The predicate WRITE-STRINGPRIN1l has not been defined yet.ÁSYSTEM-DOMAIN\BaQTRIEVEҪSTRING-EQUALpB]MEMBER-TESTҬERROR - The domain l already exists and may not be redefined.Define domain \DEFFORMATDOCGET-KEYWORD-VALUE-PREREQ\BhCGET-KEYWORD-VALUEVALIDATE-FORMAT\Blp,G8081FERRORpB]ERRSET-HANDLERLISTҬWARNING - The default value  does not satisfy the domain l          Other values will be tested for validity\ÁDEFAULT-VALUEpBG8098F6lERROR - None of the existing default values are valid for e.jWRITE-CHAR\BnÀTUPLESÀINSERTDefinition of domain  completed.@@QPAQRQRPQH
PHQPRQIPPP
PKJJQKSBCJKKIQP
 PQ!PR@QLSLLS5LQ@	"PQ#P@Q$@%P@Q&BEE5EQESE'PE(P@Q&BD))P*PT+P,P)PJCIPJCMDQH-J!BJ!B\.PDQ/PQ0PDD4PP1P
PK KSN2P3PT+P,P2PJCOPJCPNSH-J!BJ!B\NSDKD
4PQ5P6R7P@Q&BFF	PG	P8PQPEQDQFQ--9GQ	:PQ;POBPCDEFINE-ENVIRONMENTOÀDEFENVBMuM@F$B:BW]FB:B:B:BZFB_B\ENVIRONMENTBbBcBdBeCAUTO-SAVEjDIRECTORYÀERRORSCPARAMETER-CHECKINGRELATION-IMPLEMENTATIONCRELATION-STORAGE-STRUCTUREÀSTATUSÂSYSTEM-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTUREVALIDITYWARNINGSBiB:\BcBBBBBBBBBBBÁALL-KEY-VALUESÁKEYWORD-LIST-2CLEGAL-IMPCLEGAL-STOSYS-IMPSYS-STOKEYWORDS*KEYWORD\Bs\BBB7Global variables defining an environment can be set using this function.

   ENVIRONMENT  - Name of the environment.
   AUTO-SAVE    - If T, RTMS saves the database whenever a relation is modified.
   DIRECTORY    - Name of the default directory in which the database is to be saved.
   ERRORS       - If T, error messages are generated.
   PARAMETER-CHECKING - If T, extensive parameter validity checking is done.
   RELATION-IMPLEMENTATION - The default implementation type for the user relations.
   RELATION-STORAGE-STRUCTURE -The default storage structure type for the user relations.
   STATUS       - If T, status messages are generated.
   SYSTEM-IMPLEMENTATION - If there is no active database, this value will be used as the implementation
                           type for implementing system-relations.
   SYSTEM-STORAGE-STRUCTURE - If there is no active database, this value will be used as the storage structure
                              for implementing system-relations.
   VALIDITY     - If T, extensive validity checking is done for user-supplied data.
   WARNINGS     - If T, warning messages are generated. Bу*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*BBÃ*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*C*REL-STO*у*SYSTEM-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*C*RELATION-IMPLEMENTATION*C*REL-IMP*у*ACTIVE-DB*BB*SAVE-DIRECTORY*у*AUTO-SAVE*C*ENVIRONMENT-NAME*\iAUTO-SAVEiDIRECTORYERRORSiPARAMETER-CHECKING)RELATION-IMPLEMENTATIONiRELATION-STORAGE-STRUCTURESTATUSSYSTEM-IMPLEMENTATION)SYSTEM-STORAGE-STRUCTURE)VALIDITY)WARNINGSBB҃DE-NEST-KEYWORD-LIST\AUTODIRERRPARA,REL-IMP,REL-STOSTAT,SYS-IMP,SYS-STOVALWARNBSTRING-UPCASEBҬAUTOpB],SEARCH*\AUTODIRÁGET-DIRECTORYҬERR\ERRPARA\PARA,REL-IMPpB]STRING-EQUAL*\REL-IMPl-BpB]lPOSITION*SUBSEQBB\IMPLEMENTATION-NAMEBBpB]MEMBER-EQUALB,ERROR - BB, is an unrecognized implementation type,REL-STO\REL-STOB\ÂSTORAGE-STRUCTURE-NAME is an unrecognized storage-structureSTAT\STAT,SYS-IMP,WARNING - Can not change system relation implementation          while there is an active database\B,SYS-STOlWARNING - Can not change system relation storage structure\BVAL\VALWARN\WARNEnvironment , defined@@QPAQRQ@Q@P@QM@MQRRS@]@RPMQL@QSPSS PMQB!PSSMQ"#PSS$PMQB%PSS&PMQBSS'P()PMQBPPQP*PP+P,-.SS'P(N/PP0PP1N)PMQBPPQ2NQ345P6PQ78P6SS9P(:PMQBQPJ*PP-*PQQ.ySS9P(O;P
P<P	P1O:PMQBQQQ2OQ3^45P6QQ7=P6V>PSS?PMQBKSS@P(	4AP64BP6<SS@P(
CPMQBP.SSDP(4EPSSDP(
FPMQBQGPSSHPMQB
IPSSJPMQBS	4KP6P7LP6OQBDEFINE-VIEWORDEFVIEWBR$6`$FZ$B:BW]FB:B:B:BZFB_BR\VIEWNAMEVIEW-DEFBbBcBdBeBgBiB:\BcBgBnTEMP-STATUSB:B:B:\Bs\BBBBBDefine views on the relations.

   VIEW-NAME - Name of the view.
   VIEW-DEF  - Definition of the view.
   DOCUMENTATION - Describes the view.B
BC*SYSTEM-VIEW-KEY**SYSTEM-VIEW-ATTRIBUTES*BB\BBBBCRELATIONPBlERROR - A relation with the name BB, already exists in the l database.SYSTEM-VIEW\CVIEW-NAMEBBBlERROR - The view l database\BnBBBBBBҬThe  view has been defined in the @@Q	PA
RQRQPQPPPRQDPPPPFEEQFSBCEFFDQPPQPPPRPCP@Q@P@QBBPPQQPBQ  !CQ"PQ#PPPOrBRMODIFY-VIEW,X܆`,dF$B:BW]FB:B:B:BZFB_Bs\BlBbBcBdBeVIEW-DEFINITIONpBUlVIEW-DOCUMENTATIONBiB:\	BcB|B~ÀTEMP1ÀTEMP2B:B:B:Bc\Bs\pB]lXR-BQ-LISTBBBBBModify a view definition or its documentation.

   VIEW-NAME       - Name of the view.
   VIEW-DEFINITION - New definition of the view.
   VIEW-DOCUMENTATION - New description of the view.B
BBcBdB\)VIEW-DEFINITIONiVIEW-DOCUMENTATIONBBBBj\BlBBBBlERROR - The view BB, does not exist.\,OWNER-IDANDBlBOWNER-IDERROR - The owner of the view , is not the same as the current user-id BB\B]VIEW-DOCBnB\B]B\B\BnÀWHEREB8CATTRIBUTESB|B~VALUESÀMODIFY@@QPA	
Q
RQRQEPPPPGFFQGSBCFGGEQP
PQPRPPPPPPPQPPPPQPPPR@QHSHHS5HQ@P@Q @!P@Q"BC#P@Q"B$P@Q"BDCDRP%PPP&PQ'PCD(P)PC(PD)P*PCD&PCQ&PDQC&PCQD&PDQJ+OBsDESTROY-DATABASEOCDESTROY-DBB)G`)XFp$B:BW]FB:B:B:BZFB_B\DATABASEBbBcBdBeDISKBiB:\BcBMEMORY-ONLYPATH*PATHNAMEBc\Bs\BBINTERNAL-FEF-OFFSETS\F#BlDelete the specified database from memory and all the corresponding files from
   disk if the keyword DISK is T.

   DATABASE - Name of the database to be destroyed.
   DISK     - If T, all the relevant files will be deleted.BBB\DISKBBBҬERROR - Only the active database may currently be destroyedBl        and there is currently no active databaseB,,        The active database is B\BBBThe database  will be deleted from memory,Destroying the l databaseCGET-SAVE-DIRECTORYB.lispjPROBE-FILEl#*DELETE-FILEҬ.xld.xfasl.qfaslERROR - The l database does not exist in the directory B#\)INTERNALBSYSTEM-RELATIONMAPT҃RECOVER-ALLҬThe  database has been destroyed@@QPAQR		
P	PRPQ	
P	PPR@QESEES5EQ@P@Q@P@Q?BB		PQP	PQPB2QDPCCQPDQPCDQPCDQPC
	 PQ!P@Q"RB#P$P%&	'PQ(POBB#Z@XF7$B:BW]FB:B:B:BZFB_B\ÀTUPLEB:\TEMPBBDIRB:B:\Bs\pBUlCOND-EVERYBBу*SYSTEM-RELATION-ATTRIBUTES*B\RELATION-NAMEPROJECT-LISTB\SAVE-DIRECTORYl-l.BҬXLDBl#*BXFASLQFASLLISPQPPB@QP	PBCP
P@QPAPBBQPEDAQPBBQPEDAQPBBQPEDAQPBBQPEDEOBB	F	F$B:BW]FB:B:B:BZFB_BB:B:B:B:Â*SYSTEM-RELATION-KEY*BB\SAVE-DIRECTORY\BÁRELATION-NAME,SYSTEM-RELATIONBPPPPPBOBDESTROY-RELATIONODESTROY-RELB@D`@tF$B:BW]FB:B:B:BZFB_B\RELATIONBbBcBdBeBBiB:\BcBINDICESQTRIEVE-VARBBBBcB:B:B:ATTRCINDEX-NAME\Bs\BFOURTHBBBBBBDeletes the specified relation from the active database.
   Deletes all the files on disk if keyword DISK is t.

   RELATION - Name of the relation to be destroyed.
   DISK     - If T, the relevant files will be deleted.C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*C*SYSTEM-RELATIONS*BBBBB\BBBBB\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTURESAVE-DIRECTORYBBBBBBERROR - The relation BBB, is not defined in the database BB\BBBThe relation  will be deleted from memory,Destroying the l relationDELETE-OR-MODIFY,SYSTEM-RELATION\CARDINALITYlMODIFIEDP\j-CARDINALITYFSYSTEM-ATTRIBUTEBSTRINGÁATTRIBUTE-NAME,SYSTEM-ATTRIBUTEB&B'B҃SYSTEM-INDEX\lINDEX-NAMEENTRY-POINTPUTP\BBSYSTEM-INDEXl-l.BҬXLDBl#*BXFASLQFASLLISP@@QPARQR@QGSGGS5GQ@P
PP	PPPQBCPQPPPRP@Q@P@Q ?BF	!PQ"P	#PQ$PPPPQ%PPP&P'P(P%HCSJIIQJSK)P*PPPQ+P,PKQ%CIJJPPP-P'P.P/PCSC%QPP0*1PP2PPPPQBBQIISLLS3P4I1PPPQ%P5P'P.P/PBQC%Q3P4F:CQBP6PQ7P8DJIDQ9P8E:EQ;P8<IJDQ=P8E:EQ;P8<IJDQ>P8E:EQ;P8<IJDQ?P8E:EQ;P8<IJ݀O;BÁDESTROY-DOMAIN$5@$PFY$B:BW]FB:B:B:BZFB_B<\BaB:\BoB:B:B:\Bs\BBBBBB,Destroys the domain definition but keeps the domain predicate to handle previously defined data.Á*DOMAIN-LIST*BB
BBBBBBB*B\BaBBBBҬERROR - The domain BB, does not exist.\,OWNER-IDBaB,ERROR - The owner of the domain , is not the same as the current user-id BBBB8ÁDELETE-TUPLESpB],REMOVE*Destruction of domain  completed.	
Q
RQRQQAPPPPCBBQCSBCBCCAQP
PQPRPPPPPPPQBrPQPPPRP@PPPPPQ @QQPP!"PQ#POVB<ÂDESTROY-IMPLEMENTATION$4@$PFX$B:BW]FB:B:B:BZFB_BW\B4B:\B_B:B:B:\Bs\BBBBBBlDestroys implementation type definition but keeps the accessor functions to handle previously defined relations using this implementation.BBB
BBBBBBB*B\B4BBBBҬERROR - The implementation BB, does not exist.\,OWNER-IDB4B,ERROR - The owner of the implementation , is not the same as the current user-id BBBB8BQҬThe l implementation has been removed from the l database	
Q
RQRQQAPPPPCBBQCSBCBCCAQP
PQPRPPPPPPPQBrPQPPPRP@PPPPPQ @Q!PQ"PP#POnBWCDESTROY-STORAGE-STRUCTURE$4@$PFX$B:BW]FB:B:B:BZFB_Bo\B=B:\B_B:B:B:\Bs\BBBBBBDestroys storage structure definition but keeps the accessor functions to handle previously defined relations using this structure.BBB
BBBBBBB*B\B=BBBBERROR - The storage-structure BB, does not exist.\,OWNER-IDB=BҬERROR - The owner of the storage structure , is not the same as the current user-id BBBB8BQҬThe  storage-structure has been removed from the l database	
Q
RQRQQAPPPPCBBQCSBCBCCAQP
PQPRPPPPPPPQBrPQPPPRP@PPPPPQ @Q!PQ"PP#POBoDESTROY-VIEW%4
@%PFY$B:BW]FB:B:B:BZFB_B\BlB:\B_B:B:B:\Bs\BBBBBBDestroys the view from memory.BBB
BBcBdBBBBj\BlBBBBlERROR - The view BB, does not exist.\,OWNER-IDBBlBBERROR - The owner of the view , is not the same as the current user-id BBBB8BQҬThe , view has been removed from the l database	
Q
RQRQAPPPPCBBQCSBCBCCAQP
PQPRPPPPPPPQPPPPQPPPRP@PPPP PQ!@Q"PQ#PP$POBCENVIRONMENT-STATUSOENVSTATB4h`4F$B:BW]FB:B:B:BZFB_B\BbIGNOREB:\BOUTPUT-TO-WINDOWB:B:\Bs\pBUSENDBvBxBzB|B~BBBBBBBBBBBBB*OUTPUT-WINDOW*pBG8751FBBiEXPOSED-PBBBҩAPPEND-ITEM,Bh,Environment name --> ~sSave directory --> ~s,Provide warning messages --> ~sProvide status messages --> ~sProvide error messages --> ~s,Validity checking --> ~s,Auto save --> ~slParameter-checking --> ~sRelation implementation --> ~sSystem relation implementation --> ~s,System relation storage structure --> ~sBEnvironment name --> BBҬSave directory --> Provide warning messages --> Provide status messages --> Provide error messages --> Validity checking --> Auto save --> ,Parameter-checking --> Relation implementation --> System relation implementation --> System relation storage structure --> PPTPPPJCBPJCCPJ!BJ!B\BAPAuPCPPCPCPPPCPCPPPCPCPPCPCPPPCPCPPPCPCPP
PCPCP P	PCPCP!PPCPCP"PPCPCPPCPCP#PPCPCP$PPCPCP%PPCPCPPC&'P(P)&*P(P)&&+P(P)&,P(P)&-P(
P)&.P(	P)&/P(P)&0P(P)&&1P(P)&2P(P)&3P(P)&OBÁMODIFY-DOMAIN/W݆`/xF$B:BW]FB:B:B:BZFB_B\	BaBbBcBdBeBhBfBnBiB:\BcBhBfBnÁATTRIBUTE-LISTBCDOC-VALUEÀDOMAINFORMAT-VALUECVALUE-LISTBcB:B:B:\Bs\BBBBModify the default format, value, and documentation of a domain.

   DOMAIN-NAME - Name of the domain to be modified.
   FORMAT      - New format, i.e the print width, for this domain.
   DEFAULT     - New default value for this domain.
   DOC         - New description of this domain.*PKG-STRING*BBÀ*DOC*BBB\BBDOCBBBB\DOMAIN-NAMEBBaBBB,ERROR - BBl is not a domain which is defined in the current database\BhBlBnBRTMS-NO-VALUE\BhBB҃DEFAULT-PRINT-WIDTHWARNING - The value for the FORMAT keyword, , is not a positive numeric value\BlFIND-SYMBOLlWARNING -  is not a value of the domain ,         It may not be used as the default valueBB8\BnB*B,BnCCONVERT-ATTRIBUTESB @@Q
PARQR@QJSJJS5JQ@P	PPPPPQBG
PQPRP@Q@DIPP@QBH)H1HQPD]DHQI]ILHSu
HSPD]DHSL	 PHQ!PLLK"P@QBE#GSP#MEQM$PEQ%PGQ&PL	'PD]D(PEQI]ILKP)P@QB*F+,PD]DFQI]ILKPPPQDQ-IQ.OBB	F	@F$B:BW]FB:B:B:BZFB_B\BB:B:B:BBWARNING - The FORMAT value specified, BBl, is not a positive numeric value=
PQPRSOB1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\BaM*\Bx\B9\B.ً\B[\B(̢\B*j\B=#\B~-i\B|~z\Bz<p\Bx`sN\Bv|se))
      (return-from destroy-relation nil))
  (cond ((null (setf relation (validate-sym relation t)))
 (return-from destroy-relation nil)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes*
  '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "SAVE-DIRECTORY")
  *system-relation-key*
  (list 'string-equal 'relationLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540665. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DEFINE-REL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846005. :AUTHOR "REL3" :LENGTH-IN-BYTES 19953. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
1;;; DEFINE-REL
;;;
;;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp
;;; Reference
;;;     firstn
;;;     errset
;;;     deff
;;;
;;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not
;;; effect the functionality of RTMS.
;;;     defrel-flavor
;;;*
(deff defrel 'define-relation)

(defun define-relation (relation-name attribute-descriptor &rest keyword-list
&key &optional directory documentation format implementation-type key storage-structure
&allow-other-keys
&aux default doc domain key-format implementation-type1 (domain-list nil) error-p
(attribute-list nil) (system-attribute-list nil) system-relation-list
storage-structure1 attribute temp-format tuple-format-list)
  "Define relations in the active database.

   RELATION-NAME - Name of the relation to be defined.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   DIRECTORY     - Name of the directory in which this relation is to be saved.
   DOCUMENTATION - Description of this relation.
   FORMAT        - List of print-width values correponding to the attribute-list.
   IMPLEMENTATION-TYPE - Name of the implementation for this relation.
   KEY           - List of attributes comprising the key for this relation.
   STORAGE-STRUCTURE   - Name of the storage structure to be used for this relation."
  directory documentation format implementation-type key storage-structure
  (block define-relation
  (cond ((and *parameter-checking* (not (member relation-name *system-relations* :test 'string-equal)))
 (if (not (active-database relation-name))
     (return-from define-relation nil))
 (if (not (setf relation-name (validate-sym relation-name t)))
     (return-from define-relation nil))
 (cond ((null attribute-descriptor)
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - No attribute descriptor provided."))
(return-from define-relation nil)))
 (if (not (listp attribute-descriptor))
     (setf attribute-descriptor (list attribute-descriptor))))
(t
 (setf relation-name (string-upcase relation-name))))
  (setf keyword-list (de-nest-keyword-list keyword-list))
  (if *provide-status-messages*
      (format *standard-output* "~%Define relation ~s in database ~s"
      (read-from-string relation-name) (read-from-string *active-db*)))
  (if *parameter-checking*
      (setf keyword-list (get-keyword-value-prereq '(dir dom def cardinality doc imp owner-id tup mod key sto
     format) keyword-list)))
  ;;
  ;;1  Determine if the implementation and storage structure specified for the current user relation are valid.*
  ;;
  (multiple-value-setq (implementation-type1 storage-structure1)
       (obtain-imp-&-sto relation-name keyword-list))
  (if (or (not implementation-type1)(not storage-structure1))
      (return-from define-relation nil))
  ;1;*
  ;1;  Does a relation owned by this user already exist? If it does, a new one may not be defined until the current one is destroyed. In the*
  ;1; future, location transparency issues need to be introduced here.*
  ;1;*
  (if (relation-exist-p relation-name)
      (return-from define-relation nil))
  ;;
  ;;1  Define the tuples for the system-attribute relation. If an attribute descriptor is not specified, define a relation with one attribute.*
  ;;
  (setf system-attribute-list nil
tuple-format-list nil)
  (if (not (member relation-name *system-relations* :test 'string-equal))
      (setf *domain-list* (mapcar (function (lambda (dom)
      (car dom)))
  (qtrieve 'system-domain *system-domain-attributes* '("DOMAIN-NAME")
   *system-domain-key* t))))
  (if (null
(do ((att-des attribute-descriptor (if (and (listp (cadr att-des))
    (not (string-equal "QUOTE" (first (cadr att-des)))))
       (cddr att-des)
       (cdr att-des))))
    ((null att-des) t)
  ;;
  ;;1  Determine if the attribute has already been defined for this relation *
  ;;
  (cond ((not *parameter-checking*)
 (setf attribute (string-upcase (car att-des))))
((null (setf attribute (validate-sym (car att-des) t)))
 (return-from define-relation nil))
((member (setf attribute (string-upcase attribute)) attribute-list :test 'string-equal)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The attribute ~s is defined more than once"
     (read-from-string attribute)))
 (return-from define-relation nil)))
  (setf attribute-list (cons attribute attribute-list))
  ;;
  ;;1  If the second part of the attribute descriptor is provided, parse it and set the  appropriate values.*
  ;;
  (cond ((and (listp (cadr att-des)) (not (string-equal "QUOTE" (first (cadr att-des)))))
 (multiple-value-setq (domain domain-list)
      (obtain-domain relation-name (cadr att-des) domain-list))
 (if (null domain)
     (return-from define-relation nil))
 (if (listp (setf temp-format (or (car (get-keyword-value '(format) (cadr att-des)))
  (default-tuple-format (list domain)))))
     (setf temp-format (car temp-format)))
 (setf tuple-format-list (cons temp-format tuple-format-list))
 (multiple-value-setq (default error-p)
      (obtain-domain-default-value domain (cadr att-des)))
 (setf doc (car (get-keyword-value '(doc) (cadr att-des)))))
(t
 (setf domain-list (cons "ANYP" domain-list)
       domain "ANYP"
       tuple-format-list (cons (car (default-tuple-format (list domain))) tuple-format-list)
       default "?"
       doc nil)))
  (setf system-attribute-list (cons (list relation-name (string attribute) domain default doc user-id)
    system-attribute-list))))
      (return-from define-relation nil))
  ;;1 *
  ;;1 Create the system-relation tuple which defines the new relation. This will temporarly be stored in a property list and will be inserted *
  ;1; later as described below. The manner of the implementation of the tuple depends on the method in which the system-relation relation is *
  ;1; implemented. The tuple created will be of the appropriate type. The attributes are the same regardless of implementation and can be *
  ;1; done for all types and then passed to the correct function.*
  ;;
  ;;1If any keywords and their values are provided (ex. in defrel call in RESTORE from QFASL) we should not use default. Specifically, we *
  ;1; should not set cardinality to 0.*
  ;;
  (setf attribute-list (nreverse attribute-list)
domain-list (nreverse domain-list)
system-attribute-list (nreverse system-attribute-list))
  (cond ((null (errset (setf key (funcall (find-symbol (concatenate 'string "DEFREL-" storage-structure1)
       *pkg-string*)
  relation-name attribute-list keyword-list))
       nil))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is an undefined storage structure" storage-structure1))
 (return-from define-relation nil))
((null key)
 (putp 'system-attribute nil 'commit-tuples)
 (return-from define-relation nil)))
  (setf key-format (car (get-keyword-value '(format) keyword-list)))
  (if (and key-format (not (listp key-format)))
      (setf key-format (list key-format)))
  (setf tuple-format-list (nreverse tuple-format-list))
  (if key-format
      (if (< (length key-format)(length tuple-format-list))
  (setf tuple-format-list (append key-format (nthcdr (length key-format) tuple-format-list)))
(setf tuple-format-list (firstn (length tuple-format-list) key-format))))
  (cond ((and (not (member relation-name *system-relations* :test 'string-equal)) *parameter-checking*)
 (setf tuple-format-list (mapcar #'(lambda (value)
     (cond ((or (not (numberp value)) (<= value 0))
    (if *provide-warning-messages*
(format *standard-output*
"~%WARNING - ~s is not a valid format value."
value))
    *default-anyp-width*)
   (t
    value)))
 tuple-format-list))))
  (setf system-relation-list  (list (concatenate 'string relation-name) user-id
    (or (car (get-keyword-value '(mod) keyword-list))t) ;1modifiedp*
    (or (car (get-keyword-value '(cardinality) keyword-list)) 0) ;1 cardinality*
    tuple-format-list attribute-list domain-list key
    (get-directory keyword-list) (car (get-keyword-value '(doc) keyword-list ))
    (string-upcase implementation-type1) (string-upcase storage-structure1)
    nil))
  ;;
  ;;1  Call the implementation dependent function which will define the structure which will be used to implement the new relation.*
  ;;
  (cond ((null (errset (funcall (find-symbol (concatenate 'string "DEFREL-" implementation-type1)
     *pkg-string*)
relation-name attribute-list keyword-list) nil))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is an undefined implementation type" implementation-type1))
 (return-from define-relation nil)))
  ;;
  ;;1  Determine if the system-relation tuple may be inserted into the system relations thus completing the relation definition. If it is one of *
  ;1; the basic system relations it may not be commited until all have been defined.*
  ;;
  (putp 'system-relation (append (getp 'system-relation 'commit-tuples) (list system-relation-list))
'commit-tuples)
  (putp 'system-attribute (append (getp 'system-attribute 'commit-tuples) system-attribute-list) 'commit-tuples)
  (if (not (member relation-name *system-relations* :test 'string-equal))
      (commit-system-relation))
   (return-from define-relation relation-name)))

(defun defrel-restore* (relation-name attributes &optional keyword-list
&aux  implementation-type storage-structure)
  (block defrel-restore*
  (if (not (active-database relation-name))
      (return-from defrel-restore* nil))
  (setf keyword-list (get-keyword-value-prereq '(dir dom def cardinality doc imp owner-id tup mod key sto)
       (car keyword-list)))
  (setf storage-structure (string-upcase (car (get-keyword-value '(sto) keyword-list))))
  ;;
  ;;1  Define the structure which will house the new relation where applicable. The implementation type must be obtained as the selection *
  ;1; criteria. If the implementation type is not specified in the keyword list, extract it from the system default.*
  ;;
  (setf implementation-type (string-upcase (car (get-keyword-value '(imp) keyword-list))))
  (funcall (find-symbol (concatenate 'string "DEFREL-" storage-structure) *pkg-string*) relation-name attributes
   keyword-list)
  ;1;*
  ;;1  Call the implementation dependent function which will define the structure which will be used to implement the new relation.*
  ;;
  (funcall (find-symbol (concatenate 'string "DEFREL-" implementation-type) *pkg-string*) relation-name
   attributes keyword-list)
   (return-from defrel-restore* relation-name)))

(defun defrel-flavor (relation-name attribute-list keyword-list
      &aux attr-val-list atom-attribute-list )
  keyword-list
  (setf relation-name (read-from-string (concatenate 'string *pkg-name* relation-name))
atom-attribute-list (unconvert-attributes attribute-list *pkg-name*))
  (eval `(defflavor ,relation-name ,atom-attribute-list ()
   :inittable-instance-variables
   :settable-instance-variables
   :gettable-instance-variables
   :special-instance-variables))
  ;;1Using CONDITION instead of fasd-form inorder to solve the problem of the values being evaluated when saved and restored, has a *
  ;1; problem. And that is the problem of :A1 versus plain A1 which was taken care of by the following modification to the attribute-list *
  ;1; before dumping.*
  (setf attr-val-list nil)
  (mapc (function (lambda (attr)
            (setf attr-val-list (append attr-val-list
(list (list 'quote (list 'quote (read-from-string
  (concatenate 'string ":"
       (string-upcase attr)))))
      `(list 'quote ,attr))))))
  atom-attribute-list)
  (setf attr-val-list (cons (list 'quote (list 'quote relation-name)) attr-val-list))
  (eval `(defmethod (,relation-name :fasd-form) ()
    (list 'make-instance ,@attr-val-list))))

(defun defrel-hash (relation-name attribute-list keyword-list &aux key)
  (cond ((setf key (defrel-validate-key attribute-list keyword-list))
 (putp relation-name (make-hash-table :test 'equal :size 1000) 'entry-point)))
  key)

(defun defrel-validate-key (attribute-list keyword-list &aux key)
  (block defrel-validate-key
(setf attribute-list (convert-attributes attribute-list))
(setf key (car (get-keyword-value '(key) keyword-list)))
(cond (*parameter-checking*
       (if (and key (not (listp key)))
   (setf key (list key)))
       (if (null (car key))
   (setf key nil))
       (setf key (mapcar #'(lambda (attr)
     (validate-sym attr t))
 key))
       (if (member nil key)
   (return-from defrel-validate-key nil))
       (cond (key
      (cond ((and key (not (listp key)))
     (setf key (list key))))
      (if (null (do ((key (convert-attributes key) (cdr key)))
    ((null key) t)
  (cond ((not (member (car key) attribute-list :test 'string-equal))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is given as a key attribute but it is not contained in the attribute list" (car key)))
 (return-from defrel-validate-key nil)))))
  (return-from defrel-validate-key nil))
      (return-from defrel-validate-key key))
     (t
      (setf key (list (car attribute-list)))
      (return-from defrel-validate-key key))))
      ((null key)
       (setf key (list (car attribute-list)))))
(return-from defrel-validate-key key)))

(defun defrel-heap (relation-name attribute-list keyword-list)
  (putp relation-name nil 'entry-point)
  (defrel-validate-key attribute-list keyword-list))

(defun defrel-avl (relation-name attribute-list keyword-list)
  (putp relation-name nil 'entry-point)
  (defrel-validate-key attribute-list keyword-list))

(defun defrel-list (relation-name attribute-list keyword-list &aux
      attr-val-list)
  attribute-list keyword-list attr-val-list relation-name)

;;1        IMPORTANT: Since DEFSTRUCT creates a function (accessor function) for each of the components of the structure, if two*
;;1  relations have same attributes and their implementation type is structure, then when restored there will be a warning message to notify*
;1; the fact that some functions are being redefined.*
(defun defrel-struct (relation-name attribute-list keyword-list)
   keyword-list
  ;;
  ;;1create a structure which will be used to implement the tuples in this relation*
  ;;
   (setf attribute-list
(mapcar (function (lambda (attr)
    (read-from-string (concatenate 'string *pkg-name* relation-name attr))))
attribute-list))
   (setf relation-name (read-from-string (concatenate 'string *pkg-name* relation-name)))
   (eval `(defstruct (,relation-name (:conc-name nil)
     (:constructor ,(read-from-string (concatenate 'string *pkg-name* "MAKE-"
 (string relation-name))))) ,@attribute-list)))

(defun obtain-imp-&-sto (relation-name keyword-list)
  (let (implementation-type storage-structure)
    (cond ((member relation-name *system-relations* :test 'string-equal)
   (setf storage-structure *system-relation-storage-structure*
 implementation-type *system-relation-base-implementation*))
  (t
   (cond ((null (setf implementation-type (car (get-keyword-value '(imp) keyword-list))))
  (setf implementation-type (validate-sym (subseq *relation-implementation* 0
  (search "-" *relation-implementation*)) t)))
 ((not (car (qtrieve 'system-implementation *system-implementation-attributes*
     '("IMPLEMENTATION-NAME") *system-implementation-key*
     `(string-equal implementation-name ,(string-upcase implementation-type)))))
  (if *provide-error-messages*
      (format *standard-output*  "~%ERROR - ~s is an undefined implementation type"
      implementation-type))
  (setf implementation-type nil))
 (implementation-type
  (setf implementation-type (string-upcase implementation-type))))
   (cond ((null (setf storage-structure (car (get-keyword-value '(sto) keyword-list))))
  (setf storage-structure (validate-sym (subseq *relation-implementation*
(+ (search "-" *relation-implementation*) 1))
t)))
 ((not (car (qtrieve 'system-storage-structure *system-storage-structure-attributes*
     '("STORAGE-STRUCTURE-NAME") *system-storage-structure-key*
     `(string-equal storage-structure-name
    ,(string-upcase storage-structure)))))
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - ~s is an undefined storage structure"
      storage-structure))
  (setf storage-structure nil))
 (storage-structure
  (setf storage-structure (string-upcase storage-structure))))))
    (values implementation-type storage-structure)))

(defun relation-exist-p (relation-name)
  (let (qtrieve-var)
    (cond ((not (member relation-name *system-relations* :test 'string-equal))
   (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes*
    '("OWNER-ID") *system-relation-key*
    `(string-equal relation-name ,relation-name))))
   (cond ((equal qtrieve-var user-id)
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The ~S relation already exists in database ~s."
      (read-from-string relation-name) (read-from-string *active-db*)))
  t)
 ;;
 ;;1  Should let the user define a new relation with the same name. This may cause problems*
 ;;1 in other places. Think about this before doing it.*
 ;;
 (qtrieve-var
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The ~S relation exists and is defined by ~S. "
      (read-from-string relation-name) qtrieve-var))
  t)
 ;;1See if there is a view by the same name.*
 ((caar (qtrieve 'system-view *system-view-attributes* '("OWNER-ID") *system-view-key*
 `(and (string-equal view-name ,relation-name)(string-equal owner-id
    ,user-id))))
  (if *provide-error-messages*
      (format *standard-output*
      "~%ERROR - There exists a view named ~S and defining a relation with the same name causes conflicts."
      (read-from-string relation-name)))
  t)
 (t
  nil))))))

(defun obtain-domain (relation-name keyword-list domain-list)
  (let (domain)
    (setf domain (car (get-keyword-value '(dom) keyword-list)))
    (cond ((null domain)
   (setf domain "ANYP"))
  ((null (setf domain (validate-sym domain t)))
   nil)
  ((not *parameter-checking*)
   (setf domain (string-upcase domain)))
  ((and (not (member relation-name *system-relations* :test 'string-equal))
(not (member (setf domain (string-upcase domain)) *domain-list* :test 'string-equal)))
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - ~s is an unrecognized domain" domain))
   (setf domain nil)))
    (setf domain-list (cons domain domain-list))
    (values domain domain-list)))

(defun obtain-domain-default-value (domain keyword-list)
  (let (default global-attr error-p)
    (cond ((setf default (car (get-keyword-value '(def) keyword-list)))
   (if *validity-checking*
       (cond ((not (funcall (if (setf global-attr (find-symbol (string-upcase domain) "GLOBAL"))
global-attr
(find-symbol (string-upcase domain) *pkg-string*))
    default))
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The default value specified ~S is not in the domain ~S"
  default domain))
      (setf error-p t)))))
  (t
   (setf default (get-default-value domain))))
    (values default error-p)))
se))
      (return-from destroy-relation nil))
  (cond ((null (setf relation (validate-sym relation t)))
 (return-from destroy-relation nil)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes*
  '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "SAVE-DIRECTORY")
  *system-relation-key*
  (list 'string-equal 'relationLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540668. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DEFINE-REL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360336. :AUTHOR "REL3" :LENGTH-IN-BYTES 4982. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lDEFINE-REL\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPDEFINE-RELATIONOPÀDEFRELBPR(RF=$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEATTRIBUTE-DESCRIPTOR&RESTKEYWORD-LIST&KEYj&OPTIONALjDIRECTORYDOCUMENTATIONFORMATIMPLEMENTATION-TYPEKEYCSTORAGE-STRUCTUREj&ALLOW-OTHER-KEYSB:\BdBgBhBiBjBkBlDEFAULTDOCÀDOMAINCKEY-FORMATIMPLEMENTATION-TYPE1DOMAIN-LISTERROR-PÁATTRIBUTE-LISTÂSYSTEM-ATTRIBUTE-LISTSYSTEM-RELATION-LISTCSTORAGE-STRUCTURE1CATTRIBUTETEMP-FORMATCTUPLE-FORMAT-LISTB:B:B:ATT-DESB:B:ÀVALUEB:\)MACROS-EXPANDED\
pBUlCONDITION-BIND-IFpBUCONDITION-BINDpBUCATCH-CONTINUATION-IFpBUlCATCH-CONTINUATIONpBUERRSETFIRSTPROGpZLC,DO-NAMEDpBUINHIBIT-STYLE-WARNINGSSETFDOCUMENTATION0Define relations in the active database.

   RELATION-NAME - Name of the relation to be defined.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   DIRECTORY     - Name of the directory in which this relation is to be saved.
   DOCUMENTATION - Description of this relation.
   FORMAT        - List of print-width values correponding to the attribute-list.
   IMPLEMENTATION-TYPE - Name of the implementation for this relation.
   KEY           - List of attributes comprising the key for this relation.
   STORAGE-STRUCTURE   - Name of the storage structure to be used for this relation.AplEH*CONDITION-HANDLERS*у*DEFAULT-ANYP-WIDTH*C*PROVIDE-WARNING-MESSAGES*у*PKG-STRING*pBU,USER-IDÁ*DOMAIN-LIST*у*SYSTEM-DOMAIN-KEY*C*SYSTEM-DOMAIN-ATTRIBUTES*у*ACTIVE-DB*C*PROVIDE-STATUS-MESSAGES**PROVIDE-ERROR-MESSAGES*C*SYSTEM-RELATIONS*у*PARAMETER-CHECKING*\iDIRECTORYBFORMATIMPLEMENTATION-TYPEKEYiSTORAGE-STRUCTUREpB]STORE-KEYARGSҪSTRING-EQUALpB]MEMBER-TESTACTIVE-DATABASE҃VALIDATE-SYMTERPRIlERROR - No attribute descriptor provided.WRITE-STRINGҪLISTSTRING-UPCASE҃DE-NEST-KEYWORD-LIST,Define relation *READ-FROM-STRINGPRIN1 in database \DIRDOMpBUDEFCARDINALITYBpIMPOWNER-IDTUPMODBkSTOBiGET-KEYWORD-VALUE-PREREQFOBTAIN-IMP-&-STORELATION-EXIST-PÁSYSTEM-DOMAIN\DOMAIN-NAMEQTRIEVEERROR - The attribute l is defined more than onceQUOTEpB]STRING-EQUAL*FÁOBTAIN-DOMAIN\BiCGET-KEYWORD-VALUE҃DEFAULT-TUPLE-FORMAT҃OBTAIN-DOMAIN-DEFAULT-VALUE\BpANYPl?STRING*NREVERSEp,G6443FERRORpB]ERRSET-HANDLERB,DEFREL-CONCATENATEҪFIND-SYMBOL,ERROR - l is an undefined storage structureSYSTEM-ATTRIBUTEÁCOMMIT-TUPLESPUTPpB],*APPENDpBUFIRSTNlWARNING -  is not a valid format value.\B\BÁGET-DIRECTORYpBG6463FT is an undefined implementation typeSYSTEM-RELATIONGETPÂCOMMIT-SYSTEM-RELATION@@QPAQPPQRQRPR5QQ@Q@PQ PP!P@Q"@Q@Q#P$PAQKQRQ%ROTۀQPPU&PP'P
P(WVVQWSBCVWWUQ	QrXSRXSRRRQRNQP)PRQ*PRRQN]NXW5,+PXQ	B,'QXWLQ-P.PALIR/PXW0BIQ1S5SSSSQT]TIQXW#P2PAMG3PXW0BH4PL]L4PI1BT]T5PGHۀQRQ6IQGQHQPO]OXW5+PXQ	B,XYXUXNQ7NLQ7LOQ7O8P9PT:P;P8PJCUPJCY<P=PQQ>P?ZQNQ@QZEJ!BJ!B\\
@PQQAPREBPCPDR/P@Q0BJJ5JQJTQ7TJJQCTQCxJQJQCTQ
CETQCJQFTQPP#!ZZTQWVVQWS[[1[=GP[QHPP[QCVWWZQT<PQ>PIP@Q0BJP@Q0BJTQNQLQEQ@QK3P@Q0BKQQQJPLPMPT:P;PLPJCWPJCU<P=PKQ>P?\QNQ@Q\J!BJ!B\\
@PKQNPROPOPCPPPQECPDBPBPCPPOQECPDQPPQOBPDEFREL-RESTORE*;F%$B:BW]FB:B:B:BZFB_B\BaCATTRIBUTESBfBdB:\BjBlB:\B\BBB\BBBBBpBBBBBkBB\BBB\BB,DEFREL-BBꒀQRPSPQB	A
PQB	@PPAQPBQQQBPP@QPBQQQBOBÁDEFREL-FLAVORR@F4$B:BW]FB:B:B:BZFB_B\BaBvBdB:\ÁATTR-VAL-LISTATOM-ATTRIBUTE-LISTB:ATTR\B\pB]lXR-BQ-CONSpB]lXR-BQ-LISTB
BpB]XR-BQ-LIST*BC*PKG-NAME*BBB҃UNCONVERT-ATTRIBUTESpBUlDEFFLAVOR\B:INITTABLE-INSTANCE-VARIABLESSETTABLE-INSTANCE-VARIABLESGETTABLE-INSTANCE-VARIABLESiSPECIAL-INSTANCE-VARIABLESLIST*ҪEVALB8l:BBB\B8B8BpBUlDEFMETHOD\iFASD-FORM\B8pBUMAKE-INSTANCEPPQQPAPQAQ	P
@AQBBSC@QPPPPCQPPCQ@BPPQ@]@PQ\PP@Q
O<BDEFREL-HASH@F$B:BW]FB:B:B:BZFB_B=\BaBvBdB:\Bk\B\BDEFREL-VALIDATE-KEYҩTESTEQUALSIZEF*MAKE-HASH-TABLE҃ENTRY-POINTBQQ@QPPPP	P
@OPB=BI(a@F9$B:BW]FB:B:B:BZFB_BI\BvBdB:\BkB:B:B:Bk\B\B
BBBBBCCONVERT-ATTRIBUTES\BkBBBBBB,ERROR - BBl is given as a key attribute but it is not contained in the attribute listQPQB@@@@5@Q@@@A@QCBBQCS	CBCCAQ@@R@@5@Q@@QDDSQ
P
PDSPRD@S@@@S@@O`BIDEFREL-HEAPFF
$B:BW]FB:B:B:BZFB_Ba\BaBvBdB:B:B:BOBBIQPQQOjBaCDEFREL-AVLFF
$B:BW]FB:B:B:BZFB_Bk\BaBvBdB:B:B:BOBBIQPQQOtBkDEFREL-LISTFF$B:BW]FB:B:B:BZFB_Bu\BaBvBdB:B:B:O~BuÁDEFREL-STRUCT;@F%$B:BW]FB:B:B:BZFB_B\BaBvBdB:\B:B:B:B\B\B%B'B
BBBB(BBBjDEFSTRUCT\iCONC-NAMEB:CONSTRUCTORMAKE-BBB1B2@сQBAAQBSCPPQCQCABB@QPPQPQP	PPP
PQQOBB$2@$FV$B:BW]FB:B:B:BZFB_B\BaBdB:\BjBl\B\B%BÃ*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*Bу*SYSTEM-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*C*RELATION-IMPLEMENTATION*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*у*SYSTEM-RELATION-STORAGE-STRUCTURE*BBB\BBl-pB],SEARCH*SUBSEQBÂSYSTEM-IMPLEMENTATION\IMPLEMENTATION-NAMEIMPLEMENTATION-NAMEBBBB,ERROR - BBҬ is an undefined implementation type\BSYSTEM-STORAGE-STRUCTURE\STORAGE-STRUCTURE-NAMEÂSTORAGE-STRUCTURE-NAMEl is an undefined storage structureQPP
PA	P@VPQB@	PJPPPPPPPP@QP@QP@@@Q@PQBA	PPPk PP!PPP"PAQPAQ#PAAAQA@QAQOBB"(r@"DFJ$B:BW]FB:B:B:BZFB_B\BaB:\QTRIEVE-VAR\B\B%BC*SYSTEM-VIEW-KEY**SYSTEM-VIEW-ATTRIBUTES*BBBÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*BBBB\,OWNER-IDBaBBBҬERROR - The BBB relation already exists in database e.jWRITE-CHARҬ relation exists and is defined by l. SYSTEM-VIEWANDCVIEW-NAMEBlERROR - There exists a view named  and defining a relation with the same name causes conflicts.Q
PPJP	PPPPPQB@*PQPPPS@PQP@QPSPPPPPPPQPPP PQ!PSROBBC@F+$B:BW]FB:B:B:BZFB_B\BaBdBtB:\Bq\B\BBBBB\BBҬANYPBBBBB,ERROR - BBl is an unrecognized domainPQB@	P@!@Q
@@Q@QPP@Q@PP
P@QP@@Q]@QQOBB=@F'$B:BW]FB:B:B:BZFB_B\BqBdB:\BoGLOBAL-ATTRBuB:\B\BBBу*VALIDITY-CHECKING*\BBBGLOBALBBҬERROR - The default value specified BB is not in the domain CGET-DEFAULT-VALUEPQB@ Q	P
AAQQP
C@QC	P@QPQBQ@@QBQOB1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\B'N\B%.ً\B#\B[\B(̢\B*j\B
=#\Bz(\B-i\B~z\B<p\B`sN\B|abase relation-name))
      (return-from defrel-restore* nil))
  (setf keyword-list (get-keyword-value-prereq '(dir dom def cardinality doc imp owner-id tup mod key sto)
       (car keyword-list)))
  (setf storage-structure (string-upcase (car (get-keyword-value '(sto) kLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540671. :SYSTEM-TYPE :LOGICAL :VERSION 6. :TYPE "LISP" :NAME "DEFSYSTEM" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2760359651. :AUTHOR "REL3" :LENGTH-IN-BYTES 3960. :LENGTH-IN-BLOCKS 4. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;;; -*- Mode:Common-Lisp; Package:USER; Fonts:(TR12 TR12B TR12BI); Base:10 -*-
                ;1; (*CODE-FONT* *COMMENT-FONT* *STRING-FONT*)*
;1;; Copyright (c) by Texas Instruments, Incorporated*
;1;; All rights reserved*
(unless (boundp 'fonts:*code-font*)
  (setq fonts:*code-font* fonts:tr12
 fonts:*comment-font* fonts:tr12b
 fonts:*string-font* fonts:tr12bi))

(defpackage "RTMS")

(DEFSYSTEM RTMS
  (:NAME "RTMS")
  (:SHORT-NAME "RTMS")
  (:PATHNAME-DEFAULT "RTMS:RTMS;")
  (:PACKAGE "RTMS")
  (:PATCHABLE "SYS:RTMS-PATCH;" PATCH)
  (:WARNINGS-PATHNAME-DEFAULT "SYS:CWARNS;RTMS.LISP")
  (:INITIAL-STATUS :RELEASED)
  (:MODULE ATTDET "ATTACH-DETACH")
  (:MODULE AVL "AVL")
  (:MODULE DEFATT "DEFINE-ATT")
  (:MODULE DEFDB "DEFINE-DB")
  (:MODULE DEFDES "DEFINE-DESTROY")
  (:MODULE DEFREL "DEFINE-REL")
  (:MODULE DELMOD "DELETE-MODIFY")
  (:MODULE DESATT "DESTROY-ATT")
  (:MODULE DELAVL "DELETE-AVL")
  (:MODULE DOM "DOMAIN")
  (:MODULE EXT "EXTENSIONS")
  (:MODULE GLOBAL-FUNC "GLOBAL-FUNCTIONS")
  (:MODULE GLOBAL "GLOBAL-VARS")
  (:MODULE HASHOPT "HASH-OPT")
  (:MODULE INDEX "INDEX")
  (:MODULE INSERT "INSERT")
  (:MODULE MACROS "MACROS")
  (:MODULE MODAVL "MODIFY-AVL")
  (:MODULE MODREL "MODIFY-REL")
  (:MODULE MISCI "MISC-INTERNAL")
  (:MODULE MISCU "MISC-USER")
  (:MODULE PRINTT "PRINT")
  (:MODULE RELOPS "RELATION-OPS")
  (:MODULE RENAME "RENAME")
  (:MODULE RESTORE "RESTORE")
  (:MODULE RETRIEVE "RETRIEVE")
  (:MODULE SAVE "SAVE")
1  *(:MODULE RTMSRC "INTERFACE")

  (:AUXILIARY ("starter-kit"))
  (:AUXILIARY ("starter-kit-destroy"))
  (:AUXILIARY ("starter-kit-insert"))
  (:AUXILIARY ("starter-kit-pl"))
  (:AUXILIARY ("starter-kit-set"))
  (:AUXILIARY ("SYS:SITE;RTMS.SYSTEM"))
  (:AUXILIARY ("SYS:SITE;RTMS.TRANSLATIONS"))

  (:COMPILE-LOAD GLOBAL)
  (:COMPILE-LOAD MACROS (:FASLOAD GLOBAL ))
  (:COMPILE-LOAD EXT (:FASLOAD GLOBAL))
  (:COMPILE-LOAD GLOBAL-FUNC (:FASLOAD GLOBAL ext))
  (:COMPILE-LOAD MISCU  (:FASLOAD GLOBAL ext ))
  (:COMPILE-LOAD DOM (:FASLOAD GLOBAL ext ))
  (:COMPILE-LOAD AVL (:FASLOAD GLOBAL  GLOBAL-FUNC ext))
  (:COMPILE-LOAD DELAVL (:FASLOAD GLOBAL  GLOBAL-FUNC AVL ext))
  (:COMPILE-LOAD MODAVL (:FASLOAD GLOBAL  GLOBAL-FUNC AVL ext))
  (:COMPILE-LOAD INDEX (:FASLOAD GLOBAL  GLOBAL-FUNC AVL ext))
  (:COMPILE-LOAD HASHOPT (:FASLOAD GLOBAL  GLOBAL-FUNC ext))
  (:COMPILE-LOAD RESTORE (:FASLOAD GLOBAL  GLOBAL-FUNC ext))
  (:COMPILE-LOAD DELMOD (:FASLOAD GLOBAL  GLOBAL-FUNC HASHOPT RESTORE ext))
  (:COMPILE-LOAD PRINTT (:FASLOAD GLOBAL  RESTORE ext))
  (:COMPILE-LOAD INSERT (:FASLOAD GLOBAL  GLOBAL-FUNC DELMOD RESTORE ext))
  (:COMPILE-LOAD MISCI (:FASLOAD GLOBAL  GLOBAL-FUNC DELMOD INSERT ext))
  (:COMPILE-LOAD DEFREL (:FASLOAD GLOBAL  GLOBAL-FUNC MISCI ext))
  (:COMPILE-LOAD DEFDB (:FASLOAD GLOBAL  GLOBAL-FUNC MISCI DEFREL ext))
  (:COMPILE-LOAD RETRIEVE (:FASLOAD GLOBAL  ext GLOBAL-FUNC AVL DEFREL HASHOPT INSERT PRINTT RESTORE))
  (:COMPILE-LOAD DEFDES (:FASLOAD GLOBAL  ext GLOBAL-FUNC RETRIEVE INSERT DELMOD RESTORE))
  (:COMPILE-LOAD SAVE (:FASLOAD GLOBAL ext  GLOBAL-FUNC DELMOD RETRIEVE))
  (:COMPILE-LOAD RELOPS (:FASLOAD GLOBAL  ext MISCI DEFDES GLOBAL-FUNC INSERT RETRIEVE RESTORE))
  (:COMPILE-LOAD MODREL (:FASLOAD GLOBAL ext  DEFREL DEFDES INSERT RETRIEVE))
  (:COMPILE-LOAD DEFATT (:FASLOAD GLOBAL ext  GLOBAL-FUNC RESTORE MISCI MODREL INSERT DELMOD RETRIEVE))
  (:COMPILE-LOAD DESATT (:FASLOAD GLOBAL ext GLOBAL-FUNC RESTORE MISCI MODREL INSERT DELMOD RETRIEVE))
  (:COMPILE-LOAD RENAME (:FASLOAD GLOBAL ext MACROS GLOBAL-FUNC MISCU AVL HASHOPT RESTORE DELMOD RETRIEVE
  PRINTT INSERT MISCI SAVE DEFDES RELOPS DEFREL DEFDB MODREL DESATT DEFATT))
  (:COMPILE-LOAD ATTDET (:FASLOAD GLOBAL  DEFREL RESTORE GLOBAL-FUNC RETRIEVE))
1  *(:COMPILE-LOAD RTMSRC (:FASLOAD GLOBAL ext MACROS GLOBAL-FUNC MISCU AVL DOM HASHOPT RESTORE DELMOD
  PRINTT INSERT MISCI SAVE DEFDES RETRIEVE RELOPS DEFREL DEFDB MODREL DESATT DEFATT
  RENAME ATTDET INDEX DELAVL))
  )
JCUPJCY<P=PQQ>P?ZQNQ@QZEJ!BJ!B\\
@PQQAPREBPCPDR/P@Q0BJJ5JQJTQ7TJJQCTQLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540674. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DELETE-AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846025. :AUTHOR "REL3" :LENGTH-IN-BYTES 36754. :LENGTH-IN-BLOCKS 36. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package1:*RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; DELETE-AVL*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     delete-flavor-avl*
;1;;     flavor-avl-key-delete*
;1;;     process-flavor-avl-delete*
;1;;*

(defun delete-list-avl (relation-name attribute-list key-attributes domains where-clause index-name
&aux key-value key-domain-list mode (number-deleted 0) rebalancep temp-attribute-list
termination-condition (total-number-deleted 0) tree package-name)
  (cond ((or (equal where-clause t)(equal where-clause '(t)))
 (putp index-name nil 'entry-point)
 (setf total-number-deleted (caar (retrieve 'system-relation 'project '("CARDINALITY")
    'where `(string-equal relation-name
  ,(string-upcase relation-name))
    'tuples t))))
(t
 ;;
 ;;  1Obtain the key from the where clause from the particular relation.*
 ;;
 (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
(setf key-domain-list (eval (read-from-string
      (concatenate 'string *pkg-string* ":*"
   (string-upcase relation-name)
   "-KEY-DOMAINS*")))))
       (t
(setf key-domain-list (car (project-list (list domains) attribute-list key-attributes)))))
 (cond ((symbolp relation-name)
(setf package-name (package-name (symbol-package relation-name))))
       (t
(setf package-name *pkg-string*)))
 (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause
  package-name)
       tree (getp index-name 'entry-point))
 (cond ((null key-value)
(setf key-value (list (list key-attributes) '((t)) '((t))))))
 ;;
 ;;  1Perform the actual deletion of the requested tuples*
 ;;
 ;;
 ;;  1Take each key extracted from the WHERE clause and retrieve the tuples selected by the individual keys.*
 ;;
 ;;
 (do ((key% (first key-value) (cdr key%))
      (beginning-value% (second key-value) (cdr beginning-value%))
      (termination-clause% (third key-value) (cdr termination-clause%)))
     ((null key%) number-deleted)
   (cond ((equal (caar termination-clause%) t)
  (setf termination-condition t))
 (t
  (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
   ;;
   ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
   ;; 1the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to FAST-EVAL-WHERE.*
   ;;
   (multiple-value-setq (where-clause temp-attribute-list)
     (eval-where-prereq where-clause attribute-list relation-name))
   (progv temp-attribute-list nil
     (setf mode "TERMINATE"
   number-deleted 1)
     (do ((beginning-value (car beginning-value%) beginning-value))
 ((or (equal number-deleted 0)(string-equal mode "FINISHED")) t)
       (setf number-deleted 0)
       (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
 (list-avl-key-delete tree temp-attribute-list key-attributes key-domain-list beginning-value
      termination-condition "LOCATE" relation-name where-clause rebalancep
      number-deleted))
       (setf total-number-deleted (+ total-number-deleted number-deleted)
     rebalancep nil))))
 (putp index-name tree 'entry-point)))
  total-number-deleted)

(defun delavl (tree rebalancep temp-tree &aux modtree)
  (cond ((fourth tree)
 (multiple-value-setq (modtree rebalancep temp-tree)
   (delavl (fourth tree) rebalancep temp-tree))
 (rplaca (cdddr tree) modtree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (balance2 tree rebalancep)))))
(t
 (rplaca temp-tree (car tree))
 (setf tree (third tree)
       rebalancep t)))
  (values tree rebalancep temp-tree))

(defun balance1 (tree rebalancep
 &aux root-node-balance-factor left-subtree left-subtree-balance-factor right-subtree
 right-subtree-balance-factor)
  (setf root-node-balance-factor (second tree))
  (cond ((and (null (third tree))(null (fourth tree)))
 (rplaca (cdr tree) 0))
((equal root-node-balance-factor 1)
 (rplaca (cdr tree) 0))
((equal root-node-balance-factor 0)
 (rplaca (cdr tree) -1)
 (setf rebalancep nil))
((equal root-node-balance-factor -1)
 (setf right-subtree (fourth tree)
       right-subtree-balance-factor (second right-subtree))
 (cond ((<= right-subtree-balance-factor 0)
;;
;;  RR rotation
;;
(rplaca (cdddr tree) (third right-subtree))
(rplaca (cddr right-subtree) tree)
(cond ((equal right-subtree-balance-factor 0)
       (rplaca (cdr tree) -1)
       (rplaca (cdr right-subtree) 1)
       (setf rebalancep nil))
      (t
       (rplaca (cdr tree) 0)
       (rplaca (cdr right-subtree) 0)))
(setf tree right-subtree))
       (t
;;
;;  RL rotation
;;
(setf left-subtree (third right-subtree))
(setf left-subtree-balance-factor (second left-subtree))
(rplaca (cddr right-subtree) (fourth left-subtree))
(rplaca (cdddr left-subtree) right-subtree)
(rplaca (cdddr tree) (third left-subtree))
(rplaca (cddr left-subtree) tree)
(cond ((equal left-subtree-balance-factor -1)
       (rplaca (cdr tree) 1))
      (t
       (rplaca (cdr tree) 0)))
(cond ((equal left-subtree-balance-factor 1)
       (rplaca (cdr right-subtree) -1))
      (t
       (rplaca (cdr right-subtree) 0)))
(setf tree left-subtree)
(rplaca (cdr left-subtree) 0)))))
  (values tree rebalancep))

(defun balance2 (tree rebalancep
 &aux root-node-balance-factor left-subtree left-subtree-balance-factor right-subtree
 right-subtree-balance-factor)
  (setf root-node-balance-factor (second tree))
  (cond ((and (null (third tree))(null (fourth tree)))
 (rplaca (cdr tree) 0))
((equal root-node-balance-factor -1)
 (rplaca (cdr tree) 0))
((equal root-node-balance-factor 0)
 (rplaca (cdr tree) 1)
 (setf rebalancep nil))
((equal root-node-balance-factor 1)
 (setf left-subtree (third tree)
       left-subtree-balance-factor (second left-subtree))
 (cond ((>= left-subtree-balance-factor 0)
(rplaca (cddr tree) (fourth left-subtree))
(rplaca (cdddr left-subtree) tree)
(cond ((equal left-subtree-balance-factor 0)
       (rplaca (cdr tree) 1)
       (rplaca (cdr left-subtree) -1)
       (setf rebalancep nil))
      (t
       (rplaca (cdr tree) 0)
       (rplaca (cdr left-subtree) 0)))
(setf tree left-subtree))
       (t
(setf right-subtree (fourth left-subtree))
(setf right-subtree-balance-factor (second right-subtree))
(rplaca (cdddr left-subtree) (caddr right-subtree))
(rplaca (cddr right-subtree) left-subtree)
(rplaca (cddr tree) (cadddr right-subtree))
(rplaca (cdddr right-subtree) tree)
(cond ((equal right-subtree-balance-factor 1)
       (rplaca (cdr tree) -1))
      (t
       (rplaca (cdr tree) 0)))
(cond ((equal right-subtree-balance-factor -1)
       (rplaca (cdr left-subtree) -1))
      (t
       (rplaca (cdr left-subtree) 0)))
(setf tree right-subtree)
(rplaca (cdr right-subtree) 0)))))
  (values tree rebalancep))

(defun list-avl-key-delete (tree attribute-list key-attributes domains beginning-value termination-clause mode
    relation-name where-clause rebalancep number-deleted
    &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil))
      (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
  (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-list (list (caar tree)) attribute-list key-attributes)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator (node-compare beginning-value current-node-key-value domains))))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
   ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
    (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
      (list-avl-key-delete (third tree) attribute-list key-attributes domains beginning-value
   termination-clause mode relation-name where-clause rebalancep
   number-deleted))
    (rplaca (cddr tree) mod-tree)
    (cond (rebalancep
   (multiple-value-setq (tree rebalancep)
(balance1 tree rebalancep))
   (cond (rebalancep
  (setf mode "2TERMINATE"*))
 (t
  (setf mode "2RESTART"*)))))
    (cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
(not (string-equal mode "2FINISHED"*)))
   (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
      (process-list-avl-delete tree attribute-list where-clause number-deleted rebalancep mode
       beginning-value relation-name termination-clause key-attributes
       domains))
   (setf tree mod-tree))))
   ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
    (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
       (list-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
    termination-clause mode relation-name where-clause rebalancep
    number-deleted))
    (rplaca (cdddr tree) mod-tree)
    (cond (rebalancep
   (multiple-value-setq (tree rebalancep)
(balance2 tree rebalancep))
   (cond (rebalancep
  (setf mode "2TERMINATE"*))
 (t
  (setf mode "2RESTART"*))))))
   ((string-equal comparison-operator 'equal)
;
;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;1 the node is no longer equal.*
;
    (setf mode  "LOCATE-STAGE-2")
    (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
 (list-avl-key-delete (caddr tree)
      attribute-list key-attributes domains
      beginning-value termination-clause mode
      relation-name where-clause rebalancep number-deleted))
    ;;
    ;;1  The first time control is passed to this location, the beginning node has been found*
    ;;
    ;;
    ;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause for the current node.*
    ;1; Also must be wary for more than a single tuple per node. If tuples get deleted from within the node but not the node itself,*
    ;1; searching can continue. This function must only be rewound when a rebalancing needs to be done.*
    ;;
    (if (or (string-equal mode "2LOCATE"*) (string-equal mode "2LOCATE-STAGE-2"*))
(setf mode "2DELETE-SEARCH"*))
    (rplaca (cddr tree) mod-tree)
    (cond (rebalancep
   (multiple-value-setq (tree rebalancep)
(balance1 tree rebalancep))
   (if rebalancep
       (setf mode "2TERMINATE"*)
       (setf mode "2RESTART"*))))
    (cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
(not (string-equal mode "2FINISHED"*)))
   (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
      (process-list-avl-delete tree attribute-list where-clause number-deleted rebalancep mode
       beginning-value relation-name termination-clause key-attributes
       domains))
   (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
   (list-avl-key-delete tree attribute-list key-attributes domains beginning-value termination-clause
"2LOCATE"* relation-name where-clause rebalancep number-deleted))))
  (values tree mode rebalancep number-deleted beginning-value))

(defun super-fast-eval-where (val-list attribute-list where-clause
      &aux (result nil))
  (mapc
    (function (lambda (%tuple)
(mapc #'(lambda (x z)
  (set x z))
      attribute-list
      %tuple)
(if (eval where-clause)
    (setf result (cons %tuple result)))))
    val-list)
  result)

(defun process-list-avl-delete (tree attribute-list where-clause number-deleted rebalancep mode beginning-value
relation-name termination-clause key-attributes domains
&aux deleted-tuples mod-tree temp-tree tuples)
  ;;
  ;;1  Any tuples to delete from the current node ??*
  ;;
  (setf deleted-tuples (super-fast-eval-where (first tree) attribute-list where-clause))
  (cond ((> (length deleted-tuples) 0)
 ;;
 ;;1  Need to determine which tuples from the current node need to be deleted*
 ;;
 (mapc (function (lambda (node-tuple)
   (if (not (member node-tuple deleted-tuples :test 'equalp))
       (setf tuples (append (list node-tuple) tuples)))))
       (first tree))
 (setf number-deleted (+ number-deleted (length deleted-tuples)))
 ;;
 ;;1  No tuples are left in the node, delete the node*
 ;;
 (cond ((null tuples)
(setf beginning-value (car (project-list (list (caar tree)) attribute-list key-attributes)))
(rplaca tree (list (caar tree)))
(setf mode "2TERMINATE"*
      temp-tree tree)
(cond ((equal (car (fourth temp-tree)) nil)
       (setf tree (third temp-tree)
     rebalancep t))
      ((equal (car (third temp-tree)) nil)
       (setf tree (fourth temp-tree)
     rebalancep t))
      (t
       (multiple-value-setq (mod-tree rebalancep temp-tree)
 (delavl (third tree) rebalancep temp-tree))
       (rplaca (cddr temp-tree) mod-tree)
       (if rebalancep
   (multiple-value-setq (tree rebalancep)
     (balance1 tree rebalancep))))))
       (t
(rplaca tree tuples)))))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (first tree) attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (list-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
       termination-clause "2LOCATE"* relation-name where-clause rebalancep
       number-deleted))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-deleted beginning-value))

(defun delete-flavor-avl (relation-name attribute-list key-attributes domains where-clause index-name
  &aux key-value key-domain-list mode (number-deleted 0) rebalancep temp-attribute-list
  termination-condition (total-number-deleted 0) tree package-name)
  ;;
  ;;  1Obtain the key from the where clause from the particular relation.*
  ;;
  (cond ((or (equal where-clause t)(equal where-clause '(t)))
 (putp index-name nil 'entry-point)
 (setf total-number-deleted (caar (retrieve 'system-relation 'project '("CARDINALITY")
    'where `(string-equal relation-name
  ,(string-upcase relation-name))
    'tuples t))))
(t
 (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
(setf key-domain-list (eval (read-from-string
      (concatenate 'string *pkg-string* ":*"
   (string-upcase relation-name)
   "-KEY-DOMAINS*")))))
       (t
(setf key-domain-list (car (project-list (list domains) attribute-list key-attributes)))))
 (cond ((symbolp relation-name)
(setf package-name (package-name (symbol-package relation-name))))
       (t
(setf package-name *pkg-string*)))
 (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause
  package-name)
       tree (getp index-name 'entry-point))
 (cond ((null key-value)
(setf key-value (list (list key-attributes) '((t)) '((t))))))
 ;;
 ;;  1Perform the actual deletion of the requested tuples*
 ;;
 ;;
 ;;  1Take each key extracted from the WHERE clause and retrieve the tuples selected by the individual keys.*
 ;;
 ;;
 (do ((key% (first key-value) (cdr key%))
      (beginning-value% (second key-value) (cdr beginning-value%))
      (termination-clause% (third key-value) (cdr termination-clause%)))
     ((null key%) number-deleted)
   (cond ((equal (caar termination-clause%) t)
  (setf termination-condition t))
 (t
  (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
   ;;
   ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
   ;; 1the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to FAST-EVAL-WHERE.*
   ;;
   (multiple-value-setq (where-clause temp-attribute-list)
     (eval-where-prereq where-clause attribute-list relation-name))
   (progv temp-attribute-list nil
     (setf mode "TERMINATE"
   number-deleted 1)
     (do ((beginning-value (car beginning-value%) beginning-value))
 ((or (equal number-deleted 0)(string-equal mode "FINISHED")) t)
       (setf number-deleted 0)
       (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
 (flavor-avl-key-delete tree temp-attribute-list key-attributes key-domain-list beginning-value
termination-condition "LOCATE" relation-name where-clause rebalancep
number-deleted))
       (setf total-number-deleted (+ total-number-deleted number-deleted)
     rebalancep nil))))
 (putp index-name tree 'entry-point)))
  total-number-deleted)

(defun flavor-avl-key-delete (tree attribute-list key-attributes domains beginning-value termination-clause mode
      relation-name where-clause rebalancep number-deleted
      &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil))
      (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
  (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-flavor (list (caar tree)) attribute-list key-attributes)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator
      (node-compare beginning-value current-node-key-value domains))))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (flavor-avl-key-delete (third tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (cond (rebalancep
2       *(setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*)))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
 (process-flavor-avl-delete tree attribute-list where-clause number-deleted rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains))
       (setf tree mod-tree))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (flavor-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (cond (rebalancep
2       *(setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*))))))
       ((string-equal comparison-operator 'equal)
;;
;;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;;1 the node is no longer equal.*
;;
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (flavor-avl-key-delete (caddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
;;
;;1  The first time control is passed to this location, the beginning node has been found*
;;
;;
;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause*
;;1 for the current node. Also must be wary for more than a single tuple per node. If tuples get deleted*
;;1 from within the node but not the node itself, searching can continue. This function must only be rewound*
;;1 when a rebalancing needs to be done.*
;;
(cond ((or (string-equal mode "2LOCATE"*) (string-equal mode "2LOCATE-STAGE-2"*))
       (setf mode "2DELETE-SEARCH"*)))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (cond (rebalancep
      (setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*)))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
 (process-flavor-avl-delete tree attribute-list where-clause number-deleted rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains))
       (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
   (flavor-avl-key-delete tree attribute-list key-attributes domains beginning-value termination-clause
  "2LOCATE"* relation-name where-clause rebalancep number-deleted))))
  (values tree mode rebalancep number-deleted beginning-value))

(defun process-flavor-avl-delete (tree attribute-list where-clause number-deleted rebalancep mode
  beginning-value relation-name termination-clause key-attributes domains
  &aux deleted-tuples mod-tree temp-tree tuples)
  ;;
  ;;1  Any tuples to delete from the current node ??*
  ;;
  (setf deleted-tuples (super-fast-eval-where (project-flavor (first tree) attribute-list attribute-list)
      attribute-list where-clause))
  (cond ((> (length deleted-tuples) 0)
 ;;
 ;;1  Need to determine which tuples from the current node need to be deleted*
 ;;
 (mapc (function (lambda (node-tuple list-tuple)
   (cond ((not (member list-tuple deleted-tuples :test 'equalp))
  (setf tuples (append (list node-tuple) tuples))))))
       (first tree)
       (project-flavor (first tree) attribute-list attribute-list))
 (setf number-deleted (+ number-deleted (length deleted-tuples)))
 ;;
 ;;1  No tuples are left in the node, delete the node*
 ;;
 (cond ((null tuples)
(setf beginning-value (car (project-flavor (list (caar tree)) attribute-list key-attributes)))
(rplaca tree (list (caar tree)))
(setf mode "2TERMINATE"*
      temp-tree tree)
(cond ((equal (car (fourth temp-tree)) nil)
       (setf tree (third temp-tree)
     rebalancep t))
      ((equal (car (third temp-tree)) nil)
       (setf tree (fourth temp-tree)
     rebalancep t))
      (t
       (multiple-value-setq (mod-tree rebalancep temp-tree)
 (delavl (third tree) rebalancep temp-tree))
       (rplaca (cddr temp-tree) mod-tree)
       (cond (rebalancep
      (multiple-value-setq (tree rebalancep)
(balance1 tree rebalancep)))))))
       (t
(rplaca tree tuples)))))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (project-flavor (first tree) attribute-list attribute-list)
       attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (flavor-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
 termination-clause "2LOCATE"* relation-name where-clause rebalancep
 number-deleted))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-deleted beginning-value))

(defun delete-struct-avl (relation-name attribute-list key-attributes domains where-clause index-name
  &aux key-value key-domain-list mode (number-deleted 0) rebalancep temp-attribute-list
  termination-condition (total-number-deleted 0) tree package-name)
  (cond ((or (equal where-clause t)(equal where-clause '(t)))
 (putp index-name nil 'entry-point)
 (setf total-number-deleted (caar (retrieve 'system-relation 'project '("CARDINALITY")
    'where `(string-equal relation-name
  ,(string-upcase relation-name))
    'tuples t))))
(t
 ;;
 ;;  1Obtain the key from the where clause from the particular relation.*
 ;;
 (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
(setf key-domain-list (eval (read-from-string
      (concatenate 'string *pkg-string* ":*"
   (string-upcase relation-name)
   "-KEY-DOMAINS*")))))
       (t
(setf key-domain-list (car (project-list (list domains) attribute-list key-attributes)))))
 (cond ((symbolp relation-name)
(setf package-name (package-name (symbol-package relation-name))))
       (t
(setf package-name *pkg-string*)))
 (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause
  package-name)
       tree (getp index-name 'entry-point))
 (cond ((null key-value)
(setf key-value (list (list key-attributes) '((t)) '((t))))))
 ;;
 ;;  Perform the actual deletion of the requested tuples
 ;;
 ;;
 ;;  Take each key extracted from the WHERE clause and retrieve the tuples selected by the individual
 ;1;   *keys.
 ;;
 (do ((key% (first key-value) (cdr key%))
      (beginning-value% (second key-value) (cdr beginning-value%))
      (termination-clause% (third key-value) (cdr termination-clause%)))
     ((null key%) number-deleted)
   (cond ((equal (caar termination-clause%) t)
  (setf termination-condition t))
 (t
  (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
   ;;
   ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
   ;; 1the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to FAST-EVAL-WHERE.*
   ;;
   (multiple-value-setq (where-clause temp-attribute-list)
     (eval-where-prereq where-clause attribute-list relation-name))
   (progv temp-attribute-list nil
     (setf mode "TERMINATE"
   number-deleted 1)
     (do ((beginning-value (car beginning-value%) beginning-value))
 ((or (equal number-deleted 0)(string-equal mode "FINISHED")) t)
       (setf number-deleted 0)
       (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
 (struct-avl-key-delete tree temp-attribute-list key-attributes key-domain-list beginning-value
termination-condition "LOCATE" relation-name where-clause rebalancep
number-deleted))
       (setf total-number-deleted (+ total-number-deleted number-deleted)
     rebalancep nil))))
 (putp index-name tree 'entry-point)))
  total-number-deleted)

(defun struct-avl-key-delete (tree attribute-list key-attributes domains beginning-value termination-clause mode
      relation-name where-clause rebalancep number-deleted
      &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil))
      (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
  (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-struct (list (caar tree)) attribute-list key-attributes
   relation-name)))
 (cond ((equal (car beginning-value) t)
(setf comparison-operator 'less-than))
       (t
(setf comparison-operator
      (node-compare beginning-value current-node-key-value domains))))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (struct-avl-key-delete (third tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (cond (rebalancep
2       *(setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*)))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
 (process-struct-avl-delete tree attribute-list where-clause number-deleted rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains))
       (setf tree mod-tree))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (struct-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (cond (rebalancep
2       *(setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*))))))
       ((string-equal comparison-operator 'equal)
;;
;;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;;1 the node is no longer equal.*
;;
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (struct-avl-key-delete (caddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-deleted))
;;
;;1  The first time control is passed to this location, the beginning node has been found*
;;
;;
;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause*
;;1 for the current node. Also must be wary for more than a single tuple per node. If tuples get deleted*
;;1 from within the node but not the node itself, searching can continue. This function must only be rewound*
;;1 when a rebalancing needs to be done.*
;;
(cond ((or (string-equal mode "2LOCATE"*)
   (string-equal mode "2LOCATE-STAGE-2"*))
       (setf mode "2DELETE-SEARCH"*)))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (cond (rebalancep
2       *(setf mode "2TERMINATE"*))
     (t
      (setf mode "2RESTART"*)))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
 (process-struct-avl-delete tree attribute-list where-clause number-deleted rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains))
       (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-deleted beginning-value)
   (struct-avl-key-delete tree attribute-list key-attributes domains beginning-value termination-clause
  "2LOCATE"* relation-name where-clause rebalancep number-deleted))))
  (values tree mode rebalancep number-deleted beginning-value))

(defun process-struct-avl-delete (tree attribute-list where-clause number-deleted rebalancep mode
  beginning-value relation-name termination-clause key-attributes domains
  &aux deleted-tuples mod-tree temp-tree tuples)
  ;;
  ;;1  Any tuples to delete from the current node ??*
  ;;
  (setf deleted-tuples (super-fast-eval-where (project-struct (first tree) attribute-list attribute-list
      relation-name)
      attribute-list where-clause))
  (cond ((> (length deleted-tuples) 0)
 ;;
 ;;1  Need to determine which tuples from the current node need to be deleted*
 ;;
 (mapc (function (lambda (node-tuple list-tuple)
   (cond ((not (member list-tuple deleted-tuples :test 'equalp))
  (setf tuples (append (list node-tuple) tuples))))))
       (first tree)
       (project-struct (first tree) attribute-list attribute-list relation-name))
 (setf number-deleted (+ number-deleted (length deleted-tuples)))
 ;;
 ;;1  No tuples are left in the node, delete the node*
 ;;
 (cond ((null tuples)
(setf beginning-value
      (car (project-struct (list (caar tree)) attribute-list key-attributes relation-name)))
(rplaca tree (list (caar tree)))
(setf mode "2TERMINATE"*
      temp-tree tree)
(cond ((equal (car (fourth temp-tree)) nil)
       (setf tree (third temp-tree)
     rebalancep t))
      ((equal (car (third temp-tree)) nil)
       (setf tree (fourth temp-tree)
     rebalancep t))
      (t
       (multiple-value-setq (mod-tree rebalancep temp-tree)
 (delavl (third tree) rebalancep temp-tree))
       (rplaca (cddr temp-tree) mod-tree)
       (cond (rebalancep
      (multiple-value-setq (tree rebalancep)
(balance1 tree rebalancep)))))))
       (t
(rplaca tree tuples)))))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (project-struct (first tree) attribute-list attribute-list relation-name)
       attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-deleted beginning-value)
  (struct-avl-key-delete (cadddr tree) attribute-list key-attributes domains beginning-value
 termination-clause "2LOCATE"* relation-name where-clause rebalancep
 number-deleted))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-deleted beginning-value))
st)
    value-list (cons (list 'quote default-value) value-list)))))
      ((not (string-equal "RTMS-NO-VALMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540678. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DELETE-AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359963. :AUTHOR "REL3" :LENGTH-IN-BYTES 4880. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pp2\COMPILE-DATA\SW-MFG,GODZILLA,FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lDELETE-AVL\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPDELETE-LIST-AVL*Vֆ*F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEÁATTRIBUTE-LISTÁKEY-ATTRIBUTESDOMAINSWHERE-CLAUSECINDEX-NAMEB:\CKEY-VALUEKEY-DOMAIN-LISTMODEÁNUMBER-DELETEDCREBALANCEPTEMP-ATTRIBUTE-LISTÂTERMINATION-CONDITIONTOTAL-NUMBER-DELETEDTREEPACKAGE-NAMEKEY%BEGINNING-VALUE%TERMINATION-CLAUSE%B:B:BEGINNING-VALUE\)MACROS-EXPANDED\UNLESSTHIRDSECONDFIRSTPROGpB\lXR-BQ-LISTSETFÀ*PKG-STRING*C*SYSTEM-RELATIONS*\BYENTRY-POINTPUTPSYSTEM-RELATIONPROJECT\CARDINALITYÀWHERESTRING-EQUALB`STRING-UPCASEҪLISTÀTUPLESRETRIEVEpB\MEMBER-TESTSTRINGl:*-KEY-DOMAINS*CONCATENATE*READ-FROM-STRINGҪEVAL҃PROJECT-LISTBpEXTRACT-KEY-AVL҃GETP\\BYBYLEPFCEVAL-WHERE-PREREQjMAKUNBOUNDlTERMINATELOCATEPLIST-AVL-KEY-DELETE,FINISHEDpB\STRING-EQUAL*CG߄QQ*QP	P
PPPPPQPJBGGQPP
PPPQPQQQBAQCPIQQAQQIQ@QPH@QPP@@S@W@[LKJRLQB&F PJQBLQBFQQQ!P"PAEEQNMCMMSCNSNMS#MN$PBJCKSOCHQEQQAQOQFQ%PQQDQCQ&P'PAOCDBHGQCaGDJC'BQ(P)JKLJQHQPGOBPÀDELAVL-@F$B:BV]FB:B:B:BYFB^B\BoBkCTEMP-TREEB:\MODTREE\Bv\ByBFOURTHFBFBALANCE2QQBQQPPA@QB@QQQPPAQS[݀QQQOBBALANCE14k@F7$B:BV]FB:B:B:BYFB^B\BoBkB:\ROOT-NODE-BALANCE-FACTORLEFT-SUBTREELEFT-SUBTREE-BALANCE-FACTORÁRIGHT-SUBTREERIGHT-SUBTREE-BALANCE-FACTOR\Bv\BByBzBW@QQUXJ@'USJ@'ULML@'JQBCCWDD=QBC[CYQJD'ULCUJUJCUJCQ(C[AAWBCYAQBAQBCQQBA[AYQULB'JJCUJB'LJAQAUJQQOBB4k@F7$B:BV]FB:B:B:BYFB^B\BoBkB:\BBBBB\Bv\BByBzBW@QQUYL@'UTJ@'UJNJ@'K[AAWBB?YAQBAQBQJB'UJAULUJAUJAQ)AQBCCWDAQBC[CYAQYCQBCQBQUJD'LJAULD'LJCQCUJQQOBBpBF$B:BV]FB:B:B:BYFB^B\BoBaBbBcBtCTERMINATION-CLAUSEBiB`BdBkBjB:\COMPARISON-OPERATORÂCURRENT-NODE-KEY-VALUEMOD-TREE\Bv\ByBÀLOCATEBÁLOCATE-STAGE-2DELETE-SEARCHB
BBYCLESS-THANNODE-COMPARE҆PB҃GREATER-THANFBlTERMINATE,RESTARTEQUALLOCATE-STAGE-2LOCATEB,FINISHEDPROCESS-LIST-AVL-DELETEQPQPQPQBQQBAS	&
PQAQQ@
&QP[QQQQQQQQQQPPABQ@Q&+QP'QBQQQQQQQQQQPPABQBBQgQQPPAP[PY@QPVP[QQQQQQQQQQPPABQPQPPYBQQQPPAPPQP!QPQPQQQQQQQQQQQPPABÀPQPQQQQQQPQQQQPPAQQQQQOBÂSUPER-FAST-EVAL-WHERE @F$B:BV]FB:B:B:BYFB^B\VAL-LISTBaBdB:\ÀRESULTB:À%TUPLEB:B:\Bv\BB|pZLC,DO-NAMEDBQAASBQBQDCCSDSCDCDQBQ@]@A@OBBEBFW$B:BV]FB:B:B:BYFB^B\BoBaBdBjBkBiBtB`BBbBcB:\ÁDELETED-TUPLESBBBB:CNODE-TUPLE\Bv\ByBB|B
B{BBpB\MEMBER-EQUALPB
BlTERMINATEFBFBBLOCATEPBB,FINISHEDSQQ@JJSD
DSE@QEQC]CD@QCaC4QBQQBQQBPQBBUB[BQBQB[QBQP	PABABYAQQQ
PPAQCQQP.SQQ$QBQQQQQPQQQQPPAAQBAQQQ
PPAPPۀQQQQQO!BCDELETE-FLAVOR-AVL*Vֆ*F$B:BV]FB:B:B:BYFB^B"\B`BaBbBcBdBeB:\BgBhBiBjBkBlBmBnBoBpBqBrBsB:B:Bt\Bv\BxByBzB{B|B~BÀBB\BYBBBB\CARDINALITYBBB`BB
BBBBl:*-KEY-DOMAINS*BBBBBpBB\\BYBYBFBBlTERMINATELOCATEPÂFLAVOR-AVL-KEY-DELETE,FINISHEDBCG߄QQ*QP	P
PPPPPQPJBGGQPP
PPPQPQQQBAQCPIQQAQQIQ@QPH@QPP@@S@W@[LKJRLQB&F PJQBLQBFQQQ!P"PAEEQNMCMMSCNSNMS#MN$PBJCKSOCHQEQQAQOQFQ%PQQDQCQ&P'PAOCDBHGQCaGDJC'BQ(P)JKLJQHQPGO<B"B:pBF$B:BV]FB:B:B:BYFB^B:\BoBaBbBcBtBBiB`BdBkBjB:\BBB\Bv\ByBBBBDELETE-SEARCHB
ÁPROJECT-FLAVORBYBB҆PB:BFBlTERMINATE,RESTARTBLOCATE-STAGE-2LOCATEB,FINISHEDCPROCESS-FLAVOR-AVL-DELETEQPQPQPQBQQBAS	&
PQAQQ@
&QP[QQQQQQQQQQPPABQ@Q&+QP'QBQQQQQQQQQQPPABQBBQgQQPPAP[PY@QPVP[QQQQQQQQQQPPABQPQPPYBQQQPPAPPQP!QPQPQQQQQQQQQQQPPABÀPQPQQQQQQPQQQQPPAQQQQQORB:BQNBF`$B:BV]FB:B:B:BYFB^BQ\BoBaBdBjBkBiBtB`BBbBcB:\BBBBB:B:BCLIST-TUPLE\Bv\ByBB|B
B{BBIBBB
lTERMINATEFBFBBLOCATEPB:B,FINISHEDSQQQQ@JVSSQQEDDSESGFGQ@QFQC]CDEDE@QCaC4QBQQBQQBPQBBUB[BQBQB[QBQP	PABABYAQQQ
PPAQCQQP1SQQQQ$QBQQQQQPQQQQPPAAQBAQQQ
PPAPPۀQQQQQOeBQCDELETE-STRUCT-AVL*Vֆ*F$B:BV]FB:B:B:BYFB^Bf\B`BaBbBcBdBeB:\BgBhBiBjBkBlBmBnBoBpBqBrBsB:B:Bt\Bv\BxByBzB{B|B~BÀBB\BYBBBB\CARDINALITYBBB`BB
BBBBl:*-KEY-DOMAINS*BBBBBpBB\\BYBYBFBBlTERMINATELOCATEPÂSTRUCT-AVL-KEY-DELETE,FINISHEDBCG߄QQ*QP	P
PPPPPQPJBGGQPP
PPPQPQQQBAQCPIQQAQQIQ@QPH@QPP@@S@W@[LKJRLQB&F PJQBLQBFQQQ!P"PAEEQNMCMMSCNSNMS#MN$PBJCKSOCHQEQQAQOQFQ%PQQDQCQ&P'PAOCDBHGQCaGDJC'BQ(P)JKLJQHQPGOBfB~pBF$B:BV]FB:B:B:BYFB^B~\BoBaBbBcBtBBiB`BdBkBjB:\BBB\Bv\ByBBBBDELETE-SEARCHB
ÁPROJECT-STRUCTBYBB҆PB~BFBlTERMINATE,RESTARTBLOCATE-STAGE-2LOCATEB,FINISHEDCPROCESS-STRUCT-AVL-DELETEQPQPQPQBQQQBAS	&
PQAQQ@
&QP[QQQQQQQQQQPPABQ@Q&+QP'QBQQQQQQQQQQPPABQBBQgQQPPAP[PY@QPVP[QQQQQQQQQQPPABQPQPPYBQQQPPAPPQP!QPQPQQQQQQQQQQQPPABÀPQPQQQQQQPQQQQPPAQQQQQOB~BPBFb$B:BV]FB:B:B:BYFB^B\BoBaBdBjBkBiBtB`BBbBcB:\BBBBB:B:BB\\Bv\ByBB|B
B{BB
BBB
lTERMINATEFBFBBLOCATEPB~B,FINISHEDSQQQQQ@JXSSQQQEDDSESGFGQ@QFQC]CDEDE@QCaC5QBQQQBQQBPQBBUB[BQBQB[QBQP	PABABYAQQQ
PPAQCQQP2SQQQQQ$QBQQQQQPQQQQPPAAQBAQQQ
PPAPPۀQQQQQOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\
\DEFUN'\B
*j\Bx\B[\B~.ً\B|=#\B{z(\Bz{\By:}n\Bx6 (t
  (setf mode "2RESTART"*))))))
   ((string-equal comparison-operator 'equal)
;
;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;1 the node is no longer equal.*
;
   LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540681. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DELETE-MODIFY" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846037. :AUTHOR "REL3" :LENGTH-IN-BYTES 42191. :LENGTH-IN-BLOCKS 42. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; DELETE-MODIFY*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     errset*
;1;;     deff*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     delete-flavor-heap*
;1;;     delete-flavor-hash*
;1;;     modify-flavor-heap*
;1;;     modify-flavor-hash*
;1;;     flavor-bucket*
;1;;*

(defun form-alist (tuple attributes &aux (alist nil))
  (do ((att-list attributes (cdr att-list))
       (val-list tuple (cdr val-list)))
      ((null att-list) t)
    (setf alist (append (list (cons (car att-list) (car val-list))) alist)))
  alist)

(defun quote-tuple (tuple)
  (mapcar (function (lambda (value)
      `(quote ,value)))
  tuple))

(defun dom-check (value attr dom-def &aux temp)
1   *;;1This is necessary when we define database.*
  (if (and *validity-checking* (not (and *restore-operation* (null dom-def))))
      (cond ((null (funcall (intern (string-upcase
      (second (setf temp (assoc (string attr) dom-def :test 'string-equal))))
    *pkg-string*)
    value))
     (if *provide-warning-messages*
 (format *standard-output*
 "~%WARNING - ~s is not a legal value for the ~s attribute whose domain is ~s"
 value attr (second temp)))
     nil)
    (t t))
      t))

(defun modify-tuple (attribute-list modify-attributes tuple values dom-def relation-name temp-attribute-list
     &aux tempval (temp-result nil))
  (do ((attribute attribute-list (cdr attribute))
       (tuple-value tuple (cdr tuple-value)))
      ((null attribute) t)
    (cond ((member (car attribute) modify-attributes :test 'string-equal)
   (setf tempval
 ;;
 ;;  It is legal to allow the user to specify attributes from the relation when computing the
 ;1;  *new value of the attribute. This is why the entire tuple is formed in the a-list.
 ;;
 (modify-eval-where tuple (nth (position (car attribute) modify-attributes :test 'equal)
values) temp-attribute-list))
   (if (or (member relation-name *system-relations* :test 'string-equal) (not *parameter-checking*)
   (not *validity-checking*) (dom-check tempval (car attribute) dom-def))
       (setf temp-result (cons tempval temp-result))
       (setf temp-result (cons (car tuple-value) temp-result))))
  (t
   (setf temp-result (cons (car tuple-value) temp-result)))))
   (reverse temp-result))

(defun modify-eval-where (val-list where-clause temp-attribute-list)
  (mapc #'(lambda (x z)
    (set x z))
temp-attribute-list
val-list)
  (eval where-clause))

(defun delete-tuples (relation &rest keyword-list
      &key &optional where &allow-other-keys
      &aux where-clause qtrieve-var ss key-attributes attributes card imp (num-deleted 0)
      domains)
  "Deletes the tuples which satisfy the WHERE clause from the specified relation.

   RELATION - Name of the relation from which the tuples are to be deleted.
   WHERE    - Selection criterion to be used."
  where
  (block delete-tuples
(setf keyword-list (de-nest-keyword-list keyword-list))
(cond (*parameter-checking*
       (if (or (not (active-database)) (not (setf relation (validate-sym relation))))
   (return-from delete-tuples nil))
       (setf keyword-list (get-keyword-value-prereq '(where) keyword-list))))
(setf where-clause (car (get-keyword-value '(where) keyword-list)))
;;
;;1  Obtain some revelant information about the current relation*
;;
(setf qtrieve-var (get-relation relation '("IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY" "ATTRIBUTES"
   "CARDINALITY" "2DOMAINS"*) t))
(setf relation (car qtrieve-var)
      qtrieve-var (cadr qtrieve-var))
(cond ((null qtrieve-var)
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - Relation ~s does not exist in the database ~s"
   (read-from-string (string-upcase relation)) *active-db*))
       (return-from delete-tuples nil)))
;;
;;1  If the user does not specify a where clause, it defaults to NIL and thus no tuples will be deleted.*
;;
(setf imp (first qtrieve-var)
      ss (second qtrieve-var)
      key-attributes (third qtrieve-var)
      attributes (fourth qtrieve-var)
      card (fifth qtrieve-var)
      domains (sixth qtrieve-var)
      num-deleted 0)
(cond ((null where-clause)
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - No where clause specified, no tuples deleted"))
       (return-from delete-tuples nil))
      ((not (listp where-clause))
       (cond ((eval where-clause)
      (setf where-clause t))
     (t
      (return-from delete-tuples 0)))))
;;
;;1  Perform the actual deletion of the requested tuples*
;;
(setf num-deleted (funcall (find-symbol (concatenate 'string "DELETE-" imp "-" ss) *pkg-string*)
   relation attributes key-attributes domains where-clause relation))
(cond ((> num-deleted 0)
       ;;
       ;;1  Tuples were deleted, so now we must determine if there are indices defined on this relation. If so the tuples must*
       ;;1 be deleted from each of the index structures.*
       ;;
       (mapc (function (lambda (index-info)
 (funcall (find-symbol (concatenate 'string "2DELETE-"* imp "2-"*
    (second index-info)) *pkg-string*)
  relation attributes (third index-info) domains where-clause
  (first index-info))))
     (qtrieve 'system-index *system-index-attributes*
 '("INDEX-NAME2"* "INDEX-TYPE2"* "KEY2"*) *system-index-key*
 `(string-equal relation-name ,(string relation))))
       ;;
       ;;1  Indicate that the system-relation relation has been updated.*
       ;;
       (funcall (find-symbol (concatenate 'string "MODIFY-" *system-relation-base-implementation*
  "-" *system-relation-storage-structure*) *pkg-string*)
'system-relation *system-relation-attributes* *system-relation-key* '("MODIFIEDP")
'(t) `(equal relation-name "SYSTEM-RELATION") nil nil)
       ;;
       ;;1  Update the system-relation relation to reflect the number tuples deleted*
       ;;
       (funcall (find-symbol (concatenate 'string "MODIFY-" *system-relation-base-implementation* "-"
    *system-relation-storage-structure*) *pkg-string*)
'system-relation *system-relation-attributes* *system-relation-key*
'("MODIFIEDP" "CARDINALITY") (list t (- card num-deleted))
`(equal relation-name ,(string relation)) nil nil)
       (if *provide-status-messages*
   (format *standard-output* "~%~S tuple~:P deleted." num-deleted)))
      (t
       (if *provide-status-messages*
   (format *standard-output* "~%No tuples deleted"))))
(return-from delete-tuples relation num-deleted)))

(deff modify-tuples 'modify)

(defun delete-or-modify (relation del-or-mod where-clause
 &optional attributes values)
  ;;for old-times sake.
  (if del-or-mod
      (if (member (string-upcase relation) *system-relations* :test 'string-equal)
  (funcall
    (find-symbol (concatenate 'string "MODIFY-" *system-relation-base-implementation* "-"
*system-relation-storage-structure*) *pkg-string*)
    relation
    (symbol-value
      (read-from-string (concatenate 'string *pkg-name* "*" (string-upcase relation) "-attributes*")))
    (symbol-value (read-from-string (concatenate 'string *pkg-name* "*" (string-upcase relation)
 "-key*")))
    attributes values where-clause nil nil)
(modify relation 'where where-clause 'attributes attributes 'values values))
    (if (member (string-upcase relation) *system-relations* :test 'string-equal)
  (funcall
    (find-symbol (concatenate 'string "DELETE-" *system-relation-base-implementation* "-"
*system-relation-storage-structure*) *pkg-string*)
    relation
    (symbol-value
      (read-from-string (concatenate 'string *pkg-name* "*" (string-upcase relation) "-attributes*")))
    (symbol-value (read-from-string (concatenate 'string *pkg-name* "*" (string-upcase relation)
 "-key*")))
    nil where-clause relation)
(delete-tuples relation 'where where-clause))))

(defun modify (relation &rest keyword-list
       &key &optional attribute value where &allow-other-keys
       &aux attributes values where-clause ss key attr card imp (num-modified 0) qtrieve-var dom-def
       tuples domains indices)
  "The values of the tuples in a relation can be modified using this function.

   RELATION  - Name of the relation whose tuples are to be modified.
   ATTRIBUTE - List of attributes which are to be modified.
   VALUE     - Corresponding list of values to be used in modifying the above attributes.
   WHERE     - Selection criterion to be used."
  attribute value where
  (block modify
(cond (*parameter-checking*
       (if (or (not (active-database)) (not (setf relation (validate-sym relation))))
   (return-from modify nil))
       (setf keyword-list (get-keyword-value-prereq '(where attr value)
    (de-nest-keyword-list keyword-list))))
      (t
       (setf keyword-list (de-nest-keyword-list keyword-list))))
   (setf attributes (car (get-keyword-value '(attr) keyword-list))
 values (car (get-keyword-value '(value) keyword-list))
 where-clause (or (car (get-keyword-value '(where) keyword-list)) t))
   (cond ((not attributes)
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The attribute list was not specified correctly"))
  (return-from modify nil))
 ((not values)
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The value list was not specified correctly"))
  (return-from modify nil)))
   (setf qtrieve-var (get-relation relation
   '("IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY" "ATTRIBUTES" "CARDINALITY")
   t))
   (setf relation (car qtrieve-var)
 qtrieve-var (cadr qtrieve-var))
   (cond ((null qtrieve-var)
  (if *provide-error-messages*
      (format *standard-output*  "~%ERROR - Relation ~s does not exist in the database ~s"
      relation *active-db*))
 (return-from modify nil)))
   (setf ss (cadr qtrieve-var)
 key (caddr qtrieve-var)
 attr (cadddr qtrieve-var)
 card (fifth qtrieve-var)
 imp (car qtrieve-var))
   ;;
   ;;1If only one attribute is provided then it is quite possible that it is an atom and a list.*
   ;;
   (if (not (listp  attributes))
       (setf attributes (list attributes)))
   (cond (*parameter-checking*
  (setf attributes (mapcar #'(lambda (attr)
       (validate-sym attr t))
   attributes))
  (if (member nil attributes)
      (return-from modify nil)))
 (t
  (setf attributes (convert-attributes attributes))))
  ;;
  ;;1The same is true for values.*
  ;;
  (if (not (listp  values))
      (setf values (list values)))
  ;;
  ;;1Make sure that the attributes provided are actually attributes (attr) of the relation.*
  ;;
   (cond (*parameter-checking*
  (mapc (function (lambda (%attr)
    (cond ((not (member %attr attr :test 'string-equal))
   (if *provide-error-messages*
       (format *standard-output*
       "~%ERROR - ~S is not an attribute in the relation ~S."
       %attr relation))
   (return-from modify nil)))))
attributes)
  (cond ((not (equal (length values) (length attributes)))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - Number of attributes ~S is not the same as the number of values ~S"
     attributes values))
 (return-from modify nil)))
   ;;
   ;;1  DOM-DEF is used to contain the information needed to determine if the modified value is within the domain of the*
   ;;1 attribute. This does not need to be performed if validity checking is NIL*
   ;;
  (setf dom-def (funcall (find-symbol (concatenate 'string "RETRIEVE-"
   *system-relation-base-implementation*
   "-" *system-relation-storage-structure*)
      *pkg-string*)
 'system-attribute *system-attribute-attributes*
 '("ATTRIBUTE-NAME" "DOMAIN-FUNCTION" "DEFAULT-VALUE") *system-attribute-key*
 (list 'string-equal 'relation-name (string-upcase relation)) nil
 'system-attribute))
  (setf domains (mapcar (function (lambda (domain)
    (second domain)))
dom-def))
  (setf dom-def
(mapcar #'(lambda (dom)
    (list (first dom) (read-from-string (concatenate 'string *pkg-name* (second dom)))
  (third dom)))
dom-def))))
   ;;
   ;;1  Must determine if there are any indices defined on this relation. If there are, the tuples must be deleted from the indices before they*
   ;1; are modified. After the modification is complete, the tuples modified are sent back. These must then be inserted.*
   ;;
   (cond ((setf indices (qtrieve 'system-index *system-index-attributes* '("2INDEX-NAME" *"2KEY" *"2INDEX-TYPE"*)
 *system-index-key* `(string-equal relation-name ,(string relation))))
  (mapc (function (lambda (index-element)
    (funcall (find-symbol (concatenate 'string2 *"2DELETE-"* imp "2-"* (third index-element))
  *pkg-string*)
    relation attr (second index-element) domains t
    (first index-element))))
indices)))
   ;;
   ;;1  Perform the modification on the tuples specified.*
   ;;
   (multiple-value-setq (num-modified tuples)
 (funcall (find-symbol (concatenate 'string "MODIFY-" imp "-" ss) *pkg-string*) relation attr key
  attributes values where-clause dom-def indices))
   (cond (indices
  (setf tuples (funcall (find-symbol (concatenate 'string "OBTAIN-TUPLES-2"* ss) *pkg-string*) relation))
  (mapc (function (lambda (index-element)
    (funcall (find-symbol (concatenate 'string2 *"2INDEX-INSERT-"* imp "2-"*
       (third index-element)) *pkg-string*)
     (first index-element) tuples attr (second index-element) relation)))
indices)))
   ;;
   ;;1  If at least a single tuple was modified, reflect this fact in the system-relation relation.*
   ;;
   (if (> num-modified 0)
       (progn
 (funcall (find-symbol (concatenate 'string "MODIFY-" *system-relation-base-implementation*
    "-" *system-relation-storage-structure*) *pkg-string*)
  'system-relation *system-relation-attributes* *system-relation-key* '("MODIFIEDP2"*) '(t)
  (list 'or '(string-equal relation-name "SYSTEM-RELATION")
`(string-equal relation-name ,(string relation)))
  nil nil)
 (if *provide-status-messages*
     (format *standard-output* "~%~S tuple~:P modified." num-modified)))
     (if *provide-status-messages*
 (format *standard-output* "~%No tuples modified.")))
   (return-from modify relation num-modified)))

(defun delete-flavor-heap (relation attribute-list rel-key domains where index-name
   &aux beginning-tuple-length conv-attribute-list (data (getp index-name 'entry-point))
   num-deleted temp-attribute-list tuples)
  rel-key domains index-name
  (cond ((or (equal where t)(equal where '(t)))
 (putp index-name nil 'entry-point)
 (setf num-deleted (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  `(string-equal relation-name ,(string relation))))))
(t
 (multiple-value-setq (where temp-attribute-list)
   (eval-where-prereq where attribute-list relation))
 (setf beginning-tuple-length (length data))
 (setf conv-attribute-list (project-flavor-prereq temp-attribute-list))
 (progv temp-attribute-list nil
   (setf tuples (delete-if (function (lambda (tuple)
       (mapc #'(lambda (attribute attribute-value)
 (set attribute attribute-value))
     temp-attribute-list
     (car (fast-project-flavor (list tuple)
       conv-attribute-list)))
       (if (eval where)
   tuple)))
   data)
 num-deleted (- beginning-tuple-length (length tuples))))
 (if (> num-deleted 0)
     (putp index-name tuples 'entry-point))))
  num-deleted)

(defun delete-struct-heap (relation attribute-list rel-key domains where index-name
   &aux beginning-tuple-length conv-attribute-list (data (getp index-name 'entry-point))
   num-deleted temp-attribute-list tuples (string-relation-name (string relation)))
  rel-key domains
  (cond ((or (equal where t)(equal where '(t)))
 (putp index-name nil 'entry-point)
 (setf num-deleted (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  `(string-equal relation-name ,string-relation-name)))))
(t
 (multiple-value-setq (where temp-attribute-list)
   (eval-where-prereq where attribute-list relation))
 (setf beginning-tuple-length (length data))
 (setf conv-attribute-list (unconvert-attributes
     (mapcar #'(lambda (attr)
 (concatenate 'string string-relation-name attr))
     attribute-list)))
 (progv temp-attribute-list nil
   (setf tuples (delete-if (function (lambda (tuple)
       (mapc #'(lambda (attribute attribute-value)
 (set attribute attribute-value))
     temp-attribute-list
     (car (fast-project-struct (list tuple)
       conv-attribute-list)))
       (if (eval where)
   tuple)))
   data)
 num-deleted (- beginning-tuple-length (length tuples))))
 (if (> num-deleted 0)
     (putp index-name tuples 'entry-point))))
  num-deleted)

(defun delete-heap (relation rel-attributes rel-key domains where imp  index-name
    &aux beginning-tuple-length (data (getp index-name 'entry-point))
    (num-deleted 0) temp-attribute-list tuples)
  rel-key domains imp
  (cond ((or (equal where t)(equal where '(t)))
 (putp index-name nil 'entry-point)
 (setf num-deleted (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  `(string-equal relation-name ,(string relation))))))
(t
 (multiple-value-setq (where temp-attribute-list)
   (eval-where-prereq where rel-attributes relation))
 (setf beginning-tuple-length (length data))
 (progv temp-attribute-list nil
   (setf tuples (delete-if (function (lambda (tuple)
       (mapc #'(lambda (x z)
 (set x z))
     temp-attribute-list tuple)
       (eval where)))
   data)
 num-deleted (- beginning-tuple-length (length tuples))))))
  (if (> num-deleted 0)
      (putp index-name tuples 'entry-point))
  num-deleted)


(defun delete-list-heap (relation rel-attributes rel-key domains where index-name)
  (delete-heap relation rel-attributes rel-key domains where "list" index-name))

(defun delete-flavor-hash (relation rel-attributes rel-key domains where index-name)
  (delete-hash relation rel-attributes rel-key domains where "flavor" index-name))

(defun delete-struct-hash (relation rel-attributes rel-key domains where index-name)
  (delete-hash relation rel-attributes rel-key domains where "struct" index-name))

(defun delete-list-hash (relation rel-attributes rel-key domains where index-name)
  (delete-hash relation rel-attributes rel-key domains where "list" index-name))

(defun delete-hash (relation rel-attributes rel-key domains where imp index-name
    &aux (bucket nil) (sec-keys nil) (num-deleted 0) package-name
    (table (getp index-name 'entry-point)) temp-attribute-list conv-attribute-list tuples
    (string-relation-name (string relation)))
  domains
 (block delete-hash
  (cond ((or (equal where t)(equal where '(t)))
 (clrhash (getp index-name 'entry-point))
 (return-from delete-hash (caar (retrieve 'system-relation 'project '("CARDINALITY")
 'where `(string-equal relation-name ,(string-upcase relation)) 'tuples t)))))
  (cond ((symbolp relation)
 (setf package-name (package-name (symbol-package relation))))
(t
 (setf package-name *pkg-string*)))
  (setf sec-keys (extract-key-hash rel-attributes rel-key nil where package-name))
  (multiple-value-setq (where temp-attribute-list)
    (eval-where-prereq where rel-attributes relation))
  (cond ((string-equal (string-upcase imp) "FLAVOR")
 (setf conv-attribute-list (project-flavor-prereq rel-attributes)))
((string-equal (string-upcase imp) "STRUCT")
 (setf conv-attribute-list (unconvert-attributes (mapcar #'(lambda (attr)
     (concatenate 'string string-relation-name
  attr))
 rel-attributes)))))
  (setf bucket (mapcar (function (lambda (sec-key)
   (gethash sec-key table)))
       sec-keys))
  (if bucket
      (mapc (function (lambda (%bucket sec-key
       &aux (not-deleted nil) (del? nil))
   (cond ((string-equal (string-upcase imp) "FLAVOR")
  (setf tuples (fast-project-flavor %bucket conv-attribute-list)))
 ((string-equal (string-upcase imp) "STRUCT")
  (setf tuples (fast-project-struct %bucket conv-attribute-list)))
 (t
  (setf tuples %bucket)))
   (mapc #'(lambda (tup %tup)
     (if (or (equal where t) (fast-eval-where (list tup) where temp-attribute-list))
 (setf del? t
       not-deleted (if not-deleted
       (remove %tup not-deleted :test 'equal)
       (remove %tup %bucket :test 'equal)))))
 tuples %bucket)
   (if del?
       (progn
 (setf num-deleted (+ (- (length %bucket) (length not-deleted)) num-deleted))
 (if not-deleted
     (setf (gethash sec-key table) not-deleted)
     (remhash sec-key table))))))
    bucket sec-keys)
    (maphash (function (lambda (hash-key %bucket &aux (not-deleted nil) (del? nil))
  (cond ((string-equal (string-upcase imp) "FLAVOR")
  (setf tuples (fast-project-flavor %bucket conv-attribute-list)))
 ((string-equal (string-upcase imp) "STRUCT")
  (setf tuples (fast-project-struct %bucket conv-attribute-list)))
 (t
  (setf tuples %bucket)))
                  (mapc #'(lambda (tup %tup)
    (if (or (equal where t) (fast-eval-where (list tup) where temp-attribute-list))
(setf del? t
      not-deleted (if not-deleted
      (remove %tup not-deleted :test 'equal)
      (remove %tup %bucket :test 'equal)))))
     tuples %bucket)
  (if del?
      (progn
(setf num-deleted (+ (- (length %bucket) (length not-deleted)) num-deleted))
(if not-deleted
    (setf (gethash hash-key table) not-deleted)
    (remhash hash-key table))))))
     table))
  (return-from delete-hash num-deleted)))


(defun modify-flavor-heap (relation rel-attributes rel-key attributes values where dom-def indices
   &aux (num-modified 0) new-heap-list delormod? (tuples nil) atom-rel-attributes
   atom-attributes flavor-package temp-attribute-list data conv-rel-attributes)
  rel-key
  (cond ((not (listp where))
 (if (eval where)
     (setf where t)
     (values 0 nil))))
  (multiple-value-setq (where temp-attribute-list)
    (eval-where-prereq where rel-attributes relation))
  (setf flavor-package (package-name (symbol-package (typep (car (getp relation 'entry-point))))))
  (setf atom-rel-attributes (unconvert-attributes rel-attributes flavor-package)
atom-attributes (unconvert-attributes attributes flavor-package))
  (setf conv-rel-attributes (project-flavor-prereq rel-attributes))
  (setf data (fast-project-flavor (reverse (getp relation 'entry-point)) conv-rel-attributes))
  (cond (indices
 (mapcar (function (lambda (tuple a-tuple)
     (setf delormod? nil)
     (cond ((or (equal where t)
(fast-eval-where (list a-tuple) where temp-attribute-list))
    (mapcar
      (function
(lambda (attr val &aux tempval)
  (setf tempval
(eval (sublis
(form-alist (quote-tuple a-tuple) atom-rel-attributes)
val)))
  (cond ((or (member (string-upcase relation) *system-relations*
     :test 'string-equal)
     (not *validity-checking*)
     (dom-check tempval attr dom-def))
 (setf delormod? t)
 (set-in-instance tuple attr tempval)))))
      atom-attributes values)
    (setf new-heap-list (cons tuple new-heap-list))
    (if delormod?
(setf num-modified (+ 1 num-modified)))
    (setf tuples (cons tuple tuples)))
   (t
    (setf new-heap-list (cons tuple new-heap-list))))))
 (reverse (getp relation 'entry-point))
 data))
(t
 (mapc (function (lambda (tuple a-tuple)
   (setf delormod? nil)
   (cond ((or (equal where t)(fast-eval-where (list a-tuple) where temp-attribute-list))
  (mapcar
    (function
      (lambda (attr val &aux tempval)
(setf tempval
      (eval (sublis
      (form-alist (quote-tuple a-tuple) atom-rel-attributes)
      val)))
(cond ((or (member (string-upcase relation) *system-relations*
    :test 'string-equal)
   (not *validity-checking*)
   (dom-check tempval attr dom-def))
       (setf delormod? t)
       (set-in-instance tuple attr tempval)))))
    atom-attributes values)
  (setf new-heap-list (cons tuple new-heap-list))
  (if delormod?
      (setf num-modified (+ 1 num-modified))))
 (t (setf new-heap-list (cons tuple new-heap-list))))))
       (reverse (getp relation 'entry-point))
       data)))
  (putp relation new-heap-list 'entry-point)
  (values num-modified tuples))

(defun modify-struct-heap (relation rel-attributes rel-key attributes values where dom-def indices
   &aux (num-modified 0) new-heap-list temp-struct delormod?
   atom-rel-attributes atom-attributes temp-attribute-list struct-rel-attributes
   struct-attributes (modified-tuples nil) (string-relation-name (string relation)))
  rel-key
  (cond ((not (listp where))
 (if (eval where)
     (setf where t)
     (values 0 nil))))
  (multiple-value-setq (where temp-attribute-list)
    (eval-where-prereq where rel-attributes relation))
  (setf struct-rel-attributes (unconvert-attributes (mapcar #'(lambda (attr)
    (concatenate 'string string-relation-name attr))
rel-attributes))
struct-attributes (unconvert-attributes (mapcar #'(lambda (attr)
    (concatenate 'string string-relation-name attr))
attributes)))
  (setf atom-rel-attributes (unconvert-attributes rel-attributes)
atom-attributes (unconvert-attributes attributes))
  (cond (indices
 (mapcar (function (lambda (struct-tuple)
     (setf delormod? nil)
     (setf temp-struct (mapcar (function (lambda (attr)
   (funcall attr struct-tuple)))
       struct-rel-attributes))
     (cond ((or (equal where t)
(fast-eval-where (list temp-struct) where temp-attribute-list))
    (mapc (function (lambda (attr val struct-attr &aux tempval)
      (setf tempval (eval (sublis
    (form-alist
      (quote-tuple temp-struct)
      atom-rel-attributes)
    val)))
      (if (or (member (string-upcase relation)
      *system-relations* :test 'string-equal)
      (not *validity-checking*)
      (dom-check tempval attr dom-def))
  (progn
    (setf delormod? t)
    (eval `(setf (,struct-attr ,struct-tuple)
 ',tempval))))))
  atom-attributes values struct-attributes)
    (setf new-heap-list (cons struct-tuple new-heap-list))
    (if delormod?
(setf num-modified (+ 1 num-modified)))
    (setf modified-tuples (cons struct-tuple modified-tuples)))
   (t
    (setf new-heap-list (cons struct-tuple new-heap-list))))))
 (reverse (getp relation 'entry-point))))
(t
 (mapcar (function (lambda (struct-tuple)
     (setf delormod? nil)
     (setf temp-struct (mapcar (function (lambda (attr)
   (funcall attr struct-tuple)))
       struct-rel-attributes))
     (cond ((or (equal where t)
(fast-eval-where (list temp-struct) where temp-attribute-list))
    (mapc (function (lambda (attr val struct-attr &aux tempval)
      (setf tempval (eval (sublis
    (form-alist
      (quote-tuple temp-struct)
      atom-rel-attributes)
    val)))
      (if (or (member (string-upcase relation)
      *system-relations* :test 'string-equal)
      (not *validity-checking*)
      (dom-check tempval attr dom-def))
  (progn
    (setf delormod? t)
    (eval `(setf (,struct-attr ,struct-tuple)
 ',tempval))))))
  atom-attributes values struct-attributes)
    (setf new-heap-list (cons struct-tuple new-heap-list))
    (if delormod?
(setf num-modified (+ 1 num-modified))))
   (t
    (setf new-heap-list (cons struct-tuple new-heap-list))))))
 (reverse (getp relation 'entry-point)))))
  (putp relation new-heap-list 'entry-point)
  (values num-modified modified-tuples))

(defun modify-list-heap (relation attribute-list rel-key attributes values where dom-def indices
 &aux modify-list (num-modified 0) new-heap-list delormod?
 temp-attribute-list (modified-tuples nil))
  rel-key
  (cond ((not (listp where))
 (if (eval where)
     (setf where t)
     (values 0 nil))))
  (multiple-value-setq (where temp-attribute-list)
    (eval-where-prereq where attribute-list relation))
  (do ((modify-value values (cdr modify-value)))
      ((null modify-value) t)
    (if (and (listp (car modify-value)) (not (equal (car modify-value) t)))
(setf modify-list (cons (parse-where (car modify-value)) modify-list))
(setf modify-list (cons (car modify-value) modify-list))))
  (setf modify-list (reverse modify-list))
  (progv temp-attribute-list nil
    (cond (indices
   (mapc (function (lambda (tuple &aux new-tuple)
       (setf delormod? nil)
       (cond ((or (equal where t)
  (super-fast-eval-where (list tuple) temp-attribute-list where))
      (setf new-heap-list (cons (setf new-tuple
      (modify-tuple attribute-list
attributes tuple
modify-list dom-def
relation temp-attribute-list))
new-heap-list))
      (if (not (equal tuple new-tuple))
  (setf num-modified (+ 1 num-modified)))
      (setf modified-tuples (cons new-tuple modified-tuples)))
     (t
      (setf new-heap-list (cons tuple new-heap-list))))))
   (reverse (getp relation 'entry-point))))
  (t
   (mapc (function (lambda (tuple &aux new-tuple)
     (setf delormod? nil)
     (cond ((or (equal where t)
(super-fast-eval-where (list tuple) temp-attribute-list where))
    (setf new-heap-list (cons (setf new-tuple
    (modify-tuple attribute-list
      attributes tuple modify-list dom-def
      relation temp-attribute-list))
      new-heap-list))
    (if (not (equal tuple new-tuple))
(setf num-modified (+ 1 num-modified))))
   (t
    (setf new-heap-list (cons tuple new-heap-list))))))
 (reverse (getp relation 'entry-point))))))
  (putp relation new-heap-list 'entry-point)
  (values num-modified modified-tuples))

(defun modify-flavor-hash (relation rel-attributes rel-key attributes values where dom-def indices)
  (modify-hash relation where rel-key rel-attributes attributes values "FLAVOR" dom-def indices))

(defun modify-struct-hash (relation rel-attributes rel-key attributes values where dom-def indices)
  (modify-hash relation where rel-key rel-attributes attributes values "STRUCT" dom-def indices))

(defun modify-list-hash (relation rel-attributes rel-key attributes values where dom-def indices)
  (modify-hash relation where rel-key rel-attributes attributes values "LIST" dom-def indices))

(defun modify-hash (relation where-clause key attribute-list attributes values imp dom-def indices
    &aux (bucket nil) (sec-keys nil) (num-modified 0) (result nil) hash-tuples
    num-bucket-modified (table (getp relation 'entry-point)) modify-list temp-attribute-list
    atom-attributes uncon-attr conv-attribute-list struct-rel-attributes package-name
    struct-attributes modify-clause (modified-tuples nil) (modify-tuples nil)
    (string-relation-name (string relation)))
  indices
  (setf imp (find-symbol (concatenate 'string imp "-BUCKET") *pkg-string*))
  (cond ((symbolp relation)
 (setf package-name (package-name (symbol-package relation))))
(t
 (setf package-name *pkg-string*)))
  (if (or (equal where-clause t)(equal where-clause nil))
      (setf sec-keys nil)
      (setf sec-keys (extract-key-hash attribute-list key nil where-clause package-name)))
  (setf bucket (mapcar (function (lambda (sec-key)
    (gethash sec-key table)))
sec-keys))
  (multiple-value-setq (where-clause temp-attribute-list)
    (eval-where-prereq where-clause attribute-list relation))
  (do ((modify-value values (cdr modify-value)))
      ((null modify-value) t)
    (cond ((listp (car modify-value))
   (multiple-value-setq (modify-clause temp-attribute-list)
     (eval-where-prereq (car modify-value) attribute-list relation))
   (setf modify-list (append (list modify-clause) modify-list)))
  (t
   (setf modify-list (append (list (car modify-value)) modify-list)))))
  (setf modify-list (reverse modify-list))
  (setf struct-rel-attributes (unconvert-attributes (mapcar #'(lambda (attr)
(concatenate 'string string-relation-name
     (string-upcase attr)))
    attribute-list))
struct-attributes (unconvert-attributes (mapcar #'(lambda (attr)
    (concatenate 'string string-relation-name
 (string-upcase attr)))
attributes)))
  (setf atom-attributes (unconvert-attributes attribute-list))
  (setf uncon-attr (unconvert-attributes attributes))
  (setf conv-attribute-list (project-flavor-prereq attribute-list))
  (progv temp-attribute-list nil
    (cond (bucket
   (mapc (function (lambda (%bucket sec-key)
     (multiple-value-setq (num-bucket-modified modify-tuples)
       (funcall imp relation where-clause sec-key result attributes values %bucket
attribute-list key dom-def temp-attribute-list atom-attributes
uncon-attr table conv-attribute-list struct-rel-attributes
struct-attributes))
     (setf num-modified (+ num-bucket-modified num-modified))
     (cond ((and modify-tuples (car modify-tuples))
    (setf modified-tuples (append modify-tuples modified-tuples))))))
 bucket sec-keys))
  (t
   (setf hash-tuples nil)
   (maphash (function (lambda (hash-key tuple-list)
(setf hash-tuples (cons (list hash-key tuple-list) hash-tuples))))
    table)
   (mapc (function (lambda (x &aux mod-bucket)
     ;;1Some of the bucket entries might be due to the modified tuples !*
     (setf result (firstn (- (length (setf mod-bucket (gethash (car x) table)))
     (length (cadr x))) mod-bucket))
     (multiple-value-setq (num-bucket-modified modify-tuples)
       (funcall imp relation where-clause (car x) result attributes values (cadr x)
attribute-list key dom-def temp-attribute-list atom-attributes
uncon-attr table conv-attribute-list struct-rel-attributes
struct-attributes))
     (setf num-modified (+ num-bucket-modified num-modified))
     (cond ((and modify-tuples (car modify-tuples))
    (setf modified-tuples (append modify-tuples modified-tuples))))))
 hash-tuples))))
  (values num-modified modified-tuples))


(defun flavor-bucket (relation where-clause key result attributes values bucket attribute-list key-attr dom-def
      temp-attribute-list atom-attributes uncon-attr table conv-attribute-list
      struct-rel-attributes struct-attributes
      &aux new-key key-modp (num-modified 0) delormod? data)
  struct-rel-attributes struct-attributes attribute-list
  (cond ((not (listp where-clause))
 (if (eval where-clause)
     (setf where-clause t)
     (values 0 nil))))
  (setf data (fast-project-flavor bucket conv-attribute-list))
  (mapc (function (lambda (tuple a-tuple &aux c-tuple)
    (setf new-key nil
  delormod? nil)
    (cond ((or (equal where-clause t)
       (super-fast-eval-where (list a-tuple) temp-attribute-list where-clause))
   (mapcar
     (function (lambda (attr val &aux tempval)
 (setf tempval (eval (sublis
       (form-alist (quote-tuple a-tuple)
   atom-attributes)
       val)))
 (setf c-tuple (append c-tuple (list tempval)))
 (if (or (member (string-upcase relation) *system-relations*
 :test 'string-equal)
 (not *validity-checking*)
 (dom-check tempval attr dom-def))
     (progn
       (setf delormod? t)
       (set-in-instance tuple attr tempval)))))
     uncon-attr values)
   (setf key-modp nil)
   ;;1key-attr --- the actual key attributes for this relation.*
   ;;1key      --- the key value for this bucket.*
   ;;1c-tuple  --- the modification values which are evaluated. *
   (mapcar
     (function
       (lambda (attr val &aux temp)
 (if (and (member attr attributes :test 'string-equal)
  (car (errset
 (setf temp (nth (position attr attributes :test 'equal)
 c-tuple))
 nil))
  (not (equal temp val)))
     (progn
       (setf key-modp t)
       (setf new-key (cons temp new-key)))
     (setf new-key (cons val new-key)))))
     (reverse key-attr)
     (reverse key))
   (if key-modp
       (setf (gethash new-key table) (cons tuple (gethash new-key table)))
       (setf result (cons tuple result)))
   (if delormod?
       (setf num-modified (+ 1 num-modified))))
  (t
   (setf result (cons tuple result))))))
bucket data)
  (if result
      (setf (gethash key table) result)
    (remhash key table))
  (values num-modified result))

(defun struct-bucket (relation where-clause key result attributes values bucket attribute-list key-attr dom-def
      temp-attribute-list atom-attributes uncon-attr table conv-attribute-list
      struct-rel-attributes struct-attributes
      &aux key-modp new-key temp-struct (num-modified 0) delormod? tuples)
  conv-attribute-list attribute-list
  (cond ((not (listp where-clause))
 (if (eval where-clause)
     (setf where-clause t)
     (values 0 nil))))
  (mapc (function (lambda (struct-tuple &aux c-tuple)
    (setf new-key nil delormod? nil)
    (setf temp-struct (mapcar (function (lambda (struct-attr)
  (funcall struct-attr struct-tuple)))
      struct-rel-attributes))
    (cond ((or (equal where-clause t)
       (super-fast-eval-where (list temp-struct) temp-attribute-list where-clause))
   (mapc (function (lambda (struct-attr struct-val rel-attr &aux tempval)
     (setf tempval (eval (sublis
   (form-alist (quote-tuple temp-struct)
       atom-attributes)
   struct-val)))
     (setf c-tuple (append c-tuple (list tempval)))
     (if (or (member (string-upcase relation) *system-relations*
     :test 'string-equal)
     (not *validity-checking*)
     (dom-check tempval struct-attr dom-def))
 (progn
   (setf delormod? t)
   (eval `(setf (,rel-attr ,struct-tuple) ',tempval))))))
 uncon-attr values struct-attributes)
   (setf key-modp nil)
   (mapc (function (lambda (attr val &aux temp)
     (if (and (member attr attributes :test 'string-equal)
      (setf temp (car(errset (nth
       (- (length attributes)
  (length (member
    attr
    attributes
    :test
    'string-equal)))
     c-tuple)
   nil)))
      (not (equal temp val)))
 (progn
   (setf key-modp t)
   (setf new-key (cons temp new-key)))
 (setf new-key (cons val new-key)))))
 (reverse key-attr)
 (reverse key))
   (if key-modp
       (setf (gethash new-key table) (cons struct-tuple (gethash new-key table)))
       (setf result (cons struct-tuple result)))
   (if delormod?
       (setf num-modified (+ 1 num-modified))))
  (t (setf result (cons struct-tuple result))))
    (setf tuples (append struct-tuple tuples))))
bucket)
  (if result
      (setf (gethash key table) result)
    (remhash key table))
  (values num-modified tuples))


(defun list-bucket (relation where-clause key result attributes values bucket attribute-list key-attr dom-def
    temp-attribute-list atom-attributes uncon-attr table conv-attribute-list
    struct-rel-attributes struct-attributes
    &aux new-key key-modp (num-modified 0) delormod? (tuples nil))
  relation conv-attribute-list struct-rel-attributes struct-attributes attribute-list
  (cond ((not (listp where-clause))
 (if (eval where-clause)
     (setf where-clause t)
     (values 0 nil))))
  (setf tuples (mapcar
 (function (lambda (tuple)
     (setf new-key nil
   delormod? nil)
     (cond ((or (equal where-clause t)
(super-fast-eval-where (list tuple) temp-attribute-list
       where-clause))
    (setf key-modp nil)
    (mapc
      (function (lambda (attr val &aux temp)
  (if (and (member attr attributes :test 'string-equal)
   (setf temp
 (eval
   (sublis
     (form-alist
       (quote-tuple tuple)
       atom-attributes)
     (car (errset
    (nth (position attr attributes
   :test 'equal) values)
    nil)))))
   (not (equal temp val)))
      (progn
(setf key-modp t)
(setf new-key (cons temp new-key)))
      (setf new-key (cons val new-key)))))
      (reverse key-attr) (reverse key))
    (cond (key-modp
   (setf key-modp (modify-tuple atom-attributes uncon-attr tuple values
dom-def relation temp-attribute-list))
   (setf (gethash new-key table)
 (cons key-modp (gethash new-key table))))
  (t
   (setf result
 (cons (setf key-modp
     (modify-tuple atom-attributes uncon-attr tuple
   values dom-def relation
   temp-attribute-list))
       result))))
    (if (not (equal key-modp tuple))
(setf num-modified (+ 1 num-modified))))
   (t (setf result (cons tuple result))))
     key-modp))
 bucket))
  (if result
      (setf (gethash key table) result)
      (remhash key table))
  (values num-modified tuples))
al temp-key temp-val)
  ;;
  ;;1 Loop until all of the sub-clauses of the where-clause have been processed.*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond ((listp (car where-clause))
   ;;
   ;;1  The element is a list, must be a function call. Call the appropriate optimization function if one exists. Add the results from*
   ;1; the function to the current results. The optimization functions which are defined by RTMS initially are used as selections in*
   ;1; the following COND clause to improve the speed of calling these functions. If the function in the sub-clause is not from this*
   ;1; group, the function name must be formed before it can be invoked.*
   ;;
   (cond ((setf opt-func LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540685. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DELETE-MODIFY" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360164. :AUTHOR "REL3" :LENGTH-IN-BYTES 10094. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8DELETE-MODIFY\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPCFORM-ALIST@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÀTUPLECATTRIBUTESB:\ÀALISTATT-LISTVAL-LIST\)MACROS-EXPANDED\PROGSETFQQBA	ASBS
C@]@ABA@OkBPQUOTE-TUPLE@LF$B:BV]FB:B:B:BYFB^Bl\B`B:B:\Bg\pB\lXR-BQ-LISTBipZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSB8LIST@рQBAAQPBSCABB@OBlCDOM-CHECK8@F%$B:BV]FB:B:B:BYFB^B\ÀVALUEATTRDOM-DEFB:\TEMPB:\Bg\BjSECONDC*PROVIDE-WARNING-MESSAGES*у*PKG-STRING*у*RESTORE-OPERATION*у*VALIDITY-CHECKING*STRINGҪSTRING-EQUALpB\lASSOC-TESTSTRING-UPCASEINTERNTERPRIlWARNING - WRITE-STRINGPRIN1 is not a legal value for the  attribute whose domain is "QQP	@B
PAQAPQPQP@WRSOBMODIFY-TUPLE;AF$$B:BV]FB:B:B:BYFB^B\ÁATTRIBUTE-LISTCMODIFY-ATTRIBUTESB`VALUESBÁRELATION-NAMETEMP-ATTRIBUTE-LISTB:\TEMPVALTEMP-RESULTCATTRIBUTETUPLE-VALUE\Bg\BjBiBу*PARAMETER-CHECKING*C*SYSTEM-RELATIONS*BpB\MEMBER-TESTEQUALpB\lPOSITION*CMODIFY-EVAL-WHEREB*REVERSEQQCB&BSQPQBSQP	QCQ
@QPP	@QBSQ@QCSA]ABCBAQOBB@F$B:BV]FB:B:B:BYFB^B\BeWHERE-CLAUSEBB:B:\Bg\BiB{EVALQQA@@SAS@A@AQOBÁDELETE-TUPLES:f`:|F$B:BV]FB:B:B:BYFB^B\RELATION&RESTKEYWORD-LIST&KEYj&OPTIONALÀWHEREj&ALLOW-OTHER-KEYSB:\BBBɃQTRIEVE-VARCSSÁKEY-ATTRIBUTESBaCARDIMPNUM-DELETEDDOMAINSB:B:CINDEX-INFOB:\Bg\
BxBiB{SIXTHFIFTHFOURTHTHIRDBFIRSTBjDOCUMENTATIONlDeletes the tuples which satisfy the WHERE clause from the specified relation.

   RELATION - Name of the relation from which the tuples are to be deleted.
   WHERE    - Selection criterion to be used.C*PROVIDE-STATUS-MESSAGES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*Bу*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*B\WHEREpB\STORE-KEYARGS҃DE-NEST-KEYWORD-LISTACTIVE-DATABASE҃VALIDATE-SYM\BGET-KEYWORD-VALUE-PREREQCGET-KEYWORD-VALUE\IMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYlATTRIBUTESCARDINALITY,DOMAINSGET-RELATIONBlERROR - Relation BB*READ-FROM-STRINGB, does not exist in the database ERROR - No where clause specified, no tuples deletedBB,DELETE-l-CONCATENATEҪFIND-SYMBOL҃SYSTEM-INDEX\lINDEX-NAMElINDEX-TYPEKEYBBBB~QTRIEVE,MODIFY-SYSTEM-RELATION\lMODIFIEDP\BY\BB,SYSTEM-RELATION\lMODIFIEDPCARDINALITYB tupleesjWRITE-CHARl deleted.lNo tuples deleted@@QPAI@Q@QRP@Q@P@QBBQPCCSCWCPQPPRCSHCWDC[ECQBFCUBGCYBJIBPRB5BQ B!"P#PHQ$PDQ%
P&KQFQEQJQBQQKII=['P	P(PP)P*PQ+,-LLSM"P#PHQ$PMW%
P&NQFQM[JQBQMSNL"P.PP$PP%
P&N/PPP0P1P2PJN"P.PP$PP%
P&N/PPP3PGQIc,4P*PQ+,JNIQ5PJI'6P78P9PQIQO)BÀMODIFYO*ÁMODIFY-TUPLESDELETE-OR-MODIFY/xFI$B:BV]FB:B:B:BYFB^B,\BCDEL-OR-MODBBBaBB:B:B:C*PKG-NAME*BBBBBBBB,MODIFY-l-BBl*-attributes*B-key*BBaBB*,DELETE-BΒ2QP	P
#PPPPPP@QPPPQPCPPPQPCQQQJ@QPQPQPQJQP	P
 PPPPPP@QPPPQPCPPPQPCۂQQ@QPQO=B,B*LL@F
$B:BV]FB:B:B:BYFB^B*\	BBBBBBBBBB:\BBBBBaBBBKEYBBBチNUM-MODIFIEDBBÀTUPLESBINDICESB:B:B:À%ATTRB:DOMÁINDEX-ELEMENT\Bg\	BxBBBBiB{B}BBjBThe values of the tuples in a relation can be modified using this function.

   RELATION  - Name of the relation whose tuples are to be modified.
   ATTRIBUTE - List of attributes which are to be modified.
   VALUE     - Corresponding list of values to be used in modifying the above attributes.
   WHERE     - Selection criterion to be used. BBBBBB6Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*BBBBBB\iATTRIBUTEVALUEBBBB\BBBBB\BB\B\BBERROR - The attribute list was not specified correctlyBlERROR - The value list was not specified correctly\IMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYlATTRIBUTESCARDINALITYB
lERROR - Relation B, does not exist in the database B~CCONVERT-ATTRIBUTESBB,ERROR -  is not an attribute in the relation e.B&ERROR - Number of attributes l is not the same as the number of values BlRETRIEVE-l-BBSYSTEM-ATTRIBUTE\ATTRIBUTE-NAME,DOMAIN-FUNCTIONDEFAULT-VALUEBBBB\lINDEX-NAMEKEYlINDEX-TYPEBB,DELETE-,MODIFY-FOBTAIN-TUPLES-INDEX-INSERT-B\lMODIFIEDP\BYjOR\BB,SYSTEM-RELATION tupleB%l modified.No tuples modified.@@QPALQRP@Q@Q@P@QBDP@QBEP@QBFDPRE PRQ!P"MMSMWM	#PQ$%PP$RMWGM[HMQBIMUBJMSKD5DQ&DRDQTSSQTSCSTTRQDDRDQ'DE5EQ&ElDQSSSUIQ(P)*PUQ$+PQ$,P-RSEQCDQC|	.PDQ$/PEQ$R0P1PP2PP3P4T5PP6P
P(P7PQ8&5PJTNTTNQRVVQRSBCVRRTQPVVNQSRRQSSWWS0P	PWW39W[&CRSSVQN:PP;PP(P7PQ<&=QQQTTSX0P>PKQ2PX[3P4SQIQXWPQXSST0P?PKQ2PGQ3P4VQIQHQDQEQFQNQQQ@PVQAOLQ 0PAPGQ3P4VQVOQQTTSX0PBPKQ2PX[3P4SXSOQIQXWQSTL=(0P?PP2PP3P4VCPPPDPEPFPGP(P7PQ<&&JVLQ$HPJL'IP-JPKPQLQOB*CDELETE-FLAVOR-HEAP&cAF=$B:BV]FB:B:B:BYFB^B\BBREL-KEYBBCINDEX-NAMEB:\B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGÂBEGINNING-TUPLE-LENGTHCONV-ATTRIBUTE-LISTDATABBBIB:B:\Bg\UNLESSBxBjINTERNAL-FEF-OFFSETS\FiVARIABLES-USED-IN-LEXICAL-CLOSURES\BBB܀BB򑃁ENTRY-POINTGETP\BYPUTPB\CARDINALITYBBBB~BFCEVAL-WHERE-PREREQÂPROJECT-FLAVOR-PREREQjMAKUNBOUND\FF
F\)INTERNALBpB\lDELETE-IF*QPHQQ*QP	PP
PPPPQBIIQQQPPAJHQCFJQGJQLCLLSCMSMLSLMPPCHQKFQKQCcII=QKQPIOBB@TF$B:BV]FB:B:B:BYFB^B\B`B:\B:B:BB:B:\Bg\BiB{iLEXICAL-PARENT-DEBUG-INFOBB~҃FAST-PROJECT-FLAVORB̒PQPBDCCSDSCDCDPROBCDELETE-STRUCT-HEAP0zFJ$B:BV]FB:B:B:BYFB^B\BBBBBBB:\B:B:BBBBBBBBBBISTRING-RELATION-NAMEB:B:B:\Bg\BBiB{B}BxBjB\FB\BBBÀBBBBB\BYBB\CARDINALITYBBB~BFBBB҃UNCONVERT-ATTRIBUTESB\FF
F\BBBQPHQLQQ	*QP
PPPPPPLQBIIQQQPPAJHQCFMсQON	NQPLQOSCNOOMQGJQONCNNSCOSONSNOPPCHQKFQKQCcII=QKQP
IOBB@TF$B:BV]FB:B:B:BYFB^B\B`B:\B:B:BB:B:\Bg\BiB{BBB~҃FAST-PROJECT-STRUCTB̒PQPBDCCSDSCDCDPROBDELETE-HEAP%`AF;$B:BV]FB:B:B:BYFB^B\BÁREL-ATTRIBUTESBBBBBB:\B:B:BBBBBBBBBIB:B:\Bg\BBxBjB\FB\BB܀BBBB\BYBB\CARDINALITYBBBB~BFBB\FF	\BBBQPGH߄QQ*QP	PP
PPPPQBH'QQQPPAIGQCFIQKCKKSCLSLKSKLPPCGQJFQJQCcHH=QJQPHOBB
@TF$B:BV]FB:B:B:BYFB^B
\B`B:\B:B:BB:B:\Bg\BiB{BBB̒PQDCCSDSCDCDPOB
DELETE-LIST-HEAPF
$B:BV]FB:B:B:BYFB^B\BBBBBBB:B:B:listBQQQQQPQJO#BCDELETE-FLAVOR-HASHF
$B:BV]FB:B:B:BYFB^B$\BBBBBBB:B:B:flavorDELETE-HASHQQQQQPQJO/B$CDELETE-STRUCT-HASHF
$B:BV]FB:B:B:BYFB^B0\BBBBBBB:B:B:structB.QQQQQPQJO:B0DELETE-LIST-HASHF
$B:BV]FB:B:B:BYFB^B;\BBBBBBB:B:B:listB.QQQQQPQJOEB;B.*f*F$B:BV]FB:B:B:BYFB^B.\BBBBBBBB:\B:B:BBBBÀBUCKETSEC-KEYSB䪁PACKAGE-NAMEÀTABLEBBBIBB:B:B:B:%BUCKETSEC-KEYNOT-DELETEDDEL?B:B:TUP%TUP\Bg\BiB{B}BjBxB\F(B\BIBBBRBBBBBBB\BY*CLRHASHBPROJECT\CARDINALITYBBBBB~BIRETRIEVEBQEXTRACT-KEY-HASHFBFLAVORpB\STRING-EQUAL*BSTRUCTBBB*GETHASHBBFAST-EVAL-WHEREBpB\,REMOVE*pB\,SETHASH*REMHASH\FFFF
F\BB.*MAPHASHH߆QPJQNQQ*QP	
PPPPPPQPJBQCPIQQۄQIQGQQQPPAKQPQQPOсQQP	PQPNQQSCPQQOQLQQGQORRQOSJQCROOQQFZFQGQQPQPSQSTSUVۅQPSQLQ 
QPSQLQ!SQMSQXWWSXSZYQYQQKQ"
VZQUUQSQ#P$UWXWXVSQCUQCcHaHUTQJQUQ%TQJQ&PQPQH'P(PCJQ)HO~B.B{$W@F3$B:BV]FB:B:B:BYFB^B{\HASH-KEYBSB:\	B:B:BBUBVB:B:BWBX\Bg\BiB{BjBBKBFLAVORBiBSTRUCTBB~BlBBnBpBqPPQP
PPQPQQFEESFSHGPGQ	PP

DHQCCQQPCEFEFDQCCQCc`CQPCQQPRO
B{CMODIFY-FLAVOR-HEAPw
F$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:\BHÁNEW-HEAP-LISTCDELORMOD?BIATOM-REL-ATTRIBUTESATOM-ATTRIBUTESÁFLAVOR-PACKAGEBBCONV-REL-ATTRIBUTESB:B:B:B:B`A-TUPLEB:B:B:B:BVALB\Bg\BiB{B}BjBBBFBBBTYPEPBQBBBBB~BlBlBPpB\,SUBLIS*BBBBpBT,SET-IN-INSTANCEB@߅5Q݅QQQPPAGQ	P
BCFQFQDQFQEQIQ	P
IQHcJрQ	P
HQMLKTKQLSMSONBۅQOQQGQ=PPEQQSRQ'QQRSSSUTVOQDQUQVQPPVQTQQBNQTQVQCQRSRSNQA]AB@NQC]CNQA]ACKLML\MYQ	P
HQRQNQSRSONBۅQOQQGQ:PPEQQLKJ'JQKSLSUTVOQDQUQVQPPVQTQQBNQTQVQCJKLKLNQA]AB@NQA]AQRQRQAQ	P@QCQOBCMODIFY-STRUCT-HEAPHF$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:\BHBTEMP-STRUCTBBBBÂSTRUCT-REL-ATTRIBUTESCSTRUCT-ATTRIBUTESMODIFIED-TUPLESBB:B:B:B:STRUCT-TUPLEB:B:B:B:BBSTRUCT-ATTRB\Bg\BxBiB{B}BjBBBBFBBBBBBBB~BlBlBPBBBBBBjB8B@߀QJ5Q݅QQQP	PAFKсQML	LQ
PJQMSCLMMKQGMMуQKN	NQ
PJQKSCNKKMQHQDQErNNрQPLKfKQLSOCPPGQRQQQOQRSCQRRPQBQBQQFQ@EQQHQQPS*SSPSQSVUTWBQDQUQWQPPWQTQQ
CPVQOQPWQSPQSPQOQA]AC@OQI]IOQA]ACKLLqSSрQPQPfPQQSOCNNGQLKKQOQLSCKLLNQBQBQQFQ@EQQHQMLK*KSLSMSVUTWBQDQUQWQPPWQTQQ
CPVQOQPWQKLMKLMOQA]AC@k@OQA]ACPQQQAQP@QIQOBMODIFY-LIST-HEAPJB4FZ$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:\MODIFY-LISTBHBBBBMODIFY-VALUEB:B:B:B`CNEW-TUPLEB:\Bg\B{BBiBjBFBBYPARSE-WHEREBBBBB~ÂSUPER-FAST-EVAL-WHEREBBA߅5Q݅QQQPPADQFFS5FS&FSFS@]@F@Q@DQGCGGSCHSHGS	GH-Q
PIPISJKCۅQJQDQQQQJQ@QQQDQJKB]BJQK+AKQE]EJQB]BI)Q
PL#LSJKCۅQJQDQQQQJQ@QQQDQJKB]BJQK+AJQB]BLQBQ
PAQEQOBCMODIFY-FLAVOR-HASHF$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:B:B:FLAVORMODIFY-HASHQQQQQQPQQ	JOBCMODIFY-STRUCT-HASHF$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:B:B:STRUCTBܒQQQQQQPQQ	JOBMODIFY-LIST-HASHF$B:BV]FB:B:B:BYFB^B\BBBBaBBBBJB:B:B:LISTBܒQQQQQQPQQ	JOBB(@F$B:BV]FB:B:B:BYFB^B\	BBBGBBaBBBBJB:\$B:B:BBBBBOBPBHÀRESULTHASH-TUPLESNUM-BUCKET-MODIFIEDBRBBBCUNCON-ATTRBBBQBÁMODIFY-CLAUSEBB+BB:B:B:BB:BB:BSBTCXCMOD-BUCKET\Bg\BBiB{B}BjB\FB\B$BBBBB,-BUCKETBBBQBeBkFBBBBBBFpB\,*APPEND\FF
\BBB}pBTFIRSTNH߀QPLQXPQ	P
PQCPSQGQQہQSQGYGQ[ZZQ[SLQCZ[[YQFQQQPPANQ\\S5	\SQQPPANU\SM]M\MQM[[уQY]]QYS^PXQ^Q
C]YY[QR]]фQZYYQZS^PXQ^Q
CYZZ]QTQOQPQQNQ][C[[SC]S][S[]F0FQGQY_'_SYSa`QQaQۄQQ`QQQQNQOQPQLQQQRQTQPQAWKHaHWWWQVQV_Y_<Y9JPPCLQJQZ0ZSbcbSLQcÊCbWCccQIQQbSIQQQbWQQQNQOQPQLQQQRQTQPQAWKHaHWWWQVQVZHQVQOBB
@F$B:BV]FB:B:B:BYFB^B\BCTUPLE-LISTB:\B:B:B\Bg\BjBBB~QQ\O#BÁFLAVOR-BUCKETd憀F$B:BV]FB:B:B:BYFB^B$\BBBGBBaBBOBKEY-ATTRBBBBBRBBBB:\NEW-KEYKEY-MODPBHBBB:B:B`BC-TUPLEB:B:B:B:BBBB:B
B:B:\Bg\	pBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETB}BiB{Bj(plEH*CONDITION-HANDLERS*BBBBB~BBlBPBBBBBBBBp,G5145FERRORpB\ERRSET-HANDLERBBBkBpBqB߁5Q݆QQDQDQFEESFSHGI@CہQHQ	QQ
JJьQQMLK,KQLSMSONPHQQOQPIQPQ	IQPPPQNQQCGQNQPQCKLMLMAMMшQQKJQ8QQJSKSONRNQQP%PPTPPPJCSPJCTNQQPIQCR	J!BJ!B\RQO+ARQOQ@]@CQJKJKA	@Q
QGQ@Q
Q
CGQ]CBGQ]EFEFVQ
QQQ
QBQQOIB$ÁSTRUCT-BUCKETiF$B:BV]FB:B:B:BYFB^BJ\BBBGBBaBBOBB-BBBBBRBBBB:\B0B/BBHBBIB:BB1B:B:B:B:BCSTRUCT-VALREL-ATTRBBBB
B:B:\Bg\
B5B7B9B;B=BxB}BiB{Bj(BABBBB~BBlBPBBBBBBBjB8BpBBG5241FBFBHBkBpBqC߁5Q݆QFFSGHADIIяQKJJQGQKSCJKKIQBQBQQQ	QQQJIL/LSISJSONMPBQ
QNQPHQPQHQPPPQMQQ
DPOQGQPPQLIJLIJ@ۈQQKJ9JSKSRQSQQQP)PPTPPPJCTPJCUքQCQQQPCcHQCJ!BJ!B\BSSQR+@SQRQA]AJKJK@	AQ
QGQAQ
Q
CGQ]DCGQ]GQEQEFFQ
QQQ
QCQEQO\BJLIST-BUCKETPFh$B:BV]FB:B:B:BYFB^B]\BBBGBBaBBOBB-BBBBBRBBBB:\B/B0BHBBIB:B:B:B`B:B:BBB
B:B:\Bg\	B5B7B9B;B=BiB{B}Bj(BABB~BBBBBlBPpBBG5324F{BFBHBBBBBkBpBqB߁5QEцQGFFQGSH@CہQHQQQlAۈQQJI;ISJSLKMKQQ	P
+HQQPPTPPPJCNPJCOKQQPQCJ!BJ!B\BMMQL+AMQLQ@]@IJIJAQQHQQQQQJA@Q
QAQ@Q
Q
CQQHQQQQQJAÃ]AQH+BHQ]AQCFGG|EQDQ
QQQ
QBQDQOmB]1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\B=-i\B;~z\B9<p\B7`sN\B5|\B6\B톀z(\B솀:}n\B놀x\BꆀZi\B醀{Ĳ\B{\B}(̢\B{*j\Bx.ً\Bj[\Bi=#r-prereq rel-attributes)))
((string-equal (string-upcase imp) "STRUCT")
 (setf conv-attribute-list (unconvert-attributes (mapcar #'(lambda (attr)
     (concatenate 'string string-relation-name
  attr))
 rel-attributes)))))
  (setf bucket (mapcar (function (lambda LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540688. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DESTROY-ATT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846055. :AUTHOR "REL3" :LENGTH-IN-BYTES 16161. :LENGTH-IN-BLOCKS 16. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;1;; Copyright (c) by Texas Instruments, Incorporated*
;1;; All rights reserved.*
;1;; DESTROY-ATT*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     deff*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     destroy-att-flavor-hash*
;1;;     destroy-att-flavor-heap*
;1;;     destroy-att-flavor-avl*
;1;;     destroy-att-utility-redef-rel-flavor-heap*
;1;;     destroy-att-utility-redef-rel-flavor-hash*
;1;;     destroy-att-utility-redef-rel-flavor-avl*
;1;;*

(deff destroy-attr 'destroy-attribute)

(defun destroy-attribute (relation-name
  &rest keyword-list
  &key &optional attribute key &allow-other-keys
  &aux (relation-tuple nil) key-list init-attribute-list delete-attribute-list indices
  attribute-list rel-owner-id rel-implementation-type new-key key-value save-dir
  rel-storage-structure  pos)
  "Attributes in a relation can be deleted using this function.

   RELATION-NAME - Name of the relation from which the attributes are to be deleted.
   ATTRIBUTE     - List of attributes to be destroyed.
   KEY           - List of attributes to form the new key, if so desired."
  attribute key
  (block destroy-attribute
(if *parameter-checking*
    (if (or (not (active-database)) (not (setf relation-name (validate-sym relation-name))))
(return-from destroy-attribute nil)))
  (setf keyword-list (de-nest-keyword-list keyword-list))
  (if *parameter-checking*
      (setf keyword-list (get-keyword-value-prereq '(att key) keyword-list)))
  (setf delete-attribute-list (car (get-keyword-value '(att) keyword-list)))
  (cond ((and (listp delete-attribute-list) (listp (car delete-attribute-list)))
 (setf delete-attribute-list (car delete-attribute-list)))
((and delete-attribute-list (not (listp delete-attribute-list)))
 (setf delete-attribute-list (list delete-attribute-list))))
  (setf relation-tuple (cadr (get-relation relation-name '("OWNER-ID" "TUPLE-FORMAT" "ATTRIBUTES" "DOMAINS"
   "KEY" "SAVE-DIRECTORY" "DOC" "IMPLEMENTATION-TYPE"
   "STORAGE-STRUCTURE") nil)))
  (cond ((not relation-tuple)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
     relation-name *active-db*))
 (return-from destroy-attribute nil)))
  ;;
  ;;1 later, verify here that the user owns this relation*
  ;;
  (setf rel-owner-id (first relation-tuple)
save-dir (sixth relation-tuple)
init-attribute-list (third relation-tuple)
key-list (fifth relation-tuple)
new-key nil)
  ;;
  ;;1 Check if the attributes of delete-attribute-list are o.k.*
  ;;
  (let ((temp-delete-list nil))
    (mapc (function (lambda (attr)
      (setf attr (validate-sym attr t))
      (cond ((member attr temp-delete-list :test 'string-equal)
     (if *provide-warning-messages*
 (format *standard-output*
 "~%WARNING - The attribute ~S is already in the list." attr)))
    ((not (member attr init-attribute-list :test 'string-equal))
     (if *provide-warning-messages*
 (format *standard-output*
 "~%WARNING - The attribute ~S is not defined in the relation ~S."
 attr relation-name)))
    (t
     (setf temp-delete-list (append (list attr) temp-delete-list))
     ;;
     ;;1 If attribute is part of the key of the relation*
     ;;
     (cond ((member attr key-list :test 'string-equal)
    (setf new-key t)
    (setf pos  (position attr key-list :test 'string-equal))
    (setf key-list (append (firstn pos key-list) (nthcdr (1+ pos) key-list)))
    ))))))
  delete-attribute-list)
    (if temp-delete-list
(setf delete-attribute-list (nreverse temp-delete-list))
(return-from destroy-attribute nil)))
  ;;
  ;;1 Not allowed to destroy all the attributes of the relation*
  ;;
  (cond ((= (length delete-attribute-list)(length init-attribute-list))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - Destroying all the attributes of the relation has to be done invoking DESTROY-REL"))
 (return-from destroy-attribute nil)))
  (cond ((or (setf key-value (car (get-keyword-value '(key) keyword-list))) new-key)
 (cond (key-value
;;
;;1 check the key-value to see if there is any of the attribute to be destroyed in it*
;;
(mapc (function (lambda (attr-key)
 (setf attr-key (validate-sym attr-key t))
 (cond ((member attr-key delete-attribute-list :test 'string-equal)
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR - The attribute ~S cannot be part of the key as it is to be destroyed." attr-key))
(return-from destroy-attribute nil))
       ((not (member attr-key init-attribute-list :test 'string-equal))
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR - ~s is not an attribute of the ~s relation"
    attr-key relation-name))
(return-from destroy-attribute nil)))))
key-value))
       ;;
       ;;1 new key because 1.some (or 2.all) attributes which are part of the key have to be destroyed. In case 2., key-value is*
       ;1; set to T, and will be set to the default key value of the relation in DESTROY-ATT-UTILITY-REDEF-REL*
       ;;
       (t
(setf key-value (if key-list key-list t))))
 (setf rel-implementation-type (nth 7 relation-tuple)
       rel-storage-structure (nth 8 relation-tuple))
 (setf attribute-list (destroy-att-utility init-attribute-list init-attribute-list
   delete-attribute-list))
 (modify-index-key delete-attribute-list attribute-list indices)
 (if (not (funcall (find-symbol (concatenate 'string "DESTROY-ATT-UTILITY-REDEF-REL-"
       rel-implementation-type "-" rel-storage-structure)
*pkg-string*)
   relation-name delete-attribute-list relation-tuple key-value))
     (return-from destroy-attribute nil)))
(t
 (setf rel-implementation-type (nth 7 relation-tuple)
       rel-storage-structure (nth 8 relation-tuple))
 (setf attribute-list (destroy-att-utility init-attribute-list init-attribute-list
   delete-attribute-list))
 (modify-index-key delete-attribute-list attribute-list indices)
 (if (not (funcall (find-symbol (concatenate 'string "DESTROY-ATT-" rel-implementation-type
"-" rel-storage-structure) *pkg-string*)
   relation-name delete-attribute-list relation-tuple))
     (return-from destroy-attribute nil))))
  (cond (*auto-save*
   (save-system-relations)
   (save-relation relation-name (list 'dir save-dir))))
  (if *provide-status-messages*
      (format *standard-output* "~%Destroy attribute complete"))
  (return-from destroy-attribute relation-name)))

(defun modify-index-key (delete-attribute-list attribute-list indices)
  (mapc (function (lambda (index-element &aux key-list new-key)
    (setf key-list (second index-element)
  new-key nil)
    (mapc (function (lambda (attribute &aux pos)
      (cond ((member attribute key-list :test 'string-equal)
     (setf new-key t)
     (setf pos (position attribute key-list :test 'equal))
     (setf key-list (append (firstn pos key-list)
    (nthcdr (1+ pos) key-list)))))))
  delete-attribute-list)
    (cond (new-key
   (cond ((null key-list)
  (setf key-list (list `(quote ,(list (car attribute-list))))))
 (t
  (setf key-list (list `(quote ,key-list)))))
   (modify-tuples 'system-index 'attr '(key) 'values key-list
  'where `(string-equal index-name ,(first index-element)))))))
indices))

(defun destroy-att-array-hash (relation-name delete-attr-list relation-tuple
       &aux array-name init-attribute-list)
  (if (destroy-att-utility-array-list relation-name delete-attr-list relation-tuple)
      (progn
(setf init-attribute-list (third relation-tuple))
(multiple-value-setq (array-name)
  (read-from-string (concatenate 'string relation-name "ARRAY")))
(maphash (function (lambda (key bucket)
     key
     (mapcar (function (lambda (row)
 (setf (aref (symbol-value array-name) row)
       (destroy-att-utility (aref (symbol-value array-name)
  row)
    init-attribute-list
    delete-attr-list))))
     bucket)))
 (getp relation-name 'entry-point))
relation-name)
      nil))

(defun destroy-att-array-heap (relation-name delete-attr-list relation-tuple
  &aux array-name init-attribute-list)
  (if (destroy-att-utility-array-list relation-name delete-attr-list relation-tuple)
      (progn
(setf init-attribute-list (third relation-tuple))
(multiple-value-setq (array-name)
  (read-from-string (concatenate 'string relation-name "ARRAY")))
(mapcar (function (lambda (row)
    (setf (aref (symbol-value array-name) row)
  (destroy-att-utility (aref (symbol-value array-name) row) init-attribute-list
       delete-attr-list))))
(getp relation-name 'entry-point))
relation-name)
      nil))

(defun destroy-att-flavor-hash (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple  nil))

(defun destroy-att-flavor-heap (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-flavor-avl (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-list-hash (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple  nil))

(defun destroy-att-list-heap (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-list-avl (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-struct-hash (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-struct-heap (relation-name delete-attr-list relation-tuple)
 (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-struct-avl (relation-name delete-attr-list relation-tuple)
 (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))


(defun destroy-att-utility (val-list init-attribute-list delete-attr-list
    &aux (result nil))
  (do ((attr-l init-attribute-list (cdr attr-l))
       (val-l val-list (cdr val-l)))
      ((or (null attr-l)(null val-l)) (nreverse result))
    (if (not (member (car attr-l) delete-attr-list :test 'string-equal))
(setf result (cons (car val-l) result)))))

(defun destroy-att-utility-array-list (relation-name delete-attr-list relation-tuple
       &aux attribute-list domain-list tuple-format-list where-c
       init-attribute-list)
  ;;
  ;;1 (i) system-attribute relation*
  ;;1     delete the tuples which describe the attributes to be deleted*
  (mapcar (function (lambda (attr)
      (delete-or-modify 'system-attribute nil   ;1delete*
(list 'and (list 'string-equal 'relation-name (string relation-name))
      (list 'string-equal 'attribute-name (string attr))))))
  delete-attr-list)
  ;;
  ;;1  (ii) modify the system-relation tuple which defines this relation *
  ;;
  (setf init-attribute-list (third relation-tuple))
  (setf domain-list  (destroy-att-utility (fourth relation-tuple) init-attribute-list delete-attr-list))
  (setf tuple-format-list (destroy-att-utility (second relation-tuple) init-attribute-list
       delete-attr-list))
  (setf attribute-list (destroy-att-utility init-attribute-list init-attribute-list delete-attr-list))
  (setf where-c (list 'string-equal 'relation-name (string relation-name)))
  (delete-or-modify 'system-relation t where-c '("MODIFIEDP" "TUPLE-FORMAT" "ATTRIBUTES" "DOMAINS")
    (list 't `(quote ,tuple-format-list ) `(quote ,attribute-list) `(quote ,domain-list)))
  relation-name)

(defun destroy-att-utility-redef-rel (relation-name delete-attr-list relation-tuple new-key
      &aux system-attribute-list attribute-list tuple-format-list tuple-list
      dir imp ss key doc attr-des-pair init-attribute-list)
  (setf system-attribute-list (get-system-attribute-list relation-name))
  (setf init-attribute-list (third relation-tuple))
   (setf tuple-format-list (destroy-att-utility (second relation-tuple) init-attribute-list delete-attr-list))
   (setf attribute-list (destroy-att-utility init-attribute-list init-attribute-list delete-attr-list))
   (setf dir (nth 5 relation-tuple)
 imp (nth 7 relation-tuple)
 ss (nth 8 relation-tuple)
 key (cond
       ;;1 all the attributes which were part of the key have been destroyed,*
       ;;1 the new key is a list of the first attribute of the relation (default)*
       ((equal new-key t)
(list (car attribute-list)))
       ;;1 the key has been modified (either with the keyword KEY, either by destroying some attributes which were part of the*
       ;1; key)*
       (new-key
new-key)
       ;;1 the key is not modified*
       (t
(nth 4 relation-tuple)))
 doc (nth 6 relation-tuple))
   ;;
   ;;1 Create the attribute-descriptor list to redefine the relation*
  (setf attr-des-pair (create-attr-descriptor attribute-list system-attribute-list))
  (setf tuple-list nil)
  (maptuple (function (lambda (tuple)
      (setf tuple-list (append (list (destroy-att-utility tuple init-attribute-list
  delete-attr-list)) tuple-list))))
   relation-name)
  (redefine-rel relation-name attr-des-pair imp ss key tuple-format-list doc dir (nreverse tuple-list))
  relation-name)

(defun destroy-att-utility-redef-rel-list-heap (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-list-hash (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-list-avl (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-list-list (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-flavor-heap (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-flavor-hash (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-flavor-avl (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-struct-heap (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-struct-avl (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))

(defun destroy-att-utility-redef-rel-struct-hash (relation-name attribute-descriptor relation-tuple key-value)
  (destroy-att-utility-redef-rel relation-name attribute-descriptor relation-tuple key-value))
FB\B$BBBBB,-BUCKETBBBQBeBkFBBBBBBFpB\,*APPEND\FF
\BBB}pBTFIRSTNLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540691. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DESTROY-ATT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360707. :AUTHOR "REL3" :LENGTH-IN-BYTES 4935. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8DESTROY-ATT\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPCDESTROY-ATTRIBUTEOPDESTROY-ATTRBP:b:@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAME&RESTKEYWORD-LIST&KEYj&OPTIONALCATTRIBUTEKEYj&ALLOW-OTHER-KEYSB:\BcBfBgÁRELATION-TUPLEKEY-LISTINIT-ATTRIBUTE-LISTÂDELETE-ATTRIBUTE-LISTÁATTRIBUTE-LISTREL-OWNER-IDREL-IMPLEMENTATION-TYPENEW-KEYCKEY-VALUESAVE-DIRÂREL-STORAGE-STRUCTUREPOSTEMP-DELETE-LISTB:ATTRB:ATTR-KEY\)MACROS-EXPANDED\PROGpZLC,DO-NAMEDFIFTHTHIRDSIXTHFIRSTSETFDOCUMENTATIONAttributes in a relation can be deleted using this function.

   RELATION-NAME - Name of the relation from which the attributes are to be deleted.
   ATTRIBUTE     - List of attributes to be destroyed.
   KEY           - List of attributes to form the new key, if so desired. C*PROVIDE-STATUS-MESSAGES*у*AUTO-SAVE*у*PKG-STRING*C*PROVIDE-WARNING-MESSAGES*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*у*PARAMETER-CHECKING*\iATTRIBUTEKEYpB]STORE-KEYARGSACTIVE-DATABASE҃VALIDATE-SYM҃DE-NEST-KEYWORD-LIST\ATTBgGET-KEYWORD-VALUE-PREREQ\BCGET-KEYWORD-VALUEҪLIST\	,OWNER-IDTUPLE-FORMATlATTRIBUTES,DOMAINSKEYSAVE-DIRECTORYDOCIMPLEMENTATION-TYPElSTORAGE-STRUCTUREGET-RELATIONTERPRIERROR - The relation WRITE-STRINGPRIN1, is not defined in the database STRING-EQUALpB]MEMBER-TEST,WARNING - The attribute , is already in the list., is not defined in the relation e.jWRITE-CHARpB]lPOSITION*pBUFIRSTNpB],*APPEND*NREVERSElERROR - Destroying all the attributes of the relation has to be done invoking DESTROY-REL\BgERROR - The attribute  cannot be part of the key as it is to be destroyed.,ERROR -  is not an attribute of the l relationDESTROY-ATT-UTILITYMODIFY-INDEX-KEYSTRINGDESTROY-ATT-UTILITY-REDEF-REL-l-CONCATENATEҪFIND-SYMBOLҬDESTROY-ATT-ÂSAVE-SYSTEM-RELATIONS҃DIRÁSAVE-RELATIONlDestroy attribute complete@@QPA
QR@Q@
P@Q@P@QBFF5FS5FSFF5FQFQPBC		PQPPRCSHCYBLC[ECUBDJFQP=PSQQOQP
0PQQP(QQEQP!PQQ PQ!P"QQO]OQQDQPJQQDQP#NDQ$NkDQ
C%DPOOQ&FRFQCEQCz	'PR(P@QBKJUK,KQR/RSSSFQP
	)PSQ*PRSQEQP	+PSQ,PQ-PRRDDQKJCQCIJCQCMEQEQFQ.GFQGQ/0P1PIQ2PMQ3P4RQFQCQKQR!RJCQCIJCQCMEQEQFQ.GFQGQ/0P5PIQ2PMQ3P4RQFQCQRR6Q7PLQ89POBPB R@F2$B:BW]FB:B:B:BZFB_B\BmBnINDICESB:\B:ÁINDEX-ELEMENTBkBqB:BfBu\Bz\BpB]lXR-BQ-LISTSECONDBB|BpBUINHIBIT-STYLE-WARNINGSBBEQUALBBBB8B҃SYSTEM-INDEXBw\BgVALUESÀWHERECINDEX-NAMEÁMODIFY-TUPLESQ@<@SABCAWBCۀQDDSEFEQBQPCEQBQPFBQFkBQ
CBDCB	PS
	PBQ

BPPPPBQPPPAS
J@OBÂDESTROY-ATT-ARRAY-HASH#@F$B:BW]FB:B:B:BZFB_B\BaDELETE-ATTR-LISTBjB:\B:B:pB]lLEX-PARENT-ENV-REGpB]LEX-ENV-B-REGpB]LEX-CURRENT-VECTOR-REGpB]LEX-ALL-VECTORS-REGCARRAY-NAMEBl\Bz\BBINTERNAL-FEF-OFFSETS\F	iVARIABLES-USED-IN-LEXICAL-CLOSURES\BlBBÃDESTROY-ATT-UTILITY-ARRAY-LISTBARRAYB*READ-FROM-STRING\FFF\)INTERNALBENTRY-POINTGETP*MAPHASHQQQ[GPQPFP	PCQ
PROBB@F$B:BW]FB:B:B:BZFB_B\BgÀBUCKETB:\B:B:BB:B:B:ROW\Bz\BB|BBiLEXICAL-PARENT-DEBUG-INFOBBÒCсQEDDQESFPCFQPCFQCPPBCDEECO"BÂDESTROY-ATT-ARRAY-HEAP5@F $B:BW]FB:B:B:BZFB_B#\BaBBjB:\BBlB:B:B:B\Bz\B|BBBBBBARRAYBBBBBÒQQQ$[APQP@BрQP	DCCQDSE@QCEQ@QCEQCAQQ
BCCDDRO0B#DESTROY-ATT-FLAVOR-HASH
FF$B:BW]FB:B:B:BZFB_B1\BaBBjB:B:B:ÃDESTROY-ATT-UTILITY-REDEF-RELQQQO;B1DESTROY-ATT-FLAVOR-HEAP
FF$B:BW]FB:B:B:BZFB_B<\BaBBjB:B:B:B:QQQOEB<ÂDESTROY-ATT-FLAVOR-AVL
FF$B:BW]FB:B:B:BZFB_BF\BaBBjB:B:B:B:QQQOOBFÂDESTROY-ATT-LIST-HASH
FF$B:BW]FB:B:B:BZFB_BP\BaBBjB:B:B:B:QQQOYBPÂDESTROY-ATT-LIST-HEAP
FF$B:BW]FB:B:B:BZFB_BZ\BaBBjB:B:B:B:QQQOcBZDESTROY-ATT-LIST-AVL
FF$B:BW]FB:B:B:BZFB_Bd\BaBBjB:B:B:B:QQQOmBdDESTROY-ATT-STRUCT-HASH
FF$B:BW]FB:B:B:BZFB_Bn\BaBBjB:B:B:B:QQQOwBnDESTROY-ATT-STRUCT-HEAP
FF$B:BW]FB:B:B:BZFB_Bx\BaBBjB:B:B:B:QQQOBxÂDESTROY-ATT-STRUCT-AVL
FF$B:BW]FB:B:B:BZFB_B\BaBBjB:B:B:B:QQQOBB@F$B:BW]FB:B:B:BZFB_B\VAL-LISTBlBB:\ÀRESULTÀATTR-LÀVAL-L\Bz\BB|BBBQQBAASQPBS@]@ABAB@QOBB#U@F2$B:BW]FB:B:B:BZFB_B\BaBBjB:\	BnDOMAIN-LISTCTUPLE-FORMAT-LISTWHERE-CBlB:B:B:Bw\Bz\BBFOURTHBBB|BBSYSTEM-ATTRIBUTEANDBBaBBÁATTRIBUTE-NAMEDELETE-OR-MODIFYBSYSTEM-RELATION\lMODIFIEDPTUPLE-FORMATlATTRIBUTES,DOMAINSB8EсQGFFQGSHPPPPQP	PHQ
CFGG[DQBDQQAWDQQBDQDQQ@PPQCPCQPPBQP@QPAQ
OBB:"QF/$B:BW]FB:B:B:BZFB_B:\BaBBjBqB:\B:B:BBBBÂSYSTEM-ATTRIBUTE-LISTBnBCTUPLE-LISTB̃IMPCSSBgDOCÁATTR-DES-PAIRBl\Bz\BBBB\F	B\BlBBCGET-SYSTEM-ATTRIBUTE-LISTBBÂCREATE-ATTR-DESCRIPTOR\FFF	\BB:MAPTUPLEB҃REDEFINE-RELQF[PWPQQHPQPQQGJQCJJQCKJQCLQGSQJQCMJQCNGQFQOIP	PCQ
QOQKQLQMQHQNQJQIQ	JOB:B@LF$B:BW]FB:B:B:BZFB_B\ÀTUPLEB:\B:B:B\Bz\BB!BBÒQPP\OBDESTROY-ATT-UTILITY-REDEF-REL-LIST-HEAP
F$B:BW]FB:B:B:BZFB_B\BaATTRIBUTE-DESCRIPTORBjBrB:B:B:B:QQQQOBDESTROY-ATT-UTILITY-REDEF-REL-LIST-HASH
F$B:BW]FB:B:B:BZFB_B\BaBBjBrB:B:B:B:QQQQOBÄDESTROY-ATT-UTILITY-REDEF-REL-LIST-AVL
F$B:BW]FB:B:B:BZFB_B\BaBBjBrB:B:B:B:QQQQOBDESTROY-ATT-UTILITY-REDEF-REL-LIST-LIST
F$B:BW]FB:B:B:BZFB_B\BaBBjBrB:B:B:B:QQQQOBCDESTROY-ATT-UTILITY-REDEF-REL-FLAVOR-HEAP
F$B:BW]FB:B:B:BZFB_B\BaBBjBrB:B:B:B:QQQQOBCDESTROY-ATT-UTILITY-REDEF-REL-FLAVOR-HASH
F$B:BW]FB:B:B:BZFB_B\BaBBjBrB:B:B:B:QQQQO BDESTROY-ATT-UTILITY-REDEF-REL-FLAVOR-AVL
F$B:BW]FB:B:B:BZFB_B!\BaBBjBrB:B:B:B:QQQQO*B!CDESTROY-ATT-UTILITY-REDEF-REL-STRUCT-HEAP
F$B:BW]FB:B:B:BZFB_B+\BaBBjBrB:B:B:B:QQQQO4B+DESTROY-ATT-UTILITY-REDEF-REL-STRUCT-AVL
F$B:BW]FB:B:B:BZFB_B5\BaBBjBrB:B:B:B:QQQQO>B5CDESTROY-ATT-UTILITY-REDEF-REL-STRUCT-HASH
F$B:BW]FB:B:B:BZFB_B?\BaBBjBrB:B:B:B:QQQQOHB?1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\Bx\Bᆀ(̢\B߆{\Bކ.ً\B[\Bz(\B{Ĳ\B:}n\BZi\B*j\B|=#e-attr-list relation-tuple  nil))

(defun destroy-att-list-heap (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun destroy-att-list-avl (relation-name delete-attr-list relation-tuple)
  (destroy-att-utility-redef-rel relation-name delete-attr-list relation-tuple nil))

(defun desLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540695. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "DOMAIN" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846070. :AUTHOR "REL3" :LENGTH-IN-BYTES 31401. :LENGTH-IN-BLOCKS 31. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; DOMAIN*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;*      1deff   *
;1;;   *

(defun value-domainp (val)
  (cond ((typep val :list)
 '"LISTP")
((typep val :string)
 '"STRINGP")
((typep val :number)
 '"NUMBERP")
((typep val :atom)
 '"ATOM")
(t
 '"ANYP")))

(deff equalp-rtms 'rtms-equalp)
(deff *equalp 'rtms-equalp)
(defun rtms-equalp (&rest vals &aux val1 val2 dom1 dom2)
  (setf vals (do ((val-l vals (car val-l)))
 ((or (not (equal (length val-l) 1)) (not(listp (car val-l)))) val-l) ()))
  ;;
  ;;1  only one value, cannot compare*
  ;;
  (cond ((equal (length vals) 1)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Only one value provided, need at least two to compare."))
 nil)
(t
 (do ((vals-left vals (cdr vals-left)))
     ((equal (length vals-left) 1) (return t))
   (setf val1 (first vals-left)
 val2 (second vals-left)
 dom1 (value-domainp val1)
 dom2 (value-domainp val2))
   ;;1 if value-domainp returns anyp, it actually means that the domain is not supported*
   (cond ((or (string-equal dom1 "ANYP")(string-equal dom2 "ANYP"))
  (return nil)))
   (cond ((string-equal dom1 dom2)
  (if (not (funcall (find-symbol (concatenate 'string "EQUAL-" dom1) *pkg-string*)
    val1 val2))
      (return nil)))
 ((or (and (string-equal dom1 "ATOM")(string-equal dom2 "STRINGP"))
      (and (string-equal dom2 "ATOM")(string-equal dom1 "STRINGP")))
  (if (not (equal-stringp val1 val2))
      (return nil)))
 (t
  (return nil)))))))

(defun equal-anyp (val1 val2)
  (equalp-rtms (list val1 val2)))

(defun equal-atom (val1 val2)
    (cond ((and (numberp val1) (numberp val2))
   (equal val1 val2))
  ((or (numberp val1)(numberp val2))
   nil)
  ((and (stringp val1) (stringp val2))
   (string-equal val1 val2))
  ((or (stringp val1)(stringp val2))
   nil)
  (t
   (string-equal (string val1) (string val2)))))

(defun equal-listp (list1 list2 &aux val1 val2)
  (do ((v1 list1 (cdr v1))(v2 list2 (cdr v2)))
      ((and (null v1)(null v2)) (return t))
    (setf val1 (car v1)
  val2 (car v2))
    (cond ((or (null val1) (null val2)) (return nil)))
    (if (not (*equalp val1 val2))
(return nil))))

(defun equal-numberp (val1 val2)
  (equal val1 val2))

(defun equal-stringp (val1 val2)
  (string-equal val1 val2))

;;;1Comparison is made between the previous item (val1) and the present item (val2) to see if the previous item is >= present item. Then *
;;1; previous item assumes the value of the present and present gets the value of the top item in the rest of the item-list and the process is*
;;1; repeated till the  condition >= is not satisifed. NIL is returned. When no more elements are found in the item-list T is returned.*
(defun gep (&rest vals &aux val1 val2 dom1 dom2)
  (setf vals (do ((val-l vals (car val-l)))
 ((or (not (equal (length val-l) 1)) (not(listp (car val-l)))) val-l) ()))
  ;;1 only one value, cannot compare*
  (cond ((equal (length vals) 1)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Only one value provided, need at least two to compare."))
 nil)
(t
 (do ((vals-left vals (cdr vals-left)))
     ((equal (length vals-left) 1) (return t))
   (setf val1 (first vals-left)
 val2 (second vals-left)
 dom1 (value-domainp val1)
 dom2 (value-domainp val2))
   ;;1 if value-domainp returns anyp, it actually means that the domain is not supported*
   (cond ((or (string-equal dom1 "ANYP")(string-equal dom2 "ANYP"))
  (return nil)))
   (cond ((string-equal dom1 dom2)
  (if (not (funcall (find-symbol (concatenate 'string "GE-" dom1) *pkg-string*) val1 val2))
      (return nil)))
 ;; 1any list is > to anything*
 ((string-equal dom2 "LISTP")
  (return nil))
 ((string-equal dom1 "LISTP")
  ())
 ;; 1any number is < to anything*
 ((string-equal dom2 "NUMBERP")
  ())
 ((string-equal dom1 "NUMBERP")
  (return nil))
 ((or (and (string-equal dom1 "ATOM")(string-equal dom2 "STRINGP"))
      (and (string-equal dom2 "ATOM")(string-equal dom1 "STRINGP")))
  (if (not (ge-stringp val1 val2))
      (return nil)))
 (t
  (return nil)))))))

(defun ge-anyp (val1 val2)
  (gtp (list val1 val2)))

(defun ge-atom (val1 val2)
  (cond ((and (numberp val1) (numberp val2))
 (or (> val1 val2)(equal val1 val2)))
((numberp val2)
 t)
((numberp val1)
 nil)
(t
 (setf val1 (string val1)
       val2 (string val2))
 (or (string-lessp val2 val1) (string-equal val1 val2)))))

(defun ge-listp (list1 list2 &aux val1 val2 (is-ge nil))
  (do ((v1 list1 (cdr v1))(v2 list2 (cdr v2)))
      ((or is-ge (and (null v1)(null v2))) (return t))
    (setf val1 (car v1)
  val2 (car v2))
    (cond ((null val2)
   (return t))
  ((null val1)
   (return nil)))
    ;;1 this is better than calling GEP because as soon as we find one val which is GT (and not equal) we stop the tests*
    (cond ((gtp val1 val2)
   (setf is-ge t))
  ((not (*equalp val1 val2))
   (return nil)))))

(defun ge-numberp (val1 val2)
  (or (> val1 val2)(equal val1 val2)))

(defun ge-stringp (val1 val2)
  (or (string-lessp val2 val1)(string-equal val1 val2)))

;1;*;1 Comparison is made between the previous item and the present item to see if the previous item is > present item. Then previous item *
;1;; assumes the value of the present and present gets the value of the top item in the rest of the item-list and the process is repeated till *
;1;; the  condition > is not satisifed. NIL is returned. When no more elements are found in the item-list T is returned.*
(defun gtp (&rest vals &aux val1 val2 dom1 dom2)
  (setf vals (do ((val-l vals (car val-l)))
 ((or (not (equal (length val-l) 1)) (not(listp (car val-l)))) val-l) ()))
  ;;1 only one value, cannot compare*
  (cond ((equal (length vals) 1)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Only one value provided, need at least two to compare."))
 nil)
(t
 (do ((vals-left vals (cdr vals-left)))
     ((equal (length vals-left) 1) (return t))
   (setf val1 (first vals-left)
 val2 (second vals-left)
 dom1 (value-domainp val1)
 dom2 (value-domainp val2))
   ;;1 if value-domainp returns anyp, it actually means that the domain is not supported*
   (cond ((or (string-equal dom1 "ANYP")(string-equal dom2 "ANYP"))
  (return nil)))
   (cond ((string-equal dom1 dom2)
  (if (not (funcall (find-symbol (concatenate 'string "GT-" dom1) *pkg-string*) val1 val2))
      (return nil)))
 ;; 1any list is > to anything*
 ((string-equal dom2 "LISTP")
  (return nil))
 ((string-equal dom1 "LISTP")
  ())
 ;; 1any number is < to anything*
 ((string-equal dom2 "NUMBERP")
  ())
 ((string-equal dom1 "NUMBERP")
  (return nil))
 ((or (and (string-equal dom1 "ATOM")(string-equal dom2 "STRINGP"))
      (and (string-equal dom2 "ATOM")(string-equal dom1 "STRINGP")))
  (if (not (gt-stringp val1 val2))
      (return nil)))
 (t
  (return nil)))))))

(defun gt-anyp (val1 val2)
  (gtp (list val1 val2)))

(defun gt-atom (val1 val2)
    (cond ((and (numberp val1) (numberp val2))
   (> val1 val2))
  ((numberp val2)
   t)
  ((numberp val1)
   nil)
  (t
   (string-lessp (string val2) (string val1)))))

(defun gt-listp (list1 list2 &aux val1 val2 (is-gt nil))
  (do ((v1 list1 (cdr v1))(v2 list2 (cdr v2)))
      ((or is-gt (and (null v1)(null v2))) (if is-gt (return t)(return nil)))
    (setf val1 (car v1)
  val2 (car v2))
    (cond ((null val2)
   (return t))
  ((null val1)
   (return nil)))
    (cond ((gtp val1 val2)
   (setf is-gt t))
  ((not (*equalp val1 val2))
   (return nil)))))

(defun gt-numberp (val1 val2)
  (> val1 val2))

(defun gt-stringp (val1 val2)
  (string-lessp val2 val1))


(defun lep (&rest vals &aux val1 val2 dom1 dom2)
  (setf vals (do ((val-l vals (car val-l)))
 ((or (not (equal (length val-l) 1)) (not(listp (car val-l)))) val-l) ()))
  ;;1 only one value, cannot compare*
  (cond ((equal (length vals) 1)
 (if *provide-error-messages*
     (format *standard-output*  "~%ERROR - Only one value provided, need at least two to compare."))
 nil)
(t
 (do ((vals-left vals (cdr vals-left)))
     ((equal (length vals-left) 1) (return t))
   (setf val1 (first vals-left)
 val2 (second vals-left)
 dom1 (value-domainp val1)
 dom2 (value-domainp val2))
   ;;1 if value-domainp returns anyp, it actually means that the domain is not supported*
   (cond ((or (string-equal dom1 "ANYP")(string-equal dom2 "ANYP"))
  (return nil)))
   (cond ((string-equal dom1 dom2)
  (if (not(funcall (find-symbol (concatenate 'string "LE-" dom1) *pkg-string*) val1 val2))
      (return nil)))
 ;; 1any list is > to anything*
 ((string-equal dom1 "LISTP")
  (return nil))
 ((string-equal dom2 "LISTP")
  ())
 ((string-equal dom1 "NUMBERP")
  ())
 ((string-equal dom2 "NUMBERP")
  (return nil))
 ((or (and (string-equal dom1 "ATOM")(string-equal dom2 "STRINGP"))
      (and (string-equal dom2 "ATOM")(string-equal dom1 "STRINGP")))
  (if (not (le-stringp val1 val2))
      (return nil)))
 (t
  (return nil)))))))


(defun le-anyp (val1 val2)
  (lep (list val1 val2)))

(defun le-atom (val1 val2)
   (cond ((and (numberp val1) (numberp val2))
  (or (< val1 val2) (equal val1 val2)))
 ((numberp val1)
  t)
 ((numberp val2)
  nil)
 (t
  (setf val1 (string val1)
val2 (string val2))
  (or (string-lessp val1 val2)(string-equal val1 val2)))))

(defun le-listp (list1 list2 &aux val1 val2 (is-le nil))
  (do ((v1 list1 (cdr v1))(v2 list2 (cdr v2)))
      ((or is-le (and (null v1)(null v2))) (return t))
    (setf val1 (car v1)
  val2 (car v2))
    (cond ((null val1)
   (return t))
  ((null val2)
   (return nil)))
    ;;1 this is better than calling LEP because as soon as we find one val which is LT (and not equal) we stop the tests*
    (cond ((ltp val1 val2)
   (setf is-le t))
  ((not (*equalp val1 val2))
   (return nil)))))

(defun le-numberp (val1 val2)
  (or (< val1 val2) (equal val1 val2)))

(defun le-stringp (val1 val2)
  (or (string-lessp val1 val2)(string-equal val1 val2)))

(defun ltp (&rest vals &aux val1 val2 dom1 dom2)
  (setf vals (do ((val-l vals (car val-l)))
 ((or (not (equal (length val-l) 1)) (not(listp (car val-l)))) val-l) ()))
  ;;1 only one value, cannot compare*
  (cond ((equal (length vals) 1)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Only one value provided, need at least two to compare."))
 nil)
(t
 (do ((vals-left vals (cdr vals-left)))
     ((equal (length vals-left) 1) (return t))
   (setf val1 (first vals-left)
 val2 (second vals-left)
 dom1 (value-domainp val1)
 dom2 (value-domainp val2))
   ;;1 if value-domainp returns anyp, it actually means that the domain is not supported*
   (cond ((or (string-equal dom1 "ANYP")(string-equal dom2 "ANYP"))
  (return nil)))
   (cond ((string-equal dom1 dom2)
  (if (not(funcall (find-symbol (concatenate 'string "LT-" dom1) *pkg-string*) val1 val2))
      (return nil)))
 ;; 1any list is > to anything*
 ((string-equal dom1 "LISTP")
  (return nil))
 ((string-equal dom2 "LISTP")
  ())
 ;; 1any number is < to anything*
 ((string-equal dom1 "NUMBERP")
  ())
 ((string-equal dom2 "NUMBERP")
  (return nil))
 ((or (and (string-equal dom1 "ATOM")(string-equal dom2 "STRINGP"))
      (and (string-equal dom2 "ATOM")(string-equal dom1 "STRINGP")))
  (if (not (lt-stringp val1 val2))
      (return nil)))
 (t
  (return nil)))))))

(defun lt-anyp (val1 val2)
  (ltp (list val1 val2)))

(defun lt-atom (val1 val2)
   (cond ((and (numberp val1) (numberp val2))
  (< val1 val2))
 ((numberp val1)
  t)
 ((numberp val2)
  nil)
 (t
  (string-lessp (string val1) (string val2)))))

(defun lt-listp (list1 list2 &aux val1 val2 (is-lt nil))
  (do ((v1 list1 (cdr v1))(v2 list2 (cdr v2)))
      ((or is-lt (and (null v1)(null v2))) (if is-lt (return t)(return nil)))
    (setf val1 (car v1)
  val2 (car v2))
    (cond ((null val1)
   (return t))
  ((null val2)
   (return nil)))
    (cond ((ltp val1 val2)
   (setf is-lt t))
  ((not (*equalp val1 val2))
   (return nil)))))

(defun lt-numberp (val1 val2)
  (< val1 val2))

(defun lt-stringp (val1 val2)
  (string-lessp val1 val2))


(defun notp (&rest vals)
  (setf vals  (do ((val-l vals (car val-l)))
  ((not (equal (length val-l) 1)) val-l) ()))
  (do ((vals-left vals (cdr vals-left)))
      ((null vals-left) (return t))
    (if (not (first vals-left))
(return nil))))


(defun aggregate-utility (relation-name attribute-names keyword-list
  &aux relation-tuple rel-tuple-list where-list unique index-name attribute-list
  domains-list key-list rel-imp rel-sto by card key-value-list)
  (block aggregate-utility
(if (not (active-database))
    (return-from aggregate-utility nil))
(cond ((null (setf relation-name (validate-sym relation-name)))
       (return-from aggregate-utility nil)))
(if (not (listp attribute-names))
    (setf attribute-names (list attribute-names)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
(setf keyword-list (get-keyword-value-prereq  '(where unique by tuples) keyword-list)
      where-list (or (car (get-keyword-value '(where) keyword-list)) t)
      unique (car (get-keyword-value '(unique) keyword-list))
      by (car (get-keyword-value '(by) keyword-list)))
(if (listp by)
    (setf by (car by)))
(if by
    (setf attribute-names (cons by attribute-names)))
(setf relation-tuple (cadr (get-relation relation-name '("ATTRIBUTES" "DOMAINS" "KEY"
 "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE"
 "CARDINALITY") nil)))
(cond ((not relation-tuple)
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
   (read-from-string (string-upcase relation-name)) *active-db*))
       (return-from aggregate-utility nil)))
(setf attribute-list (first relation-tuple)
      domains-list (second relation-tuple)
      key-list (third relation-tuple)
      rel-imp (fourth relation-tuple)
      rel-sto (fifth relation-tuple)
      card (sixth relation-tuple))
(cond  ((or (equalp attribute-names '(nil)) (not attribute-names))
       (setf attribute-names attribute-list))
      (t
       (setf attribute-names (convert-attributes attribute-names))
       ;;
       ;; 1   verify that the attribute to rename exists, and check if its domain is numberp*
       (mapc #'(lambda (attr)
 (cond ((null (member attr attribute-list :test 'string-equal))
1         *(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR - The attribute ~S is not defined in ~S."
    attr (read-from-string (string-upcase relation-name))))
(return-from aggregate-utility nil))))
     attribute-names)))
(multiple-value-setq (index-name key-value-list rel-sto key-list)
  (extract-key relation-name attribute-list key-list domains-list rel-sto where-list nil))
(setf rel-tuple-list (funcall (find-symbol (concatenate 'string "RETRIEVE-" rel-imp "-" rel-sto)
   *pkg-string*)
       relation-name attribute-list attribute-names key-list where-list key-value-list
       index-name))
(cond ((and rel-tuple-list unique)
       (setf rel-tuple-list (unique-tuples rel-tuple-list))))
(if rel-tuple-list
    (return-from aggregate-utility (list card rel-tuple-list))
    (return-from aggregate-utility nil))))

(defun average (relation-name attribute-name &rest keyword-list
&key &optional unique where by tuples &allow-other-keys
&aux  rel-tuple-list (result 0)(size 0) tuples? agg-tuples by? card)
  "Average of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose average is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group average of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table."
  unique where by tuples
  (block average
(if (not (setf rel-tuple-list (aggregate-utility relation-name attribute-name keyword-list)))
    (return-from average nil))
(setf card (car rel-tuple-list)
      rel-tuple-list (second rel-tuple-list))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
(setf tuples? (car (get-keyword-value '(tuples) (setf keyword-list (get-keyword-value-prereq
     '(tuples where by unique)
     keyword-list)))))
(cond ((setf by? (car (get-keyword-value '(by) keyword-list)))
       (if (listp by?)
   (setf by? (car by?)))
       (setf by? (string-upcase by?))
       (mapc #'(lambda (tuple &aux agg-tuple)
 (cond ((not (numberp (cadr tuple)))
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR -- Can not find the average for ~S in the relation ~S because ~S is not a number."
    attribute-name (read-from-string (string-upcase relation-name))
    (car tuple)))
(return-from average nil)))
 (if (setf agg-tuple (assoc (car tuple) agg-tuples :test 'equal))
     (setf (first (cadr agg-tuple)) (+ (first (cadr agg-tuple)) (cadr tuple))
   (second (cadr agg-tuple)) (incf (second (cadr agg-tuple))))
     (setf agg-tuples (cons (list (car tuple) (list (cadr tuple) 1)) agg-tuples))))
     rel-tuple-list)
       (if (not agg-tuples) (return-from average 0))
       (setf rel-tuple-list
     (mapcar #'(lambda (tuple)
 (list (car tuple) (/ (first (cadr tuple)) (float (second (cadr tuple))))))
     agg-tuples))
       (if tuples?
   (return-from average rel-tuple-list)
   (return-from average (printrel-internal* relation-name rel-tuple-list
       (list by? (read-from-string
   (concatenate 'string
     "AVERAGE-OF-" (string-upcase attribute-name))))
       nil nil nil nil '(20 30) t t card)))))
(mapc (function (lambda (tuple)
  (if (not (numberp (car tuple)))
      (progn
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR -- Can not find the average for ~S in the relation ~S because ~S is not a number."
    attribute-name relation-name (car tuple)))
(return-from average nil)))
  (setf result (+ result (car tuple)))
  (setf size (1+ size))))
      rel-tuple-list)
(if (not (equal size 0))
    (if tuples?
(return-from average (/ result (float size)))
(return-from average (printrel-internal* relation-name
    (list (list (/ result (float size))))
    (list (read-from-string
    (concatenate 'string "AVERAGE-OF-"
   (string-upcase attribute-name))))
    nil nil nil nil '(30) t t card)))
    (return-from average 0))))

(defun maximum (relation-name attribute-name &rest keyword-list
&key &optional where by tuples &allow-other-keys
&aux  rel-tuple-list tuples? agg-tuples by? card)
  "Maximum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose maximum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group maximum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table."
  where by tuples
  (block maximum
(if (not (setf rel-tuple-list (aggregate-utility relation-name attribute-name keyword-list)))
    (return-from maximum nil))
(setf card (car rel-tuple-list)
      rel-tuple-list (second rel-tuple-list))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
(setf tuples? (car (get-keyword-value '(tuples) (setf keyword-list (get-keyword-value-prereq
     '(tuples where by)
     keyword-list)))))
(if (setf by? (car (get-keyword-value '(by) keyword-list)))
    (progn
      (if (listp by?)
  (setf by? (car by?)))
      (setf by? (string-upcase by?))
      (mapc #'(lambda (tuple &aux agg-tuple)
(if (setf agg-tuple (assoc (car tuple) agg-tuples :test 'equal))
    (if (gtp (cadr tuple) (cadr agg-tuple))
(setf (cadr agg-tuple) (cadr tuple)))
    (setf agg-tuples (cons (list (car tuple) (cadr tuple)) agg-tuples))))
    rel-tuple-list)
      (if (not agg-tuples)
  (return-from maximum nil))
      (if tuples?
  (return-from maximum agg-tuples)
  (return-from maximum (printrel-internal* relation-name agg-tuples
      (list by? (read-from-string
  (concatenate 'string "MAXIMUM-OF-"
       (string-upcase attribute-name))))
      nil nil nil nil '(20 30) t t card))))
    (setf agg-tuples rel-tuple-list))
(if tuples?
    (return-from maximum (maximum-internal (mapcar #'(lambda (tuple)
  (car tuple))
      agg-tuples)))
    (return-from maximum (printrel-internal*
      relation-name (list (list (maximum-internal (mapcar #'(lambda (tuple)
      (car tuple))
  agg-tuples))))
      (list (read-from-string (concatenate 'string "MAXIMUM-OF-" (string-upcase attribute-name))))
      nil nil nil nil '(30) t t card)))
(return-from maximum nil)))

(defun maximum-internal (values &aux temp-max)
  (setf temp-max (car values))
  (mapc (function (lambda (value)
    (if (gtp value temp-max)
(setf temp-max value))))
values)
  temp-max)

(defun minimum (relation-name attribute-name &rest keyword-list
&key &optional where by tuples &allow-other-keys
&aux  rel-tuple-list tuples? agg-tuples by? card)
  "Minimum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose minimum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group minimum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table."
  where by tuples
  (block minimum
    (if (not (setf rel-tuple-list (aggregate-utility relation-name attribute-name keyword-list)))
      (return-from minimum nil))
    (setf card (car rel-tuple-list)
  rel-tuple-list (second rel-tuple-list))
    (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
   ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf tuples? (car (get-keyword-value '(tuples) (setf keyword-list (get-keyword-value-prereq
       '(tuples where by) keyword-list)))))
  (if (setf by? (car (get-keyword-value '(by) keyword-list)))
      (progn
(if (listp by?)
    (setf by? (car by?)))
(setf by? (string-upcase by?))
(mapc #'(lambda (tuple &aux agg-tuple)
(if (setf agg-tuple (assoc (car tuple) agg-tuples :test 'equal))
    (if (ltp  (cadr tuple) (cadr agg-tuple))
(setf (cadr agg-tuple) (cadr tuple)))
    (setf agg-tuples (cons (list (car tuple) (cadr tuple)) agg-tuples))))
    rel-tuple-list)
       (if (not agg-tuples) (return-from minimum nil))
       (if tuples?
  (return-from minimum agg-tuples)
(return-from minimum (printrel-internal* relation-name agg-tuples
    (list by? (read-from-string
(concatenate 'string "MINIMUM-OF-"
     (string-upcase attribute-name))))
    nil nil nil nil '(20 30) t t card))))
      (setf agg-tuples rel-tuple-list))
  (if tuples?
  (return-from minimum (minimum-internal (mapcar #'(lambda (tuple)
(car tuple))
    agg-tuples)))
(return-from minimum (printrel-internal*
  relation-name (list (list (minimum-internal (mapcar #'(lambda (tuple)
  (car tuple))
      agg-tuples))))
  (list (read-from-string (concatenate 'string "MINIMUM-OF-" (string-upcase attribute-name))))
  nil nil nil nil '(30) t t card)))
    (return-from minimum nil)))

(defun minimum-internal (values &aux temp-min)
  (setf temp-min (car values))
  (mapc (function (lambda (value)
    (if (ltp value temp-min)
(setf temp-min value))))
values)
  temp-min)

(defun relationp (relation)
  (caar (qtrieve 'system-relation *system-relation-attributes* '("RELATION-NAME") *system-relation-key*
 (list 'string-equal 'relation-name (string-upcase relation)))))

(defun size (relation-name &rest keyword-list
     &key &optional unique where &allow-other-keys
     &aux rel-tuple-list)
  "Number of tuples in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation whose size is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying tuples will be used."
  unique where
  (if (not (setf rel-tuple-list (aggregate-utility (read-from-string (string-upcase relation-name))
   nil keyword-list)))
      nil
      (length (second rel-tuple-list))))


(defun between (value lower-bound upper-bound)
  "Checks if a given value is between two bounds.

   VALUE - Any value.
   LOWER-BOUND - Lower bound value.
   UPPER-BOUND - Upper bound value."
  (or (and (gep value lower-bound) (lep value upper-bound))
      (and (gep value upper-bound) (lep value lower-bound))))


(defun sum (relation-name attribute-name &rest keyword-list
&key &optional unique where by tuples &allow-other-keys
&aux  rel-tuple-list (result 0) tuples? agg-tuples by? card)
  "Sum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose sum is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group sum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table."
  unique where by tuples
  (block sum
    (if (not (setf rel-tuple-list (aggregate-utility relation-name attribute-name keyword-list)))
      (return-from sum nil))
    (setf card (car rel-tuple-list)
  rel-tuple-list (second rel-tuple-list))
    (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
   ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf tuples? (car (get-keyword-value '(tuples) (setf keyword-list (get-keyword-value-prereq
       '(tuples where by unique)
       keyword-list)))))
  (if (setf by? (car (get-keyword-value '(by) keyword-list)))
      (progn
(if (listp by?)
    (setf by? (car by?)))
(setf by? (string-upcase by?))
       (mapc #'(lambda (tuple &aux agg-tuple)
(if (not (numberp (cadr tuple)))
  (progn
    (if *provide-error-messages*
(format *standard-output*
"~%ERROR -- Can not find the sum for ~S in the relation ~S because ~S is not a number."
attribute-name relation-name (car tuple)))
    (return-from sum nil)))
(if (setf agg-tuple (assoc (car tuple) agg-tuples :test 'equal))
    (setf (cadr agg-tuple) (+ (cadr agg-tuple) (cadr tuple)))
    (setf agg-tuples (cons tuple agg-tuples))))
    rel-tuple-list)
       (if (not agg-tuples) (return-from sum 0))
       (if tuples?
  (return-from sum agg-tuples)
(return-from sum (printrel-internal* relation-name agg-tuples
    (list by? (read-from-string (concatenate 'string
  "SUM-OF-" (string-upcase  attribute-name))))
    nil nil nil nil '(20 30) t t card))))
      (setf agg-tuples rel-tuple-list))
  (mapc (function (lambda (tuple)
      (if (not (numberp (car tuple)))
  (progn
    (if *provide-error-messages*
(format *standard-output*
"~%ERROR -- Can not find the sum for ~S in the relation ~S because ~S is not a number."
attribute-name relation-name (car tuple)))
    (return-from sum nil)))
      (setf result (+ result (car tuple)))))
  agg-tuples)
  (if tuples?
      (return-from sum result)
    (return-from sum (printrel-internal* relation-name (list (list result))
    (list (read-from-string (concatenate 'string
      "SUM-OF-" (string-upcase attribute-name))))
    nil nil nil nil '(30) t t card)))))

(deff rtms-count 'count-rtms)
(defun count-rtms (relation-name attribute-name &rest keyword-list
&key &optional unique where by tuples &allow-other-keys
&aux  rel-tuple-list (result 0) tuples? agg-tuples by? card)
  "Number of the values of a given attribute in a relation satisfying a where clause.
   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose count is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group count of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table."
  unique where by tuples
  (block count-rtms
    (if (not (setf rel-tuple-list (aggregate-utility relation-name attribute-name keyword-list)))
      (return-from count-rtms nil))
    (setf card (car rel-tuple-list)
  rel-tuple-list (second rel-tuple-list))
    (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
   ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf tuples? (car (get-keyword-value '(tuples) (setf keyword-list (get-keyword-value-prereq
       '(tuples where by unique)
       keyword-list)))))
  (if (setf by? (car (get-keyword-value '(by) keyword-list)))
      (progn
(if (listp by?)
    (setf by? (car by?)))
(setf by? (string-upcase by?))
       (mapc #'(lambda (tuple &aux agg-tuple)
 (if (setf agg-tuple (assoc (car tuple) agg-tuples :test 'equal))
     (setf (cadr agg-tuple) (incf (cadr agg-tuple)))
     (setf agg-tuples (cons (list (car tuple) 1) agg-tuples))))
     rel-tuple-list)
       (if (not agg-tuples)
   (return-from count-rtms 0))
       (if tuples?
  (return-from count-rtms agg-tuples)
(return-from count-rtms (printrel-internal* relation-name agg-tuples
    (list by? (read-from-string (concatenate 'string
  "COUNT-OF-" (string-upcase attribute-name))))
    nil nil nil nil '(20 30) t t card)))))
;
  (setf result (length rel-tuple-list))
  (if tuples?
      (return-from count-rtms result)
    (return-from count-rtms (printrel-internal* relation-name (list (list result))
    (list (read-from-string (concatenate 'string
      "COUNT-OF-" (string-upcase attribute-name))))
    nil nil nil nil '(30) t t card)))))
ces)
  (modify-hash relation where rel-key rel-attributes attributes values "LIST" dom-def indices))

(defun modify-hash (relation where-clause key attribute-list attributes values imp dom-def indices
    &aux (bucket nil) (sec-keys nil) (num-modified 0) (result nil) hash-tuples
    num-bucket-modified (table (getp relation 'entry-point)LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540698. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "DOMAIN" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359820. :AUTHOR "REL3" :LENGTH-IN-BYTES 9014. :LENGTH-IN-BLOCKS 18. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8DOMAIN\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPÁVALUE-DOMAINPF@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\VALB:B:B:LISTP,STRINGP,NUMBERPATOMANYP571OfBPRTMS-EQUALPOgEQUALP-RTMSBgOg*EQUALPBg+h` F=$B:BV]FB:B:B:BYFB^Bg\&RESTVALSB:\BsVAL1VAL2DOM1DOM2ÀVAL-LCVALS-LEFTB:\)MACROS-EXPANDED\SECONDFIRSTPROGSETF*PKG-STRING**PROVIDE-ERROR-MESSAGES*TERPRIERROR - Only one value provided, need at least two to compare.WRITE-STRINGBPҬANYPpB\STRING-EQUAL*STRINGEQUAL-CONCATENATEҪFIND-SYMBOLҬATOM,STRINGPÁEQUAL-STRINGP@QESEÊCES5EQ@ÊCPR@QF9FSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQGRCQP
DQP
DQP
CQP
AQBQRFFQCSOBgCEQUAL-ANYP	FF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:LISTBhQQOBCEQUAL-ATOMFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:B11Q+^11R77QQ77ROBEQUAL-LISTP@F$B:BV]FB:B:B:BYFB^B\ÀLIST1ÀLIST2B:\BuBvCV1CV2\B|\BBBiQQCBBS@CSA@AR@QAQRBCBCSOBÁEQUAL-NUMBERPFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:Q+^OBBFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:BQQOBGEP4|` FH$B:BV]FB:B:B:BYFB^B\BrBsB:\BsBuBvBwBxByBzB:\B|\B~BBBBBBERROR - Only one value provided, need at least two to compare.BBPҬANYPBBGE-BB
LISTP,NUMBERPATOM,STRINGPCGE-STRINGP@QESEÊCES5EQ@ÊCPR@QFKFSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQG(RDQP
RCQP
DQP
CQP
RCQP
DQP
DQP
CQP
AQBQRFFQCSOBGE-ANYP	FF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:B҃GTPQQOBGE-ATOM&FF$B:BV]FB:B:B:BYFB^B\BuBvB:B:\B|\BBҪSTRING-LESSPB1
1QQyCQ+^1S1RQQÀQQQOBGE-LISTP'@F$B:BV]FB:B:B:BYFB^B\BBB:\BuBvÀIS-GEBB\B|\BBBBiQQDCCS@DSAS@R@QAQB@QAQRCDBCDSOBCGE-NUMBERPFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:QQyCQ+^OBBFF	$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:BBQQQQOBB4|` FH$B:BV]FB:B:B:BYFB^B\BrBsB:\BsBuBvBwBxByBzB:\B|\B~BBBBBBERROR - Only one value provided, need at least two to compare.BBPҬANYPBBGT-BB
LISTP,NUMBERPATOM,STRINGPCGT-STRINGP@QESEÊCES5EQ@ÊCPR@QFKFSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQG(RDQP
RCQP
DQP
CQP
RCQP
DQP
DQP
CQP
AQBQRFFQCSO,BGT-ANYP	FF$B:BV]FB:B:B:BYFB^B-\BuBvB:B:B:BB钀QQO6B-GT-ATOMFF$B:BV]FB:B:B:BYFB^B7\BuBvB:B:B:B11Q#^1S1RQQO@B7GT-LISTP+@F$B:BV]FB:B:B:BYFB^BA\BBB:\BuBvÀIS-GTBB\B|\BBBBiQQDCCS@DSAS@R@QAQB@QAQRCDBCDBSRONBACGT-NUMBERPFF$B:BV]FB:B:B:BYFB^BO\BuBvB:B:B:Q#^OXBOB+FF$B:BV]FB:B:B:BYFB^B+\BuBvB:B:B:BQQOaB+LEP4|` FH$B:BV]FB:B:B:BYFB^Bb\BrBsB:\BsBuBvBwBxByBzB:\B|\B~BBBBBBERROR - Only one value provided, need at least two to compare.BBPҬANYPBBLE-BB
LISTP,NUMBERPATOM,STRINGPCLE-STRINGP@QESEÊCES5EQ@ÊCPR@QFKFSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQG(RCQP
RDQP
CQP
DQP
RCQP
DQP
DQP
CQP
AQBQRFFQCSOvBbLE-ANYP	FF$B:BV]FB:B:B:BYFB^Bw\BuBvB:B:B:BBbQQOBwLE-ATOM&FF$B:BV]FB:B:B:BYFB^B\BuBvB:B:\B|\BBBB11QQxCQ+^1S1RQQQQQQOBLE-LISTP)@F$B:BV]FB:B:B:BYFB^B
\BBB:\BuBvÀIS-LEBB\B|\BBLTPBiQQDCCS@DSA@SAR@QAQB@QAQRCDBCDSOB
CLE-NUMBERPFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:QQxCQ+^OBBuFF	$B:BV]FB:B:B:BYFB^Bu\BuBvB:B:B:BBQQQQOBuB4|` FH$B:BV]FB:B:B:BYFB^B\BrBsB:\BsBuBvBwBxByBzB:\B|\B~BBBBBBERROR - Only one value provided, need at least two to compare.BBPҬANYPBBLT-BB
LISTP,NUMBERPATOM,STRINGPCLT-STRINGP@QESEÊCES5EQ@ÊCPR@QFKFSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQG(RCQP
RDQP
CQP
DQP
RCQP
DQP
DQP
CQP
AQBQRFFQCSOBLT-ANYP	FF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:BBQQOBLT-ATOMFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:B11Q%^1S1RQQOBLT-LISTP+@F$B:BV]FB:B:B:BYFB^B\BBB:\BuBvÀIS-LTBB\B|\BBBBiQQDCCS@DSA@SAR@QAQB@QAQRCDBCDBSROBCLT-NUMBERPFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:Q%^OBBFF$B:BV]FB:B:B:BYFB^B\BuBvB:B:B:BQQOBNOTP	`F$B:BV]FB:B:B:BYFB^B\BrBsB:\BsByBz\B|\BBB@QASAÊCAQ@BBRBSOBCAGGREGATE-UTILITY)VՆ)F$B:BV]FB:B:B:BYFB^B\ÁRELATION-NAMEATTRIBUTE-NAMESKEYWORD-LISTB:\ÁRELATION-TUPLEÁREL-TUPLE-LISTCWHERE-LISTÀUNIQUECINDEX-NAMEÁATTRIBUTE-LISTDOMAINS-LISTKEY-LISTREL-IMPREL-STOCBYCARDÁKEY-VALUE-LISTBB:ATTR\B|\	pZLC,DO-NAMEDSIXTHFIFTHFOURTHTHIRDB~BBBaBу*ACTIVE-DB*BACTIVE-DATABASE҃VALIDATE-SYMB\ÀWHEREBBÀTUPLESGET-KEYWORD-VALUE-PREREQ\B.CGET-KEYWORD-VALUE\B\B\lATTRIBUTES,DOMAINSKEYIMPLEMENTATION-TYPElSTORAGE-STRUCTURECARDINALITYGET-RELATIONBERROR - The relation BSTRING-UPCASE*READ-FROM-STRINGPRIN1, is not defined in the database \B:CCONVERT-ATTRIBUTESҪSTRING-EQUALpB\MEMBER-TESTERROR - The attribute  is not defined in e.jWRITE-CHAR҆EXTRACT-KEYBlRETRIEVE-l-BB
ÁUNIQUE-TUPLESRQR5Q	QMSMMS5MQ
PQPQBBPQBCPQBJJ5JSJJJQ]QPB@PQPPR@SE@WF@[G@QBH@UBI@YBKQ,EQQNNSOEQPPOQPQP RNQEQGQFQIQBQ!P"PAGILD#P$PHQ%PIQ&P'NQEQQGQBQLQDQJNA
CAQ(AAKQAQ	ROPBAVERAGE p F$B:BV]FB:B:B:BYFB^BQ\BÁATTRIBUTE-NAMEBrB&KEYj&OPTIONALBB.BB/j&ALLOW-OTHER-KEYSB:\BBB.BB/BÀRESULTSIZETUPLES?CAGG-TUPLESBY?BBB:ÀTUPLECAGG-TUPLEB:B:\B|\pBTINHIBIT-STYLE-WARNINGSINCFBB$BB~BDOCUMENTATIONAverage of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose average is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group average of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.AB\UNIQUEWHEREiBYTUPLESpB\STORE-KEYARGSB\B/\B/B.BBB0B2\BB>BERROR -- Can not find the average for BB@l in the relation B?l because l is not a number.pB\ASSOC-EQUALBFLOATBAVERAGE-OF-B\FFCPRINTREL-INTERNAL*\F@@QPAFG߀QQ@QERESKEWE@QLSLLS5LQ@P	P@Q
@BHP@QBJuJ5JSJJQJEQM8MSNONWuPQPQPNSPRNSIQOOWOQ	BNWaOQBOQBOQBkBNSNWJI]IMIMMIQQPPQQSNNSNQ	BNQBdCCPQQMQEHEQEQJQPPQPKQJEQPPSNNSuPQPQPNSPRNSFaFGPJG'HFQGQdCQFQGQdCPPQPOBQMAXIMUMNFf$B:BV]FB:B:B:BYFB^B\
BBZBrBB[B\B.BB/B]B:\BB.BB/BBaBbBcBBB:BdBeB:B:B:\B|\BiB$BB~BBkMaximum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose maximum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group maximum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.A\BpBqBrBtB\B/\B/B.BB0B2\BB>B}BBBMAXIMUM-OF-BB?\FFBMAXIMUM-INTERNAL\F@@QPAQQ@QDRDSHDWD@QISIIS5IQ@PP@Q	@
BEP@Q
BG;G5GSGGQGDQJJSKLKSFQLKWLW	LUKWKSKWF]FJFREFQFQGQPPQPHQJDQFEJJFQNMMQNSBCMNNJQQNNFQJOOQJSBCOJJNQPPQPOBB@LF$B:BV]FB:B:B:BYFB^B\VALUESB:\TEMP-MAXB:ÀVALUE\B|\BB$BB钀S@QA	ASB@QBQ@A@OBMINIMUMNFf$B:BV]FB:B:B:BYFB^B\
BBZBrBB[B\B.BB/B]B:\BB.BB/BBaBbBcBBB:BdBeB:B:B:\B|\BiB$BB~BBkMinimum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose minimum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group minimum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.A\BpBqBrBtB\B/\B/B.BB0B2\BB>B}BBBMINIMUM-OF-BB?\FFBMINIMUM-INTERNAL\F@@QPAQQ@QDRDSHDWD@QISIIS5IQ@PP@Q	@
BEP@Q
BG;G5GSGGQGDQJJSKLKSFQLKWLW	LUKWKSKWF]FJFREFQFQGQPPQPHQJDQFEJJFQNMMQNSBCMNNJQQNNFQJOOQJSBCOJJNQPPQPOBB@LF$B:BV]FB:B:B:BYFB^B\BB:\TEMP-MINB:B\B|\BB$BBS@QA	ASB@QBQ@A@OBCRELATIONPF@F$B:BV]FB:B:B:BYFB^B\RELATIONB:B:B:Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*SYSTEM-RELATION\RELATION-NAMEBDBB>BQTRIEVEPPPPPPQ	
BOBB`
`PF$B:BV]FB:B:B:BYFB^B`\BBrBB[B\BB.B]B:\BBB.B\B|\B~BBkNumber of tuples in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation whose size is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying tuples will be used.\BoBpBtB>B?B@@QPAQ@QCRCWCOB`BETWEENFF$B:BV]FB:B:B:BYFB^B\BLOWER-BOUNDUPPER-BOUNDB:B:\BkChecks if a given value is between two bounds.

   VALUE - Any value.
   LOWER-BOUND - Lower bound value.
   UPPER-BOUND - Upper bound value.BBbQQQQQQQQOBSUMVˆFu$B:BV]FB:B:B:BYFB^B\BBZBrBB[B\BB.BB/B]B:\BBB.BB/BB_BaBbBcBBB:BdBeB:\B|\B$BB~BBk	Sum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose sum is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group sum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.AB\BoBpBqBrBtB\B/\B/B.BBB0B2\BB>BlERROR -- Can not find the sum for BB@l in the relation l because l is not a number.B}B,SUM-OF-BB?B\FFB\F@@QPAF߀QQ@QERESJEWE@QKSKKS5KQ@P	P@Q
@BGP@QBILI5ISIIQIEQL(LSMNMWuPQPQPMSPRMSHQNNUNWMWaMQH]HLHGHQHQIQPPQPJQJEQHOOSMMSuPQPQPMSPRMSFaFOGFQFQPPQPO"BCCOUNT-RTMSO#CRTMS-COUNTB#>`FT$B:BV]FB:B:B:BYFB^B#\BBZBrBB[B\BB.BB/B]B:\BBB.BB/BB_BaBbBcBBB:BdBe\B|\BjB$BB~BBkNumber of the values of a given attribute in a relation satisfying a where clause.
   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose count is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group count of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.\BoBpBqBrBtB\B/\B/B.BBB0B2\BB>B}BBlCOUNT-OF-BB?\FFB\F@@QPAF߀QQ@QERESJEWE@QKSKKS5KQ@PP@Q@	BG
P@Q	BI:I5ISIIQIEQLLSMNMSHQNNUNUNWkBMSJH]HLHGHQHQIQPPQPJQJEQCFGFQFQPPQPO<B#1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\BjEz\Bi(̢\B(:}n\B'x\B&Zi\B%{Ĳ\B$*j\B[\B=#\Bz(\B~{     rel-tuple-list)
       (if (not agg-tuples) (return-from average 0))
       (setf rel-tuple-list
     (mapcar #'(lambda (tuple)
 (list (car tuple) (/ (first (cadr tuple)) (float (second (cadr tuple))))))
     agg-tuples))
       (if tuples?
   (return-from average rel-tuple-list)
   (return-from average (printrel-internal* relation-name rel-tuple-list
       (list by? (read-fLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540701. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "EXTENSIONS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846087. :AUTHOR "REL3" :LENGTH-IN-BYTES 3639. :LENGTH-IN-BLOCKS 4. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved

;1;;INITIAl-VALIDATION*
;1;;*
;1;; This purpose of this function is to provide initial validation (error checking) for certain parameters. These types of checks are common*
;1;; across many of the user callable functions in RTMS.*
;1;;   (1) Checks for active-database*
;1;;   (2) Converts the name passed nto a string*
;1;;   (3) Takes care of nesting of parens in the keyword-list*
;1;;   (4) Sends the keyword list through the get-keyword-prereq cycle*
;1;;   (5) Obtains information about the relation sent.*

(defun initial-validation (relation-name keyword-list keyword-list-prereq info-attribute-list
   &optional (relation-name-stringp nil))
  (let (relation-info)
    (cond ((not *parameter-checking*)
   (setf  keyword-list (de-nest-keyword-list keyword-list)
  relation-info (car (qtrieve 'system-relation *system-relation-attributes* info-attribute-list
     *system-relation-key*
     `(string-equal relation-name  ,(string relation-name))))))
  ((or (not (active-database relation-name))
       (not (setf relation-name (validate-name relation-name))))
   (setf relation-name nil))
  (t
   ;1; Remove levels of parens which might be present. This is here to support the pre-released version where the user was*
   ;1; required to include all of the keywords in a list. NLMENU is one example which requires this to remain.*
   (setf keyword-list (get-keyword-value-prereq keyword-list-prereq (de-nest-keyword-list keyword-list))
 relation-info (car (qtrieve 'system-relation *system-relation-attributes* info-attribute-list
     *system-relation-key*
     `(string-equal relation-name  ,(string relation-name)))))))
    (if (and relation-name relation-name-stringp)
(setf relation-name (string-upcase relation-name)))
    (values relation-name keyword-list relation-info)))

(defun de-nest-keyword-list (keyword-list)
  (do ((keyword-list keyword-list (car keyword-list)))
    ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))

(defun move-relation (relation-name &optional  &key (direction 'out))
  (cond ((equalp direction 'out)
 (mapc (function (lambda (system-relation-name)
   (putp relation-name (retrieve system-relation-name 'tuples t
 'where `(string-equal relation-name
       ,(string relation-name)))
 system-relation-name)))
       '(system-relation system-attribute system-index))
 (putp (concatenate 'string "MOVE-" (string relation-name)) (getp relation-name 'entry-point)
       'entry-point))
((equalp direction 'in)
 (mapc (function (lambda (system-relation-name)
   (if (getp relation-name system-relation-name)
       (insert system-relation-name
       'tuples (getp relation-name system-relation-name)))))
       '(system-relation system-attribute system-index))
 (putp relation-name (getp (concatenate 'string "MOVE-" (string relation-name)) 'entry-point)
       'entry-point))))

(defun database-modifiedp ()
  (let ((modified-relation-list nil))
    (mapc (function (lambda (%tuple)
      (if (car %tuple)
  (setf modified-relation-list (cons (cadr %tuple) modified-relation-list)))))
  (retrieve 'system-relation 'project '(modifiedp relation-name) 'tuples t))
    modified-relation-list))


(defun get-attributes (relation-name)
  (caar (qtrieve 'system-relation *system-relation-attributes* '(attributes) *system-relation-key*
`(string-equal relation-name ,(string relation-name)))))
B:B:B:BYFB^B\BrBsB:\BsBuBvBwBxByBzB:\B|\B~BBBBBBERROR - Only one value provided, need at least two to compare.BBPҬANYPBBGT-BB
LISTP,NUMBERPATOM,STRINGPCGT-STRINGP@QESEÊCES5EQ@ÊCPR@QFKFSAFWBAQCBQDCQ	P
DQ	P
RCQDQ
PPCQPGAQBQG(RDQP
RCQP
DQP
CQP
RLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540704. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "EXTENSIONS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359728. :AUTHOR "REL3" :LENGTH-IN-BYTES 1233. :LENGTH-IN-BLOCKS 3. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         pp2\COMPILE-DATA\SW-MFG,GODZILLA@FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lEXTENSIONS\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPCINITIAL-VALIDATION;F&$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEKEYWORD-LISTKEYWORD-LIST-PREREQINFO-ATTRIBUTE-LISTj&OPTIONAL\ÂRELATION-NAME-STRINGPB:B:\ÁRELATION-INFO\)MACROS-EXPANDED\pB\lXR-BQ-LISTSETFÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PARAMETER-CHECKING*DE-NEST-KEYWORD-LISTACTIVE-DATABASEÁVALIDATE-NAMEGET-KEYWORD-VALUE-PREREQSYSTEM-RELATIONSTRING-EQUALB`STRINGҪLISTQTRIEVESTRING-UPCASEQQQQQ	
PPQPPPQB@QQQ@QO|BPBr@DF$B:BV]FB:B:B:BYFB^Br\BaB:\Ba\Bj\PROGQ@S@@S5@OBrÁMOVE-RELATION"Y`TF7$B:BV]FB:B:B:BYFB^B\B`Bd&KEY\CDIRECTION\B8OUTB:\B:BB:SYSTEM-RELATION-NAMEB:\Bj\BmBpZLC,DO-NAMEDB\iDIRECTIONpB\STORE-KEYARGS\BvSYSTEM-ATTRIBUTESYSTEM-INDEXÀTUPLESÀWHEREBwB`BxByRETRIEVE҃PUTPMOVE-pBTSTRING-APPEND҃ENTRY-POINTGETPCINÀINSERTPA@@QPAAQ,PBBSCQCQPP	P
PQCQBPQQPPAQ,PDDSCQCQCQPQCQDQPQROBCDATABASE-MODIFIEDP	@F$B:BV]FB:B:B:BYFB^BB:B:\ÂMODIFIED-RELATION-LISTB:À%TUPLE\Bj\BnBBBvPROJECT\CMODIFIEDPB`BBPPPPA	ASBBBW@]@A@OBÁGET-ATTRIBUTESF@F$B:BV]FB:B:B:BYFB^B\B`B:B:\Bj\BmBoBpBv\CATTRIBUTESBwB`BxByBzPPPPPPQ	
BOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B*j\B=#\Bn[\Bm.ً
       ,(string relation-name)))
 system-relation-name)))
       '(system-relation system-attribute system-index))
 (putp (concatenate 'string "MOVE-" (string relation-name)) (getp relation-name 'entry-point)
       'entry-point))
((equalp direction 'in)
 (mapc (function (lambda (system-relation-name)
   (if (getp relation-name system-relation-name)
       (insert system-relation-name
       'tuples (getp relation-name system-relation-name)))))
       '(system-relation system-attribute system-index))
 (putp relation-name (getp (concatenate 'string "MOVE-" (string relatLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540708. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "GLOBAL-FUNCTIONS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2753963282. :AUTHOR "REL3" :LENGTH-IN-BYTES 65836. :LENGTH-IN-BLOCKS 65. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; GLOBAL-FUNCTIONS*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     arglist*
;1;;     fs:directory-list*
;1;;     errset*
;1;;     ed*
;1;;     tyo*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     project-flavor-prereq*
;1;;     fast-project-flavor*
;1;;     put-flavor*
;1;;     qtrieve-flavor-hash*
;1;;     qtrieve-flavor-heap*
;1;;     qtrieve-flavor-avl*
;1;;     project-flavor*
;1;;*
;;;  Change History
;;;  04.09.87  MRR  Changed a line in HELP-ATTRIBUTE, so that print-width is not made into a mouse-sensitive item.
;;;                     Fixed MODIFY-TRANSACTION and SAVE-TRANSACTION so that the fs:directory-list works for remote files, too.


(defun dbp (&optional (operation nil))
  (active-database operation))

(defun active-db (&optional (operation nil))
  (active-database operation))

(defun active-dbp (&optional (operation nil))
  (active-databasep operation))

(defun active-database (&optional (operation nil) &aux active-system-relations)
  ;1;*
  ;1; Determine if the system relations have been completely defined*
  ;1;*
  (cond (*restore-operation*
 t)
(t
 (setf active-system-relations
       (mapcar (function (lambda (sys-rel)
   (not (and (not (getp sys-rel 'entry-point))
     (not (string-equal sys-rel "SYSTEM-VIEW"))
     (not (string-equal sys-rel "SYSTEM-2INDEX*"))))))
       *system-relations*))
 (setf active-system-relations (not (member 'nil active-system-relations)))
 (cond ((or (null *active-db*)
    (and (null active-system-relations) (not (member operation *system-relations*
     :test 'string-equal))))
(cond ((and *provide-error-messages*
    (and (not (string-equal operation "DEFDB"))
 (not (string-equal operation "RESTORE"))))
       (format *standard-output*  "~%ERROR - There is currently no active database")
       (format *standard-output*
       "~%        Please either restore a saved database or define a new one")))
(recover-all)
nil)
       (t
*active-db*)))))

(defun active-databasep (&optional (operation nil) &aux active-system-relations)
  ;1;*
  ;1; Determine if the system relations have been completely defined*
  ;1;*
  (cond (*restore-operation*
 t)
(t
 (setf active-system-relations
       (mapcar (function (lambda (sys-rel)
   (not (and (not (getp sys-rel 'entry-point))
     (not (string-equal sys-rel "SYSTEM-VIEW"))
     (not (string-equal sys-rel "SYSTEM-2INDEX*"))))))
       *system-relations*))
 (setf active-system-relations (not (member 'nil active-system-relations)))
 (cond ((or (null *active-db*)
    (and (null active-system-relations) (not (member operation *system-relations*
     :test 'string-equal))))
(recover-all)
nil)
       (t
*active-db*)))))

(defun anyp (value)
  value
  t)

(defun domain-check (attributes attr-fun attr-dom values &aux original-fun)
  (block domain-check
   (mapc (function (lambda (value attr fun dom)
     (setf original-fun fun)
     (if (setf fun (find-symbol (string-upcase fun) "GLOBAL"))
 fun
 (setf fun (find-symbol (string-upcase original-fun) *pkg-string*)))
     (cond ((null (funcall fun value))
    (if *provide-warning-messages*
(format *standard-output*
"~%WARNING - ~s is not a legal value for the ~s attribute whose domain is ~s"
value (read-from-string attr) (read-from-string dom)))
    (return-from domain-check nil)))))
 values attributes attr-fun attr-dom)
   (return-from domain-check t)))

(defun project-tuples (tuples attribute-list imp relation-name)
  ;;
  ;;  Convert the tuples into a list-heap format so that they may be processed
  ;;
  (if (not (string-equal "LIST" imp))
      (funcall (find-symbol (concatenate 'string "PROJECT-" imp) *pkg-string*) tuples attribute-list
       attribute-list relation-name)
      tuples))

(defun eval-where (tuples attribute-list where-clause imp relation-name
   &aux temp-attribute-list)
  (if (not (string-equal imp "LIST"))
      (setf tuples (project-tuples tuples attribute-list imp relation-name)))  ;;
  ;;  Determine if the tuples may be returned unchaged.
  ;;
  (cond ((or (null tuples) (equal where-clause t))
 tuples)
((not (listp where-clause))
 (if (eval where-clause)
     tuples
     nil))
(t
 (multiple-value-setq (where-clause temp-attribute-list)
      (eval-where-prereq where-clause attribute-list relation-name))
 (fast-eval-where tuples where-clause temp-attribute-list))))

(defun eval-where-prereq (where-clause attribute-list relation-name
  &aux reader-package-name temp-attribute-list)
  ;;
  ;;  Determine if any optimization may be performed on the where clause. This is usually dealing with
  ;1; *aggregrate functions.
  ;;
  (cond ((symbolp relation-name)
 (setf reader-package-name (package-name (symbol-package relation-name))))
(t
 (setf reader-package-name *pkg-string*)))
  (if (not (equal where-clause t))
      (setf where-clause (parse-where where-clause)))
  ;;
  ;;  Determine the attributes which have global variables defined for them. These1 *will have to be take into
  ;1; *account in the where clause since it comes  from the reader.
  ;;
 (setf temp-attribute-list
       (mapcar #'(lambda (attr &aux global-attr)
   ;1; This currently has a problem in that if a relaiton name is contained in the global package this will cause a*
   ;1; problem. The only solution seems to rewrite eval-where to parse the where-clause and locate the attributes*
   ;1; which are used and there package.*
   (if (setf global-attr (find-symbol (string-upcase attr) "GLOBAL"))
       global-attr
       (read-from-string (concatenate 'string reader-package-name ":" attr))))
       attribute-list))
  (values where-clause temp-attribute-list))

(defun fast-eval-where (val-list where-clause temp-attribute-list
&aux (result nil))
 (progv temp-attribute-list nil
  (mapc
    (function (lambda (%tuple)
(mapc #'(lambda (x z)
  (set x z))
      temp-attribute-list %tuple)
(if (eval where-clause)
    (setf result (cons %tuple result)))))
    val-list))
  (reverse result))

(defun get-directory (keyword-list &optional (default-directory nil)
      &aux directory num dir)
  (cond ((null (setf directory (car (get-keyword-value '(dir) keyword-list))))
 (setf directory (or default-directory *save-directory* (concatenate 'string user-id ";"))))
((not (stringp directory))
 (setf directory (string directory))
 (cond ((and (null (search ";" directory)) (null (search "." directory)))
(setf directory (concatenate 'string directory ";")))))
((and (null (search ";" directory)) (null (search "." directory)))
 (setf directory (concatenate 'string directory ";"))))
  (if (setf num (search ":;" directory))
      (setf directory (concatenate 'string (subseq directory 0 (1+ num)) user-id ";")))
  (setf directory (fs:parse-pathname directory))
  (concatenate 'string (send (send directory :host) :short-name) ":"
       (if (setf directory (send directory :directory))
   (if (listp directory)
       (progn
 (setf dir (concatenate 'string (car directory)))
 (mapc #'(lambda (sub-dir)
   (setf dir (concatenate 'string dir "." sub-dir)))
       (cdr directory))
 dir)
       directory)
   user-id)
       ";"))

(defun get-keyword-value (keyword-list keyword-value-list
  &aux (result nil) (temp-result nil) key-found exit-var string-value
  default-variable)
  (setf keyword-list (convert-attributes keyword-list))
  (do ((keyword keyword-list (cdr keyword)))
      ((null keyword) (nreverse result))
    (setf key-found nil)
    (setf temp-result (do ((value-list keyword-value-list (cddr value-list)))
  ((or (null value-list) key-found) exit-var)
(if (not (listp (car value-list)))
    (setf string-value (string-upcase (car value-list))))
(if (setf key-found (equal (search (car keyword) string-value) 0))
    (setf exit-var (cadr value-list))
    (setf exit-var nil))))
    (setf result (if (null key-found)
     (progn
       (setf default-variable (read-from-string (concatenate 'string *pkg-name* "*"
     (car keyword) "*")))
1         *;1that keyword is not in keyword-value-list. value will be default value*
       (cons (if (boundp default-variable)
 (symbol-value default-variable)
 *default-keyword-value*)
     result))
     (cons temp-result result)))))


(defun get-keyword-value-prereq (command-keywords-list keyword-value-list
 &aux  (result nil) this-is-keyword (first-is-keyword nil)  first-value-list
 second-value-list third-value-list second-is-keyword third-is-keyword
 first-value)
  ;;
  ;;1 the keyword-value-list has to begin with a keyword to be treated*
  ;;
  ;;1  The keywords are made into string so that complications will not arise from keywords being interned into a different package.*
  (setf command-keywords-list (mapcar (function (lambda (%keyword)
  (string-upcase %keyword)))
      command-keywords-list))
  ;;
  ;;1  Remove any extra sets of parens that may be around the keyword list which may be there if the macro version of the function is*
  ;1; called also for older versions of RTMS which allow the keyword list to really be a list of keywords.*
  ;;
  (setf keyword-value-list (do ((value-list (de-nest-keyword-list keyword-value-list) (cdr value-list)))
       ((or (null value-list) first-is-keyword (equal value-list '(nil)))
(if first-is-keyword
    (cons first-value value-list)
    nil))
     (setf this-is-keyword nil)
     (if (and (first value-list)
      (or (symbolp (first value-list)) (stringp (first value-list))))
 (progn
   (setf first-value-list (string-upcase (first value-list))
 first-value (car value-list))))
     (setf first-is-keyword (and (first value-list) (symbolp (first value-list))
1  *;;1 This "DO" is to allow to use abbreviated keywords*
 (do ((commands command-keywords-list (cdr commands)))
     ((or (null commands) this-is-keyword)
      this-is-keyword)
   (setf this-is-keyword (equal
   (search (car commands)
   first-value-list)
   0)))))
     (if (not first-is-keyword)
 (if *provide-warning-messages*
     (format *standard-output* "~%WARNING unrecognized keyword -->~S"
     (car value-list))))))
  (do ((value-list keyword-value-list (cddr value-list)))
      ((null value-list) (nreverse result))
    (setf third-is-keyword nil)
    (do () (third-is-keyword)
      (setf second-is-keyword nil)
      (cond
   ;1third word is a keyword*
   ((and (third value-list) (symbolp (third value-list))
 (setf third-value-list (string-upcase (third value-list)))
 (do ((commands command-keywords-list (cdr commands)))
     ((or (null commands) third-is-keyword) third-is-keyword)
   (setf third-is-keyword (equal (search (car commands) third-value-list) 0))))
    nil)
   ;;1 no value for that keyword. add default value to keyword-value-list. I had to change the test (NOT(SECOND value-list))*
   ;1; because it didn't allowed to have the last value of keyword-value-list equal to NIL.*
   ((equal (length value-list) 1)   ;1no value for the last keyword*
    (setf second-value-list (string-upcase (second value-list))
  first-value-list (string-upcase (first value-list)))
    (cond ((and (symbolp (second value-list)) ;1next word: keyword instead of value*
     (do ((commands command-keywords-list (cdr commands)))
 ((or (null commands) second-is-keyword) second-is-keyword)
       (setf second-is-keyword (and (equal (search (car commands) second-value-list) 0)
    (not (equal (search (car commands) first-value-list)
0))))))
   (setf third-is-keyword t)
1    *;;
   ;;1  There is a problem here if the keyword is the same as the global variable*
   ;;1 *
   (setf value-list
 (cons (car value-list)
       (cons (if (boundp (read-from-string (concatenate 'string *pkg-name* "*"
first-value-list "*")))
 (symbol-value (read-from-string (concatenate 'string *pkg-name* "*"
      first-value-list "*")))
 *default-keyword-value*)
     (cdr value-list)))))))
   ;1last pair of keyword-value-list*
   ((not (third value-list))
    (setf third-is-keyword t))
   ;1third word will be ignored as it and second word are not keyword*
   (t
    (if *provide-warning-messages*
(format *standard-output* "~%WARNING unrecognized keyword -->~S" (third value-list)))
    (setf value-list (cons (first value-list) (cons (second value-list) (cdddr value-list)))))))
    (setf result (cons (second value-list)(cons (first value-list) result)))))

(defun rtms-describe (&optional object &rest ignore)
  (help object))

(defun help (&optional object &rest ignore)
  (if object (help-object (string-upcase object))
    (if (not (car (errset (send *output-window* ':exposed-p) nil)))
(format *standard-output*  "~&(HELP <object>) will provide help on <object>.")
  (format *typeout-window*"~&
  You are in the user interface to the database. The interaction pane
  is used to accept your input and the results are displayed in the output window.
  Any trivial output is displayed in the typeout window and when
  you type in any character the typeout window disappears.

  The interface menu is at the bottom. In the submenu \"help\" the menu item
  \"inspect-dbms-object\" lets you seek information on any database object
  (currently - a relation, command or an attribute). If the object is any
  database command, syntax for that command is provided. In the submenu \"help\"
  the menu item \"introduction\" prints out this information.

  The menu item \"command-menu\" pops up a menu of all database
  commands and when a command is selected all the input data required
  to execute that command is obtained using a choose-variables-value
  window and the command is executed. The menu item \"exit\" allows you to exit
  the interface by burying it and the item \"kill\" kills the interface process.
  The item \"display\" lets you scroll in the output window. For more information
  on any of these items, see the documentation provided by the command tables.

  Each of the attribute names  and relation names is made mouse-sensitive. If you
  click on any mouse-sensitive item, either that item is inspected or some stated
  (as seen in the who-line-documentation) operation is performed. Each line of
  display is sensitive to line-area-scrolling and clicking the left button in the
  zone of line-area-scrolling (when -> appears) on any line will cause the
  entire line to be displayed in the typeout-window.

  The interaction pane runs under universal command loop. It has preemptable read
  facility - lets you typein part of a lisp expression and click on a menu or
  a mouse-sensitive item and when the execution of the mouse command is over,
  continue with the unfinished expression. It also has command completion
  capability and pops up a choose-variables-values window if all the arguments are
  not provided."))))

;**************************************************************************
;1             Functions used in inspecting database objects.                       **
;**************************************************************************
(defun help-object (object
    &aux attribute-list (found-object nil) help-object atomic-object (db-test t) out-window
    attribute-test)
 (block help-object
       (if (not (active-database))
   (return-from help-object nil))
       (setf out-window (car (errset (send *output-window* ':exposed-p) nil)))
       (cond ((null (setf object (validate-sym object t)))
      (return-from help-object nil)))
1        *(setf db-test nil
     attribute-test nil
     atomic-object (read-from-string object))
       ;;
       ;;1  Determine if the type of the object and call the appropriate function. It is possible that the name is used for more than one*
       ;1; object.*
       ;;
       (cond-every ((string-equal object *active-db*)
    (help-database out-window atomic-object)
    (setf found-object t))
   (t
    ;;
    ;;1  Determine if the object name is a relation or an attribute*
    ;;
    (mapc (function
    (lambda (systup &aux rel)
      (cond-every ((string-equal
     (setf rel (caar (project-list (list systup)
   *system-relation-attributes*
   '("RELATION-NAME"))))
     object)
   (help-relation out-window object
  (car (project-list (list systup)
     *system-relation-attributes*
     '("MODIFIEDP"
       "SAVE-DIRECTORY"
       "IMPLEMENTATION-TYPE"
       "STORAGE-STRUCTURE"
       "KEY"
       "TUPLE-FORMAT"
       "DOC"
       "CARDINALITY"
       "ATTRIBUTES"))))
   (setf found-object t))
  (t
   (setf attribute-list (caar (project-list
(list systup)
*system-relation-attributes*
'("ATTRIBUTES"))))
   (cond ((member object attribute-list :test 'string-equal)
  (help-attribute out-window object rel attribute-test)
  (setf attribute-test t)))))))
  (qtrieve 'system-relation *system-relation-attributes* *system-relation-attributes*
   *system-relation-key* t)))
   ;;
   ;;1  Determine if the object is a view*
   ;;
   ((setf help-object (assoc object (qtrieve 'system-view *system-view-attributes*
      *system-view-attributes* *system-view-key* t)
     :test 'string-equal))
    (help-view out-window help-object atomic-object)
    (setf found-object t))
   ;;
   ;;1  Determine if the object is an index*
   ;;
   ((setf help-object
  (funcall
    (find-symbol (concatenate 'string "2RETRIEVE-"* *system-relation-base-implementation*
"2-"* *system-relation-storage-structure*) *pkg-string*)
    'system-index *system-index-attributes* *system-index-attributes* *system-index-key*
    `(string-equal index-name ,(string-upcase object))
    nil 'system-index))
    (help-index out-window help-object atomic-object)
    (setf found-object t))
   ;;
   ;;1  Determine if the object is an implementation*
   ;;
   ((setf help-object (assoc object (qtrieve 'system-implementation
     *system-implementation-attributes*
     *system-implementation-attributes*
     *system-implementation-key* t)
     :test 'string-equal))
    (help-implementation out-window help-object atomic-object)
    (setf found-object t))
   ;;
   ;;1  Determine if the object is a storage-structure*
   ;;
   ((setf help-object (assoc object (qtrieve 'system-storage-structure
     *system-storage-structure-attributes*
     *system-storage-structure-attributes*
     *system-storage-structure-key* t)
     :test 'string-equal))
    (help-storage-structure out-window help-object atomic-object)
    (setf found-object t))
   ;;
   ;;1  Determine if the object is a domain*
   ;;
   ((setf help-object (assoc object (qtrieve 'system-domain *system-domain-attributes*
     *system-domain-attributes*
     *system-domain-key* t)
     :test 'string-equal))
    (help-domain out-window help-object atomic-object)
    (setf found-object t))
   ;;
   ;;1  Determine if the object is a function*
   ;;
   ((functionp object)
    (help-function out-window atomic-object)
    (setf found-object t)))
    (cond ((or found-object attribute-test)
   (return-from help-object object))
  (t
   (if out-window
       (format *typeout-window*  "~%~S is not a valid object in the database ~S."
       (read-from-string object) (read-from-string *active-db*))
       (format *standard-output* "~%~S is not a valid object in the database ~S."
       (read-from-string object) (read-from-string *active-db*)))
   (return-from help-object nil)))))

;**************************************************************************
;1           The object is a relation.                                              **
;**************************************************************************
(defun help-relation (out-window object qtrieve-var
       &aux dir imp ss key tup-fmt doc card attr atomic-object indices)
  (setf dir (second qtrieve-var)
imp (third qtrieve-var)
ss (fourth qtrieve-var)
key (fifth qtrieve-var)
tup-fmt (sixth qtrieve-var)
doc (seventh qtrieve-var)
card (nthcdr 7 qtrieve-var)
attr (second card)
card (first card)
atomic-object (read-from-string object)
indices(qtrieve '2system-index* *system-index-attributes* *system-index-attributes* *system-index-key*
 `(string-equal relation-name ,(string-upcase object))))
  (cond (out-window
 (scroll-to-bottom)
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item  (list (list ':item1 atomic-object 'relation) " is a relation"))
 (send *output-window* ':append-item  (format nil "Characteristics of this relation are :"))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item (list "Database :   "
   (list ':item1 (read-from-string *active-db*) 'database)))
 (send *output-window* ':append-item (list (list ':item1 'attributes 'attribute) "  : "))
 (mapcar (function (lambda (atr)
     (send *output-window* ':append-item (list " : " (list ':item1 atr 'attribute)))))
 attr)
 (send *output-window* ':append-item
       (list (list ':item1 'implementation-type 'attribute) "  : " (list ':item1 imp 'dbms-object)))
 (send *output-window* ':append-item
       (list (list ':item1 'storage-structure 'attribute) "  : " (list ':item1 ss 'dbms-object)))
 (send *output-window* ':append-item
       (list (list ':item1 'cardinality 'attribute) "  : " (list card card)))
 (send *output-window* ':append-item
       (list (list ':item1 'save-directory 'attribute) "  : " (list dir dir)))
 (send *output-window* ':append-item
       (list (list ':item1 'tuple-format 'attribute) "  : " (list tup-fmt tup-fmt)))
 (send *output-window* ':append-item
       (list (list ':item1 'key 'attribute) "  : " (list key key)))
 (send *output-window* ':append-item
       (list (list ':item1 'doc 'attribute) "umentation: " (list doc doc)))
 (cond (indices
(send *output-window* ':append-item
      (list (list ':item1 'secondary-indices 'attribute) "  : "))
(mapcar (function (lambda (index)
    (send *output-window* ':append-item
  (list "                  "
(list ':item1 (second index) 'attribute)))))
indices))))
(t
 (format *standard-output* "~% ")
 (format *standard-output* "~%~S is a relation." atomic-object)
 (format *standard-output* "~%Characteristics of this relation are :")
 (format *standard-output* "~%~%Database : ~s" (read-from-string *active-db*))
 (format *standard-output* "~%~%Attributes: ")
 (mapcar (function (lambda (atr)
     (format *standard-output* "~%      ~S" atr)))
 attr)
 (format *standard-output* "~%Implementation type: ~S" imp)
 (format *standard-output* "~%Storage structure: ~S" ss)
 (format *standard-output* "~%Cardinality: ~S" card)
 (format *standard-output* "~%Save-Directory: ~S" dir)
 (format *standard-output* "~%Tuple-Format: ~S" tup-fmt)
 (format *standard-output* "~%Key: ~S" key)
 (format *standard-output* "~%Documentation: ~S" doc)
 (cond (indices
(format *standard-output* "~%2Secondary Indices*: ")
(mapcar (function (lambda (index)
    (format *standard-output* "~%      ~S" (second index))))
indices))))))

;**************************************************************************
;1           The object is an attribute                                             **
;**************************************************************************
(defun help-attribute (out-window object relation attribute-test
       &aux  doc qtrieve-var dom def rel)
  (setf qtrieve-var (car (qtrieve 'system-attribute *system-attribute-attributes*
  '(relation-name domain-function default-value doc )
  *system-attribute-key*
  `(and (string-equal relation-name ,(string relation))
(string-equal attribute-name ,(string object))))))
  (setf dom (second qtrieve-var)
def (third qtrieve-var)
doc (fourth qtrieve-var)
rel (first qtrieve-var))
  (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes* '(attributes tuple-format)
  *system-relation-key*
  `(string-equal relation-name ,(string-upcase relation)))))
  (cond (out-window
 (send *output-window* ':append-item " ")
 (cond (attribute-test
(send *output-window* ':append-item  (format nil "~S is a duplicate attribute." object)))
       (t
(scroll-to-bottom)
(send *output-window* ':append-item (format nil "~S is an attribute." object))))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item (format nil "It has the following characteristics." ))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item
       (list (list ':item1 'relation-name 'attribute) "  : " (list ':item1 relation 'relation)))
 (send *output-window* ':append-item
       (list (list ':item1 'domain-function 'attribute) "  : " (list ':item1 dom 'dbms-object)))
 (send *output-window* ':append-item
       (list (list ':item1 'default-value 'attribute) "  : " (list def def)))
 (setf def (caar (project-list (cdr qtrieve-var) (car qtrieve-var) (list object))))
 (send *output-window* ':append-item
       (list (list ':item1 'print-width 'other-info) "  : " (list def def)));mrr 04.09.87
 (send *output-window* ':append-item
       (list (list ':item1 'doc 'attribute) "umentation  : " (list doc doc))))
(t
 (format *standard-output* "~% ")
 (cond (attribute-test
(format *standard-output* "~S is a duplicate attribute." object))
       (t
(format *standard-output* "~%~S is an attribute." object)))
 (format *standard-output* "~% ")
 (format *standard-output* "~%It has the following characteristics. ")
 (format *standard-output* "~%Relation-name  : ~S" relation)
 (format *standard-output* "~%Domain-function  : ~S" dom)
 (format *standard-output* "~%Default-value  : ~S" def)
 (setf def (caar (project-list (cdr qtrieve-var) (car qtrieve-var) (list object))))
 (format *standard-output* "~%Print-width    : ~s" def)
 (format *standard-output* "~%Documentation  : ~S" doc))))


(defun parse-where (where-c &aux a-list by? where-clause)
  (block parse-where
  (setf where-clause (copy-list where-c))
  (cond ((null where-clause)
 (return-from parse-where where-clause))
((listp (car where-clause))
 (return-from parse-where where-clause))
((and (not (stringp (car where-clause))) (not (symbolp (car where-clause))))
 (return-from parse-where where-clause))
((member (string-upcase (car where-clause)) *where-opt-macros* :test 'string-equal)
 (setf a-list (eval (append where-clause (list 'tuples t))))
 (cond ((setf by? (member 'by where-clause :test 'member-pkgind))
(if (listp (setf by? (cadr by?)))
    (setf by? (car by?)))
(setf a-list (list 'cadr (list 'assoc (read-from-string (string-upcase by?))
       `(quote ,a-list))))))
 (return-from parse-where a-list))
((member (string-upcase (car where-clause)) *where-opt* :test 'string-equal)
 (setf a-list (eval (append where-clause (list '(quote tuples) t))))
 ;;
 ;;  Need to determine if there is a by clause and pull out the attribute name for use in the
 ;1; *association list
 ;;
 (cond ((setf by? (member 'by where-clause :test 'member-pkgind))
(if (listp (setf by? (cadr (cadr by?))))
    (setf by? (car by?)))
(setf a-list (list 'cadr (list 'assoc (read-from-string (string-upcase by?))
       `(quote ,a-list))))))
 (return-from parse-where a-list)))
  (do ((sub-clause (cdr where-clause) (cdr sub-clause)))
      ((null sub-clause) t)
    (cond ((listp (car sub-clause))
   (rplaca sub-clause (parse-where (car sub-clause))))))
  (return-from parse-where where-clause)))


(defun member-pkgind (item1 item2)
  (cond ((and (listp item2) (equal 'quote (car item2)))
 (setf item2 (cadr item2))))
  (cond ((or (listp item1) (listp item2))
 (equal item1 item2))
(t
 (string-equal (string-upcase item1) (string-upcase item2)))))

(defun project-array (tuples attribute-list project-list &optional relation-name)
  relation-name
  (project-list tuples attribute-list project-list))

(defun project-flavor (tuples attribute-list project-list &optional relation-name)
  relation-name attribute-list
  (setf project-list (project-flavor-prereq project-list))
  (fast-project-flavor tuples project-list))

(defun project-flavor-prereq (project-list)
  (mapcar #'(lambda (attr)
   (read-from-string (concatenate 'string ":" (string-upcase attr))))
project-list))

(defun fast-project-flavor (tuples project-list)
  (mapcar (function (lambda (tuple)
      (mapcar (function (lambda (attr)
  (funcall tuple attr)))
      project-list)))
  tuples))



(defun project-list (tuples attribute-list project-attr-list
     &optional relation-name &aux attribute-length)
  relation-name
  (cond ((equal attribute-list project-attr-list)
 tuples)
(t
 (setf attribute-length (length attribute-list))
 (setf project-attr-list (mapcar (function (lambda (attr &aux pos)
     (setf pos (- attribute-length
  (length
    (member attr attribute-list
    :test 'string-equal))))))
       project-attr-list))
 (mapcar (function (lambda (tuple)
     (mapcar (function (lambda (attr-pos)
 (nth attr-pos tuple)))
     project-attr-list)))
 tuples))))

(defun project-struct (tuples attribute-list project-list relation-name)
  attribute-list
  (let ((string-relation-name (string relation-name)))
    (setf project-list (unconvert-attributes (mapcar #'(lambda (attr)
 (concatenate 'string string-relation-name
      (string attr))) project-list))))
  (mapcar (function (lambda (tuple)
      (mapcar (function (lambda (attr)
  (funcall attr tuple)))
      project-list)))
  tuples))

(defun put-array (relation-name array-attribute-init-list
  &aux array-name current-point)
  ;;
  ;;1form the array name and current-point. *
  ;
  (multiple-value-setq (array-name)
       (intern (read-from-string (concatenate 'string relation-name "ARRAY"))))
  (multiple-value-setq (current-point)
    (intern (read-from-string (concatenate 'string relation-name "CURRENT-POINT"))))
  ;;
  ;;1Call the function to do the insertion.*
  ;;
  (put-array* (symbol-value array-name) (symbol-value current-point) array-attribute-init-list)
  ;;
  ;;1Increment the current-point.*
  ;;
  (set current-point (+ (symbol-value current-point) 1))
  ;;
  ;;1Return the row in which this tuple was stored.*
  ;;
  (- (symbol-value current-point) 1))

(defun put-array* (array-name current-point attribute-init-list)
  ;;
  ;;1if the current-point equals current-size increase the size of the array*
  ;;
  (cond ((equal current-point (array-total-size array-name))
   (adjust-array array-name (+ (array-total-size array-name) 10))))
  ;;
  ;;1Store the tuple in the array.*
  ;;
  (setf (aref array-name current-point) attribute-init-list))


(defun put-flavor (relation-name attr-list attribute-init-list &aux tuple)
  (setf tuple (make-instance (read-from-string (string-upcase relation-name))))
  (do ((attribute-init-list attribute-init-list (cdr attribute-init-list))
       (attr-list attr-list (cdr attr-list)))
      ((null attribute-init-list) tuple)
     (set-in-instance tuple (read-from-string (string-upcase (car attr-list))) (car attribute-init-list)))
  tuple)

 (defun put-struct (relation-name attr-list attribute-init-list
    &aux structure-tuple alter-macro temp1 temp2)
   ;;
   ;;1make an instance of the relation-structure.*
   ;;
  (setf structure-tuple  (eval `(,(read-from-string (concatenate 'string "MAKE-" relation-name)))))
   ;;
   ;;1Form the name of the macro to be used to set the values in the instance.*
   ;;
  (setf alter-macro (read-from-string (concatenate 'string "ALTER-" relation-name)))
  ;;
  ;;1Set the attribute values in the instance. (Initialize)*
  ;;
  (do ((attribute-init-list attribute-init-list (cdr attribute-init-list))
       (attr-list attr-list (cdr attr-list)))
      ((null attribute-init-list) structure-tuple)
    (setf temp1 (read-from-string (concatenate 'string (string relation-name) (car attr-list)))
  temp2 (car attribute-init-list))
    (eval `(,alter-macro structure-tuple ,temp1 temp2)))
  structure-tuple)

(defun getp (relation-name property)
  (get (find-symbol (string relation-name) *pkg-string*)
       (find-symbol (string property) *pkg-string*)))

(defun putp (relation-name value property)
  (if (not (find-symbol (string relation-name) *pkg-string*))
      (intern (string relation-name) *pkg-string*))
  (putprop (find-symbol (string relation-name) *pkg-string*)
   value
   (find-symbol (string property) *pkg-string*)))

(defun qtrieve (relation-name attribute-list project-list secondary-key where-clause)
  (if (equal where-clause t)
      (funcall (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation*
    "-" *system-relation-storage-structure*) *pkg-string*)
       relation-name attribute-list project-list secondary-key where-clause nil relation-name)
      (funcall (find-symbol (concatenate 'string "QTRIEVE-" *system-relation-base-implementation*
    "-" *system-relation-storage-structure*) *pkg-string*)
       relation-name attribute-list project-list secondary-key where-clause)))

;1;*;1  A simplification may be made by enforcing the rule which us stated for all QTRIEVEs, the where-clause is assumed to be an AND-EQUAL *
;1;; clause containing all of the attributes contained in the secondary-key. Thus the where-clause specifies a single bucket. The tuples in the *
;1;; bucket do not necessarly satisfy  the where-clause however and each tuple in the bucket must be checked for validity.*
;1;*;
(defun qtrieve-flavor-hash (relation-name attribute-list project-list secondary-key where-clause
    &aux (key nil) result)
  secondary-key
  (do ((where-c (cdr where-clause) (cdr where-c)))
      ((null where-c) t)
    (cond ((listp (car where-c))
   (setf key (append key (list (caddar where-c)))))
  (t
   (setf key (append key (list (cadr where-c))))
   (setf where-c (cdddr where-c)))))
  (setf result (eval-where (gethash key (getp relation-name 'entry-point))
   attribute-list where-clause "FLAVOR" relation-name))
  (project-list result attribute-list project-list))

(defun qtrieve-flavor-heap (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (getp relation-name 'entry-point)))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list  attribute-list where-clause "FLAVOR" relation-name)
    attribute-list project-list)
      (project-flavor tuple-list attribute-list project-list relation-name)))

(defun qtrieve-struct-avl (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (avl-inorder-traversal (getp relation-name 'entry-point))))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list  attribute-list where-clause "2STRUCT*" relation-name)
    attribute-list project-list)
      (project-struct tuple-list attribute-list project-list relation-name)))

(defun qtrieve-list-avl (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (avl-inorder-traversal (getp relation-name 'entry-point))))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list  attribute-list where-clause "2LIST*" relation-name)
    attribute-list project-list)))

(defun qtrieve-flavor-avl (relation-name attribute-list project-list  secondary-key where-clause
    &optional (tuple-list (avl-inorder-traversal (getp relation-name 'entry-point))))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list  attribute-list where-clause "FLAVOR" relation-name)
    attribute-list project-list)
      (project-flavor tuple-list attribute-list project-list relation-name)))


(defun qtrieve-list-hash (relation-name attribute-list project-list secondary-key where-clause
  &aux (key nil) result)
  secondary-key
  (do ((where-c (cdr where-clause) (cdr where-c)))
      ((null where-c) t)
    (cond ((listp (car where-c))
   (setf key (append key (list (caddar where-c)))))
  (t
   (setf key (append key (list (cadr where-c))))
   (setf where-c (cdddr where-c)))))
  (setf result (eval-where (gethash key (getp relation-name 'entry-point)) attribute-list where-clause "LIST"
   relation-name))
  (project-list result attribute-list project-list))

(defun qtrieve-list-heap (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (getp relation-name 'entry-point)))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list attribute-list where-clause "LIST" relation-name)
    attribute-list project-list)))


(defun qtrieve-struct-hash (relation-name attribute-list project-list secondary-key where-clause
    &aux (key nil) result)
  secondary-key
  (do ((where-c (cdr where-clause) (cdr where-c)))
      ((null where-c) t)
    (cond ((listp (car where-c))
   (setf key (append key (list (caddar where-c)))))
  (t
   (setf key (append key (list (cadr where-c))))
   (setf where-c (cdddr where-c)))))
  (setf result
(eval-where (gethash key (getp relation-name 'entry-point)) attribute-list where-clause "STRUCT"
    relation-name))
  (project-list result attribute-list project-list))

(defun qtrieve-struct-heap (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (getp relation-name 'entry-point)))
  secondary-key
  (if tuple-list
      (project-list (eval-where tuple-list attribute-list where-clause "STRUCT" relation-name)
      attribute-list project-list)
      (project-struct tuple-list attribute-list project-list relation-name)))

(defun validate-name (object-name &optional (donot-flag-error nil))
  ;1;*
  ;1;  List testing needs to be done before the actual name can be validated*
  ;1;*
  (cond ((and (listp object-name) (string-equal "QUOTE" (car object-name)))
 (setf object-name (cadr object-name)))
((and (listp object-name) (equal (length object-name) 1))
 (setf object-name (car object-name))))
  (cond ((not (atom object-name))
 (cond ((and (not donot-flag-error) *provide-error-messages*)
(format *standard-output* "~%ERROR - improperly specified name --> ~s" object-name)
(setf object-name nil))))
((stringp object-name)
 (setf object-name (read-from-string object-name))))
  object-name)

(defun validate-sym (object-name &optional (allow-strings nil))
  ;1;*
  ;1;  List testing needs to be done before the actual name can be validated*
  ;1;*
  (cond ((and (listp object-name) (string-equal "QUOTE" (car object-name)))
 (setf object-name (cadr object-name))))
  (cond ((and (symbolp object-name) (not allow-strings)))
((and allow-strings (or (symbolp object-name)(stringp object-name)))
 (setf object-name (string-upcase object-name)))
(t
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - Improperly specified name --> ~s" object-name)
(format *standard-output* "~%        All names in RTMS must be SYMBOLS")))
 (setf object-name nil)))
  object-name)

(defun define-transaction (transaction forms &rest keyword-list
   &key &optional directory pathname
   &allow-other-keys
   &aux dir)
  "Define a transaction, a list of database calls.

   TRANSACTION - Name of the transaction.
   FORMS       - List of RTMS calls.
   DIRECTORY   - Name of the directory in which this transaction will be stored.
   PATHNAME    - Name of the file in which it will be stored."
  directory pathname
  (block define-transaction
(if (not (active-database))
    (return-from define-transaction nil))
(cond ((null (setf transaction (validate-sym transaction t)))
       (return-from define-transaction nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
(setf keyword-list (get-keyword-value-prereq '(dir path) keyword-list))
(putp transaction (if (setf dir (car (get-keyword-value '(dir) keyword-list)))
      dir
      *save-directory*)
      ':save-directory)
(putp transaction (car (get-keyword-value '(path) keyword-list)) ':file)
(putp transaction forms ':forms)
(return-from define-transaction transaction)))

;1;*;1  *Unless you call an explicit (BEGIN-TRANSACTION), the forms in a given transaction1 *file are treated as a set
;1;; *of database calls. In effect, a sequence of db calls can be made to fall under the category of a transaction
;1;; *just by calling the1 *following function and the transaction period is over when you call1 *(END-TRANSACTION).
;1;*;1 *Just what exactly is a transaction?.1 *In our context, we will postpone all the disk modifiable functions
;1;; *until the1 *user ends the transaction. They include (as of now) all SAVE operations. Since1 *destroy operations
;1;; *call SAVE they are taken care of. If any files on the1 *disk are deleted due to any of the destroy operations
;1;; *(DISK T), they can1 *always be undeleted using DIRED.
(defun begin-transaction (&rest ignore)
   "Start transaction processing - postpone any save-related operations."
  (setf *transaction-on* t))

(defun end-transaction (&rest ignore)
  "End transaction processing. Revert to normal processing after executing any save-related operations
    postponed during transaction processing."
  (if *transaction-on*
      (progn
(setf *transaction-on* nil)
(mapc #'(lambda (x) (eval x))
      *transaction-forms-postponed*)
(setf *transaction-forms-postponed* nil))
      (progn
(if *provide-status-messages*
    (format *standard-output* "~%WARNING - There is no active transaction."))
nil)))

(defun abort-transaction (&rest ignore)
  "Abort the ongoing transaction processing - Do not perform any postponed save-related operations."
  (if (not *transaction-on*)
      (progn
(setf *transaction-on* nil)
(setf *transaction-forms-postponed* nil))
      (progn
(if *provide-status-messages*
    (format *standard-output* "~%WARNING - There is no active transaction."))
nil)))

(defun modify-transaction (transaction &rest keyword-list
   &key &optional directory pathname
   &allow-other-keys
   &aux dir file)
  "Edit the database calls in a transaction.
   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction can be found.
   PATHNAME    - Name of the file in which it is stored."
  directory pathname
  (block modify-transaction
(if (not (active-database))
    (return-from modify-transaction nil))
(cond ((null (setf transaction (validate-sym transaction t)))
       (return-from modify-transaction nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
(setf keyword-list (get-keyword-value-prereq '(dir path) keyword-list))
(if (not (getp transaction ':save-directory))
    (progn
      (setf file (or (car (get-keyword-value '(path) keyword-list))
     (concatenate 'string (if (setf dir (car (get-keyword-value '(dir) keyword-list)))
(get-directory keyword-list)
*save-directory*)
    transaction)))
      (if (probe-file file)
  (progn
    (ed (string-upcase file))
    (return-from modify-transaction transaction))
(progn
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The transaction file ~S does not exist; ~@
                              ~7T the transaction ~S has not been defined yet." file transaction))
  (return-from modify-transaction nil)))))

(if (not (probe-file (setf file (or (car (get-keyword-value '(path) keyword-list))
(if (setf dir (car (get-keyword-value '(dir) keyword-list)))
    (concatenate 'string (get-directory keyword-list) transaction))
   (getp transaction ':file)
   (concatenate 'string (getp transaction ':save-directory) transaction)))))
    (progn
      (unless (errset (fs:directory-list file) nil);mrr 04.09.87
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - The directory of file ~S does not exist." file))
(return-from modify-transaction nil))
      (with-open-file (path file :characters t :direction 'output)
(write-char #\( path)
(mapc #'(lambda (form)
  (print form path))
      (getp transaction ':forms))
(terpri)
(write-char #\) path))))

(ed (string-upcase file))
(return-from modify-transaction transaction)))

(defun save-transaction (transaction &rest keyword-list
 &key &optional directory pathname
 &allow-other-keys
 &aux dir file keys)
  "Save a transaction on disk.

   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction is to be stored.
   PATHNAME    - Name of the file in which it is to be stored."
   directory pathname
  (block save-transaction
(if (not (active-database))
    (return-from save-transaction nil))
(cond ((null (setf transaction (validate-sym transaction t)))
       (return-from save-transaction nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
(setf keys (copy-list keyword-list))
(if (not (getp transaction ':save-directory))
    (progn
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The transaction ~S has not been defined yet."
  transaction))
      (return-from save-transaction nil)))
(if *transaction-on*
    (progn
      (setf *transaction-forms-postponed* (append *transaction-forms-postponed*
  (list `(save-transaction ',transaction ',keys))))
      (return-from save-transaction transaction)))
(setf keyword-list (get-keyword-value-prereq '(dir path) keyword-list))
(setf file (or (car (get-keyword-value '(path) keyword-list))
       (if (setf dir (car (get-keyword-value '(dir) keyword-list)))
   (concatenate 'string (get-directory keyword-list) transaction))
       (getp transaction ':file)
       (concatenate 'string (getp transaction ':save-directory) transaction)))
(unless (errset (fs:directory-list file) nil);mrr 04.09.87
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The directory of file ~S does not exist." file))
  (return-from save-transaction nil))
(with-open-file (path file :characters t :direction :output)
  (write-char #\( path)
  (mapc #'(lambda (form) (print form path))
(getp transaction ':forms))
  (terpri)
  (write-char #\) path))
(return-from save-transaction transaction)))

(defun commit-transaction (transaction &rest keyword-list
   &key &optional directory pathname
   &allow-other-keys
   &aux dir path file forms)
  "Execute the database calls in a transaction.

   TRANSACTION - Name of the transaction to be commited.
   DIRECTORY   - Name of the directory in which this transaction can be found, if not in memory.
   PATHNAME    - Name of the file in which it can be found."
  directory pathname
  (block commit-transaction
(if (not (active-database))
    (return-from commit-transaction nil))
(cond ((null (setf transaction (validate-sym transaction t)))
       (return-from commit-transaction nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
(begin-transaction)
(setf keyword-list (get-keyword-value-prereq '(dir path) keyword-list))
(if (not (getp transaction ':save-directory))
    (progn
      (setf path (or (car (get-keyword-value '(path) keyword-list))
     (concatenate 'string (if (setf dir (car (get-keyword-value '(dir) keyword-list)))
(get-directory keyword-list)
*save-directory*)
    transaction)))
      (if (probe-file path)
  (progn
    (setf forms (rtms-read-insert-file path))
    (mapc #'(lambda (form) (eval form))
  forms)
           (end-transaction)
    (return-from commit-transaction transaction))
(progn
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The transaction file ~S does not exist; ~@
                              ~7T the transaction ~S has not been defined yet."
      path transaction))
  (end-transaction)
  (return-from commit-transaction nil)))))
(if (setf file
              (or (car (get-keyword-value '(path) keyword-list))
   (if (setf dir (car (get-keyword-value '(dir) keyword-list)))
       (concatenate 'string (get-directory keyword-list) transaction))))
    (if (probe-file file)
(putp transaction (rtms-read-insert-file file) ':forms)
(progn
  (if *provide-error-messages*
      (format *standard-output* "~%ERROR - The transaction file ~S does not exist." file))
  (end-transaction)
  (return-from commit-transaction nil)))
    (progn
      (setf file (or (getp transaction ':file)
     (concatenate 'string (getp transaction ':save-directory) transaction)))
      (if (probe-file file)
  (putp transaction (rtms-read-insert-file file) ':forms))))
(mapc #'(lambda (form) (eval form))
      (getp transaction ':forms))
(end-transaction)
(return-from commit-transaction transaction)))

(defun memtuple (tuple relation &aux where-clause)
  (setf where-clause
(cons 'and
      (mapcar #'(lambda (attr val)
  (list 'equal attr `(quote ,val)))
      (first (second (get-relation relation '(attributes) nil)))
      tuple)))
  (car (retrieve relation 'where where-clause 'tuples t)))

(defun dblessp (x y)
  (cond ((and (not (equal (type-of x) (type-of y))) (not (and (numberp x) (numberp y))))
 nil)
((numberp x)
 (<= x y))
((or (atom x) (stringp x))
 (or (string-lessp x y) (string-equal x y)))
((listp x)
 (and (equal (length x)(length y)) (apply 'and (mapcar #'(lambda (x1 y1) (dblessp x1 y1)) x y))))
(t
 nil)))

(defun dbgtp (x y)
  (cond ((and (not (equal (type-of x) (type-of y))) (not (and (numberp x) (numberp y))))
 nil)
((numberp x) (>= x y))
((or (atom x)
     (stringp x))
 (or (string-greaterp x y)
     (string-equal x y)))
((listp x) (and (equal (length x)(length y))
(apply 'and (mapcar #'(lambda (x1 y1) (dbgtp x1 y1))
    x y))))
(t nil)))

(defun quick-sort (tuples sort-attrs attributes
   &aux sort-attributes tuple-attributes)
  ;;
  ;;1 This is a temporary solution*
  ;;
  (setf sort-attributes sort-attrs
sort-attrs nil
tuple-attributes attributes
attributes nil)
  (do ((attribute% sort-attributes (cdr attribute%)))
      ((null attribute%) t)
    (cond ((listp (car attribute%))
   (setf sort-attrs (cons (list (read-from-string (caar attribute%)) (second (car attribute%)))
  sort-attrs)))
  ((stringp (car attribute%))
   (setf sort-attrs (cons (read-from-string (car attribute%)) sort-attrs)))
  (t
   (setf sort-attrs (cons (read-from-string (string (car attribute%)))
  sort-attrs)))))
  (do ((attribute% tuple-attributes (cdr attribute%)))
      ((null attribute%) t)
    (setf attributes (cons (read-from-string (car attribute%)) attributes)))
  (setf sort-attrs (reverse sort-attrs)
attributes (reverse attributes))
  (cond ((equal sort-attrs t)
 (sort tuples 'ltp))
(t
 (sort tuples
     #'(lambda (x y)
 (apply
   'and
   (mapcar
     #'(lambda
 (attr &aux (number (position (if (not (listp attr)) attr (car attr)) attributes)))
 (cond ((null number) t)
       ((equal attr (car sort-attrs))
(if (or (not (listp attr)) (null (cadr attr)))
    (ltp (nth number x) (nth number y))
  (funcall (cadr attr) (nth number x) (nth number y))))
       (t
(if (apply 'and
     (mapcar
       #'(lambda
   (at &aux num)
   (equal
     (nth
       (setf num (position (if (listp at) (car at) at)
   attributes))
       x)
     (nth num y)))
       (firstn (position attr sort-attrs)
 sort-attrs)))
      (if (or (not (listp attr))
      (null (cadr attr)))
  (ltp (nth number x) (nth number y))
(funcall (cadr attr) (nth number x)
 (nth number y)))
    t))))
     sort-attrs)))))))

(defun define-implementation (implementation-name &rest keyword-list
      &key &optional documentation
      &allow-other-keys
      &aux doc)
  "Define a new implementation.

   IMPLEMENTATION-NAME - Name of the implementation to be defined. All the implementation-specific
                         accessor functions are expected to be defined.
   DOCUMENTATION       - Description of this implementation."
  documentation
  (block define-implementation
(cond (*parameter-checking*
       (if (not (active-database implementation-name))
   (return-from define-implementation nil))))
(cond ((not (setf implementation-name (validate-sym implementation-name t)))
       (return-from define-implementation nil)))
;;
;;1Check to see if this implementation exists.*
(if (member (list implementation-name) (qtrieve 'system-implementation
*system-implementation-attributes*
 '(implementation-name)
 *system-implementation-key* t)
    :test 'equal)
    (progn
      (cond (*provide-error-messages*
     (format *standard-output*
     "~%ERROR - The implementation ~s already exists in the ~s database"
     implementation-name *active-db*)
      (format *standard-output*
     "~%        and may not be redefined")))
      (return-from define-implementation nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
;;
;;1 Everything seems to be in order, proceed*
;;
(if *provide-status-messages*
    (format *standard-output* "~%Define implementation ~s" implementation-name))
(setf keyword-list (get-keyword-value-prereq '(doc) keyword-list))
(setf doc (car (get-keyword-value '(doc) keyword-list)))
(insert 'system-implementation (list 'tuples (list (list implementation-name user-id doc))))
(if *provide-status-messages*
    (format *standard-output* "~%Definition of implementation ~s completed." implementation-name))
implementation-name))

(defun define-storage-structure (storage-structure-name &rest keyword-list
 &key &optional documentation
 &allow-other-keys
 &aux doc)
  "Define a new storage structure.

   STORAGE-STRUCTURE-NAME - Name of the storage-structure to be defined. All the storage-structure-specific
                            accessor functions are expected to be defined.
   DOCUMENTATION          - Description of this storage-structure."
  documentation
  (block define-storage-structure
(cond (*parameter-checking*
       (if (not (active-database storage-structure-name))
   (return-from define-storage-structure nil))))
(cond ((not (setf storage-structure-name (validate-sym storage-structure-name t)))
       (return-from define-storage-structure nil)))
;;1Check to see if this storage-structure exists.*
(if (member (list (setf storage-structure-name (string storage-structure-name)))
    (qtrieve 'system-storage-structure *system-storage-structure-attributes*
   '(storage-structure-name) *system-storage-structure-key* t)
    :test 'equal)
    (progn
      (cond (*provide-error-messages*
     (format *standard-output*
     "~%ERROR - The storage structure ~s already exists in the ~s database"
  storage-structure-name *active-db*)
     (format *standard-output*
  "~%        and may not be redefined")))
      (return-from define-storage-structure nil)))
(setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
       ((or (null keyword-list) (not (listp (car keyword-list)))) keyword-list)))
;;
;;1 Everything seems to be in order, proceed*
;;
(if *provide-status-messages*
    (format *standard-output* "~%Define storage-structure ~s" storage-structure-name))
(setf keyword-list (get-keyword-value-prereq  '(doc) keyword-list))
(setf doc (car (get-keyword-value '(doc) keyword-list)))
(insert 'system-storage-structure (list 'tuples (list (list storage-structure-name user-id doc))))
(if *provide-status-messages*
    (format *standard-output* "~%Definition of storage-structure ~s completed." storage-structure-name))
(return-from define-storage-structure storage-structure-name)))

(defun help-database (out-window atomic-object &aux (none t))
  (cond (out-window
 ;;
 ;;1  Send the output to the output window of the interface if the user is using the interface*
 ;;
 (scroll-to-bottom)
 (send *output-window* ':append-item (format nil "~S is the current database." atomic-object))
 (if *database-documentation* (send *output-window* ':append-item (format nil "~S"
  *database-documentation*))
     (send *output-window* ':append-item " "))
 (send *output-window* ':append-item (format nil "The relations in this database include:"))
 (send *output-window* ':append-item " ")
 ;;
 ;;1  Retrieve all of the relations in the current database and display the relations which are not system relations.*
 ;;
 (mapc (function (lambda (rel)
   (cond ((not (member (car rel) *system-relations* :test 'string-equal))
  (setf none nil)
  (send *output-window* ':append-item
(list (list ':item1  (read-from-string (car rel)) 'relation)))))))
       (qtrieve 'system-relation *system-relation-attributes* '("RELATION-NAME") *system-relation-key*
t))
 (if none
     (format *typeout-window* "~% There are no relations defined in ~S" (read-from-string *active-db*))
     (send *output-window* ':append-item " ")))
(t
 ;;
 ;;1  The user is not using the interface, therefore send all output to the standard output*
 ;;
 (format *standard-output* "~%~S is the current database." atomic-object)
 (if *database-documentation*
     (format *standard-output* "~%~S" *database-documentation*)
     (format *standard-output* "~% "))
 (format *standard-output* "~%The relations in this database include:")
 (format *standard-output* "~% ")
 (mapc (function (lambda (rel)
   (if (not (member (car rel) *system-relations* :test 'string-equal))
       (progn
 (setf none nil)
 (format *standard-output* "~%~S" (read-from-string (car rel)))))))
       (qtrieve 'system-relation *system-relation-attributes* '("RELATION-NAME") *system-relation-key*
t))
 (if none
     (format *standard-output* "~% There are no relations defined in ~S"
     (read-from-string *active-db*)))
 (format *standard-output* "~% "))))

(defun help-implementation (out-window implementation-name atomic-object)
  (cond (out-window
 (scroll-to-bottom)
 (send *output-window* ':append-item (format nil "~S is a type of implementation." atomic-object))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item
       (list (list ':item1 'owner-id 'attribute)
     (format nil ":  ~S" (read-from-string (cadr implementation-name)))))
 (send *output-window* ':append-item
       (list (list ':item1 'doc 'attribute)
     (format nil "UMENTATION:  ~S" (caddr implementation-name)))))
(t
 (format *standard-output* "~%~S is a type of implementation." atomic-object)
 (format *standard-output* "~% ")
 (format *standard-output* "~%OWNER-ID:  ~S" (read-from-string (cadr implementation-name)))
 (format *standard-output* "~%DOCUMENTATION:  ~S" (caddr implementation-name)))))

(defun help-storage-structure (out-window storage-structure atomic-object)
  (cond (out-window
 (scroll-to-bottom)
 (send *output-window* ':append-item (format nil "~S is a type of storage structure." atomic-object))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item
       (list (list ':item1 'owner-id 'attribute)
     (format nil ":  ~S" (read-from-string (cadr storage-structure)))))
 (send *output-window* ':append-item
       (list (list ':item1 'doc 'attribute) (format nil "UMENTATION:  ~S" (caddr storage-structure)))))
(t
 (format *standard-output* "~%~S is a type of storage structure." atomic-object)
 (format *standard-output* "~% ")
 (format *standard-output* "~%OWNER-ID:  ~S" (read-from-string (cadr storage-structure)))
 (format *standard-output* "~%DOCUMENTATION:  ~S" (caddr storage-structure)))))

(defun help-view (out-window view-name atomic-object)
  (cond (out-window
 (scroll-to-bottom)
 (send *output-window* ':append-item (format nil "~S is a view." atomic-object))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item
       (list (list ':item1 'view-definition 'attribute) (format nil ":  ~S" (cadr view-name))))
 (send *output-window* ':append-item
       (list (list ':item1 'owner-id 'attribute)
     (format nil ":  ~S" (read-from-string (caddr view-name)))))
 (send *output-window* ':append-item
       (list (list ':item1 'view-documentation 'attribute) (format nil ":  ~S" (cadddr view-name)))))
(t
 (format *standard-output* "~%~S is a type of view." atomic-object)
 (format *standard-output* "~% ")
 (format *standard-output* "~%VIEW DEFINITION:  ~S" (cadr view-name))
 (format *standard-output* "~%OWNER-ID:  ~S" (read-from-string (caddr view-name)))
 (format *standard-output* "~%VIEW DOCUMENTATION:  ~S" (cadddr view-name)))))

(defun help-index (out-window view-name atomic-object)
  (cond (out-window
 (scroll-to-bottom)
 (mapc (function (lambda (view-tuple)
   (send *output-window* ':append-item " ")
   (send *output-window* ':append-item " ")
   (send *output-window* ':append-item
 (format nil "~S is a2n* 2index on relation ~s*."
 atomic-object (read-from-string (first view-tuple))))
   (send *output-window* ':append-item " ")
   (send *output-window* ':append-item
 (list (list ':item1 'storage-structure 'attribute)
       (format nil ":  ~S" (read-from-string (third view-tuple)))))
   (send *output-window* ':append-item
 (list (list ':item1 'key 'attribute) (format nil ":  ~S" (fourth view-tuple))))
   (send *output-window* ':append-item
 (list (list ':item1 'priority 'attribute)
       (format nil ":  ~S" (fifth view-tuple))))
   (send *output-window* ':append-item
 (list (list ':item1 'doc 'attribute)
       (format nil ":  ~S" (sixth view-tuple))))))
       view-name))
(t
 (mapc (function (lambda (view-tuple)
   (format *standard-output* "~% ")
   (format *standard-output* "~% ")
   (format *standard-output* "~%~S is a2n index on relation ~s*."
   atomic-object (read-from-string (first view-tuple)))
   (format *standard-output* "~% ")
   (format *standard-output* "~%2STORAGE-STRUCTURE*:  ~S"
   (read-from-string (third view-tuple)))
   (format *standard-output* "~%2KEY*:  ~S"
   (fourth view-tuple))
   (format *standard-output* "~%2PRIORITY*:  ~S"
   (fifth view-tuple))
   (format *standard-output* "~%2DOC*:  ~S"
   (sixth view-tuple))))
       view-name))))

(defun help-domain (out-window domain-name atomic-object)
  (cond (out-window
 (scroll-to-bottom)
 (send *output-window* ':append-item (format nil "~S is a domain." atomic-object))
 (send *output-window* ':append-item " ")
 (send *output-window* ':append-item
       (list (list ':item1 'owner-id 'attribute)
     (format nil ":  ~S" (read-from-string (cadr domain-name)))))
 (send *output-window* ':append-item
       (list (list ':item1 'default-print-width 'attribute)
     (format nil ":  ~S" (caddr domain-name))))
 (send *output-window* ':append-item
       (list (list ':item1 'default-value 'attribute)
     (format nil ":  ~S" (cadddr domain-name))))
 (send *output-window* ':append-item
       (list (list ':item1 'doc 'attribute)
     (format nil "UMENTATION:  ~S" (fifth domain-name)))))
(t
 (format *standard-output* "~%~S is a domain." atomic-object)
 (format *standard-output* "~% ")
 (format *standard-output* "~%OWNER ID:  ~S" (read-from-string (cadr domain-name)))
 (format *standard-output* "~%DEFAULT PRINT WIDTH:  ~S" (caddr domain-name))
 (format *standard-output* "~%DEFAULT VALUE:  ~S" (cadddr domain-name))
 (format *standard-output* "~%DOCUMENATATION:  ~S" (fifth domain-name)))))

(defun help-function (out-window atomic-object)
  (cond (out-window
 (format *typeout-window* "~%~S is a function." atomic-object)
 (format *typeout-window* "~%~S" (documentation atomic-object))
 (format *typeout-window* "~%The syntax of ~S is:" atomic-object)
 (format *typeout-window* "~%~S" (cons atomic-object (arglist atomic-object))))
(t
 (format *standard-output* "~%~S is a function." atomic-object)
 (format *standard-output* "~%~S" (documentation atomic-object))
 (format *standard-output* "~%The syntax of ~S is:" atomic-object)
 (format *standard-output* "~%~S" (cons atomic-object (arglist atomic-object))))))
reduced.*
    ;;
    (cond ((<= (length beg-val-list) 1)
   (return-from reduce-avl-key (append (list extracted-key-attribute-list)
       (list beg-val-list)
       (list end-val-list)))))
    ;;
    ;;1  This is a test section of this function, it only looks at the first attribute of the key to determine the range of values which*
    ;1;will be selected.*
    ;;
    (do ((begval% beg-val-list (cdr begval%))
 (endval% end-val-list (cdr endval%)))
((null begval%) t)
      (setf normalized-key-list (append (list (list (car key-attribute-list))) normalized-key-list)
    normalized-begval-list (cons (list (caar begval%)) normalized-begval-list)
    normalized-endval-list (cons (list (caar endval%)LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540711. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "GLOBAL-FUNCTIONS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359740. :AUTHOR "REL3" :LENGTH-IN-BYTES 17705. :LENGTH-IN-BLOCKS 35. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 pp2\COMPILE-DATA\SW-MFG,GODZILLALFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8,GLOBAL-FUNCTIONS\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPDBP$F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\j&OPTIONAL\COPERATIONB:B:B:B:ACTIVE-DATABASEQOdBPCACTIVE-DB$F$B:BV]FB:B:B:BYFB^Be\B`\BbB:B:B:B:BcQOoBeCACTIVE-DBP$F$B:BV]FB:B:B:BYFB^Bp\B`\BbB:B:B:B:ACTIVE-DATABASEPQO{BpBc!WF6$B:BV]FB:B:B:BYFB^Bc\B`\BbB:B:\ACTIVE-SYSTEM-RELATIONSB:B:B:SYS-REL\)MACROS-EXPANDED\PROGpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSSETF*PROVIDE-ERROR-MESSAGES*у*ACTIVE-DB*C*SYSTEM-RELATIONS*у*RESTORE-OPERATION*ENTRY-POINTGETPҬSYSTEM-VIEWpB\STRING-EQUAL*ҬSYSTEM-INDEXSTRING-EQUALpB\MEMBER-TESTDEFDB,RESTORETERPRIERROR - There is currently no active databaseWRITE-STRINGl        Please either restore a saved database or define a new oneRECOVER-ALLSAPCBBQCSDP?	DQ	P
?DQP
??BCBCCAQ@@?B@@QPPQP

QP
PPROBcBz@F'$B:BV]FB:B:B:BYFB^Bz\B`\BbB:B:\BB:B:B:B\B\BBBBBBBBBҬSYSTEM-VIEWBҬSYSTEM-INDEXBBBSAPCBBQCSDP?	DQP	?DQ
P	??BCBCCAQ@@?B@@QPPROBzANYPF@F$B:BV]FB:B:B:BYFB^B\ÀVALUEB:B:B:SOBDOMAIN-CHECK OA$F/$B:BV]FB:B:B:BYFB^B\CATTRIBUTESATTR-FUNATTR-DOMVALUESB:\	ORIGINAL-FUNB:B:B:B:BATTRFUNDOM\B\BBBC*PROVIDE-WARNING-MESSAGES*у*PKG-STRING*STRING-UPCASEGLOBALFIND-SYMBOLBlWARNING - BPRIN1 is not a legal value for the *READ-FROM-STRINGҬ attribute whose domain is QQQQDCBA/ASBSCSDSHGFEGQ@GQPG@QPGEQG	P
EQP
FQP
HQRABCDABCDSOBÁPROJECT-TUPLES
	A
F$B:BV]FB:B:B:BYFB^B\ÀTUPLESÁATTRIBUTE-LISTIMPÁRELATION-NAMEB:B:B:B֑LISTBSTRING,PROJECT-CONCATENATEBْPQPPQP	@QQQQ@OBCEVAL-WHERE
.A
DF$B:BV]FB:B:B:BYFB^B\BBꃁWHERE-CLAUSEBBB:\TEMP-ATTRIBUTE-LIST\B\BLISTBBҪEVALFCEVAL-WHERE-PREREQFAST-EVAL-WHEREQPQQQQQ5QRQQQPPA@QQ@Q	OBB=@F%$B:BV]FB:B:B:BYFB^B\BBBB:\READER-PACKAGE-NAMEBB:B:B:BЃGLOBAL-ATTR\B\BBBBB֑PACKAGE-NAME҃PARSE-WHEREBGLOBALBBl:BBݒQCP@QQBсQDCCQDSEFEQPFFQ	P@Q
PEQCCDDBQAQAQOBB4@F$B:BV]FB:B:B:BYFB^B\VAL-LISTBBB:\ÀRESULTB:B:B:À%TUPLEB:B:\B\BBBUNLESSjMAKUNBOUNDB*REVERSEQACAASCBSBASABQCCSDQDQFEESFSEFEFQDQ@]@C@QO)BÁGET-DIRECTORY*hTF>$B:BV]FB:B:B:BYFB^B*\KEYWORD-LISTB`\CDEFAULT-DIRECTORYB:B:\jDIRECTORYNUMDIRB:SUB-DIR\B\BBpBTSENDBpBT,USER-ID*SAVE-DIRECTORY*\B9CGET-KEYWORD-VALUEBBl;pB\,SEARCH*l.Bl:;SUBSEQpB4PARSE-PATHNAMEiSHORT-NAMEHOSTl:iDIRECTORYPQB@QPPP@7@Q@	P@Q
	P@Q
P@Q	P@P@Q
A	P@QJAkP	P@@Q@PPP@PP@@@5P@SB@UC
CSDPBQPDQBCBQ@QP	POPB*BCE@F)$B:BV]FB:B:B:BYFB^BC\B3CKEYWORD-VALUE-LISTB:\B"TEMP-RESULTCKEY-FOUNDEXIT-VARSTRING-VALUEDEFAULT-VARIABLE*KEYWORDCVALUE-LIST\B\BB*DEFAULT-KEYWORD-VALUE*C*PKG-NAME*CCONVERT-ATTRIBUTESBBFBl*BB*NREVERSEQF1BہQGGS5GSDFSDQJ|CBGWCCGBCQABPP	PFS	P
EàEQCPAQ@]@F@QOiBCGET-KEYWORD-VALUE-PREREQaՆ@Ft$B:BV]FB:B:B:BYFB^Bj\ÂCOMMAND-KEYWORDS-LISTBYB:\B"THIS-IS-KEYWORDFIRST-IS-KEYWORDFIRST-VALUE-LISTCSECOND-VALUE-LISTTHIRD-VALUE-LISTCSECOND-IS-KEYWORDTHIRD-IS-KEYWORDFIRST-VALUEB:B:B:BaCOMMANDSB}\B\SECONDTHIRDFIRSTBBBBBdBeBՑB҃DE-NEST-KEYWORD-LISTBFB,WARNING unrecognized keyword -->BB\B:Bl*BBBhIрQKJJQKSCJKKIQQL*AL
LLSLSCLSHLSLSCQMMSCQJ|CAMAAQB	
PLSLBLQ*BHQL]QLpGgFLQLQL[EQMMSEQJ|CGMGGMLQC4LWDLSCL?QNNSDQJ|CNSCQ?BFNFF*GLSPPPCQP	PPPCQPCPLULQG	
PL[LSLWLQB
C
CLGLWLS@]
C@Lǐ@QOBjÁRTMS-DESCRIBEF$B:BV]FB:B:B:BYFB^B\B`ÀOBJECT&RESTIGNOREB:\BB:HELPQOBB9F&$B:BV]FB:B:B:BYFB^B\B`BBBB:\BB:B:\B\B>pBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETplEH*CONDITION-HANDLERS**TYPEOUT-WINDOW**OUTPUT-WINDOW*B҃HELP-OBJECTp,G8558FBERRORpB\ERRSET-HANDLERiEXPOSED-PLISTjFRESH-LINE(HELP <object>) will provide help on <object>.B~&
  You are in the user interface to the database. The interaction pane
  is used to accept your input and the results are displayed in the output window.
  Any trivial output is displayed in the typeout window and when
  you type in any character the typeout window disappears.

  The interface menu is at the bottom. In the submenu "help" the menu item
  "inspect-dbms-object" lets you seek information on any database object
  (currently - a relation, command or an attribute). If the object is any
  database command, syntax for that command is provided. In the submenu "help"
  the menu item "introduction" prints out this information.

  The menu item "command-menu" pops up a menu of all database
  commands and when a command is selected all the input data required
  to execute that command is obtained using a choose-variables-value
  window and the command is executed. The menu item "exit" allows you to exit
  the interface by burying it and the item "kill" kills the interface process.
  The item "display" lets you scroll in the output window. For more information
  on any of these items, see the documentation provided by the command tables.

  Each of the attribute names  and relation names is made mouse-sensitive. If you
  click on any mouse-sensitive item, either that item is inspected or some stated
  (as seen in the who-line-documentation) operation is performed. Each line of
  display is sensitive to line-area-scrolling and clicking the left button in the
  zone of line-area-scrolling (when -> appears) on any line will cause the
  entire line to be displayed in the typeout-window.

  The interaction pane runs under universal command loop. It has preemptable read
  facility - lets you typein part of a lisp expression and click on a menu or
  a mouse-sensitive item and when the execution of the mouse command is over,
  continue with the unfinished expression. It also has command completion
  capability and pops up a choose-variables-values window if all the arguments are
  not provided.FORMATQP	PT
PPPJCAPJCBPJ!BJ!B\PRPPOBBG|?@G|F$B:BV]FB:B:B:BYFB^B\BB:\BꃁFOUND-OBJECTBÁATOMIC-OBJECTDB-TESTCOUT-WINDOWÁATTRIBUTE-TESTB:B:pB)lMAP-RESULTB:ÀSYSTUPRELB:B:\B\pB\lXR-BQ-LISTBBBpBTlCOND-EVERYB>BBBBBBBBу*SYSTEM-DOMAIN-KEY*C*SYSTEM-DOMAIN-ATTRIBUTES*Ã*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*у*SYSTEM-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*Bу*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*C*SYSTEM-VIEW-KEY**SYSTEM-VIEW-ATTRIBUTES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*BBBcpBG8582FBBBB҃VALIDATE-SYMBBÁHELP-DATABASESYSTEM-RELATIONQTRIEVE\RELATION-NAMEPROJECT-LIST\	lMODIFIEDPSAVE-DIRECTORYIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATDOCCARDINALITYlATTRIBUTESÁHELP-RELATION\lATTRIBUTESBBÁHELP-ATTRIBUTE҃SYSTEM-VIEWpB\lASSOC-TESTCHELP-VIEWBlRETRIEVE-l-BB҃SYSTEM-INDEXCINDEX-NAMEBCHELP-INDEXÂSYSTEM-IMPLEMENTATIONHELP-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTUREÂHELP-STORAGE-STRUCTUREÁSYSTEM-DOMAINHELP-DOMAINjFUNCTIONPÁHELP-FUNCTION~%~S is not a valid object in the database ~S.BBB, is not a valid object in the database Be.jWRITE-CHARDRPPTPPPJCGPJCHPJ!BJ!B\BEQRDFۀQCHGۀQPEQCQ AGH!PPPP"IJ3JSKLMNKQP#P$BLÀQEQQKQP%P$B&ANMKQP'P$B@Q@Q(P)EQQLQFQ*FNNJIQGQ+PPPP"(P,BEQBQCQ-AG.P/PP0PP1P2N3PPPP(P4PQ53PJNBEQBQCQ6AG݀Q7P
P
P	P"(P,BEQBQCQ8AG݀Q9PPPP"(P,BEQBQCQ:AG݀Q;PPPP"(P,BEQBQCQ<AG݀Q=EQCQ>AGAFEP?PQP@RAQBCPDPBEPFROBB99F$B:BV]FB:B:B:BYFB^B\BBQTRIEVE-VARB:\B9BCSSKEYTUP-FMTDOCCARDBBINDICESB:B:B:ATRB:ÀINDEX\B\BBBB>BB*SEVENTHSIXTHFIFTHFOURTHBBBaBBBBBBBBBBBSCROLL-TO-BOTTOMҩAPPEND-ITEMl ITEM1RELATION is a relationCharacteristics of this relation are :BDatabase :   DATABASEBCATTRIBUTE  :  : IMPLEMENTATION-TYPEDBMS-OBJECTCSTORAGE-STRUCTURECARDINALITYÁSAVE-DIRECTORYTUPLE-FORMATBB!umentation: CSECONDARY-INDICESl                  Be BB, is a relation.BҬDatabase : Attributes:       Implementation type: Storage structure: Cardinality: ,Save-Directory: Tuple-Format: Key: ,Documentation: Secondary Indices: W@[AQBBUBCYBDQBBEJQ
CFFWGFSFQH	PPPP
PPQIPPPPHQPPPJPPJPPPJPPPPPJPPPPPJJGQLKKQLSMPPPMQPCKLLPPPPPPAQPPPPPPPBQPPP PPPFQFQPP!PPP@Q@QPP"PPPDQDQPP#PPPCQCQPP$PP%PEQEQI PP&PPPLLIQJNNQJSOP'PPOWPCNJJLR()P*(HQ+,P-(P-((.P-P+((/P-NNGQKJJQKSM(0P-MQ+CJKK(1P-AQ+(2P-BQ+(3P-FQ+(4P-@Q+(5P-DQ+(6P-CQ+(7P-EQ+I(8P-NNIQKJJQKSO(0P-OW+CJKKNROOBB4`A4F$B:BV]FB:B:B:BYFB^B\BBB1BB:\B!BBpBTDEFBB:\B\B>BB+BBBBBBBÂ*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*SYSTEM-ATTRIBUTE\BDOMAIN-FUNCTIONÁDEFAULT-VALUEB!ANDBBBBÁATTRIBUTE-NAMEBB\BB>BB.l ~S is a duplicate attribute.B-Ҭ~S is an attribute.BIt has the following characteristics.B0B6  : B1BaB:BbB҃PRINT-WIDTHCOTHER-INFOB!umentation  : BBBBBl is a duplicate attribute.l is an attribute.BIt has the following characteristics. lRelation-name  : Domain-function  : lDefault-value  : lPrint-width    : lDocumentation  : PP	PP
PPPQPPQBAAWBA[CAQB@ASDPPPPPPQBAaPPPEPPPEPPQEPPPEPPEPPPPPPPPQPPPPPPPBQ PPP!PPPCQCQAUASQ"BCPP#P$PPCQCQPP%PP&P@Q@Q'(P)Q*+P'Q*,P-'(P)'.P-'/P-Q*'0P-BQ*'1P-CQ*AUASQ"BC'2P-CQ*'3P-@Q*ROvBB4}@PFI$B:BV]FB:B:B:BYFB^B\WHERE-CB:\ÀA-LISTBY?BCSUB-CLAUSE\B\BBB*WHERE-OPT*C*WHERE-OPT-MACROS*jCOPY-LISTBBBBBpB\,*APPENDBCBYÁMEMBER-PKGINDCADRASSOCBB8\B8BBQBBBS5BBSBBBSPPBQ	P
@PBQPAAWA5ASAPPAQP@Q


@@BSPP BQP
@PBQPAAQBA5ASAPPAQP@Q


@@BUC	CS5CQCSCBOBB
FF$B:BV]FB:B:B:BYFB^B\ÀITEM1ÀITEM2B:B:\B\BB8BB5S&W55Q+^QQOBÁPROJECT-ARRAY$F$B:BV]FB:B:B:BYFB^B\BBBB`BB:B:B:BQQQOBÁPROJECT-FLAVOR$F$B:BV]FB:B:B:BYFB^B\BBBB`BB:B:\B\BÂPROJECT-FLAVOR-PREREQ҃FAST-PROJECT-FLAVORQQQOBB@PF$B:BV]FB:B:B:BYFB^B\BB:\B:B:B:B\B\BBBBl:BBBݒ@рQBAAQBSCPPCQCABB@OBB#@F$B:BV]FB:B:B:BYFB^B\BBB:\B:B:B:ÀTUPLEB:B:B:\B\BBB@рQBAAQBSCDDсQFEEQFSCCEFFDQCABB@OBB!GF&$B:BV]FB:B:B:BYFB^B\BBCPROJECT-ATTR-LISTB`BB:\ATTRIBUTE-LENGTHB:B:B:BЃPOSB:BB:B:B:\B\BBBBBBQ+QC@AтQCBBQCSDE@QDQQPCcECBCCAQCCрQAFFQASGHHтQJIIQJSGQCCIJJHQCFAACOBÁPROJECT-STRUCTAA(F$$B:BV]FB:B:B:BYFB^B\BBBBB:\
STRING-RELATION-NAMEB:B:B:BB:BB:B:B:\B\BBBBBBB҃UNCONVERT-ATTRIBUTESQ@AтQCBBQCSDP@QDQCBCCAQCCрQAEEQASFGGтQIHHQFQISCHIIGQCEAACOBCPUT-ARRAY
(@
F$B:BV]FB:B:B:BYFB^B\BCARRAY-ATTRIBUTE-INIT-LISTB:\CARRAY-NAMEÁCURRENT-POINTB:BARRAYBBINTERNCURRENT-POINTCPUT-ARRAY*PQP@PQPA@QCAQCQ	AQAQCkAQCmOBBFF$B:BV]FB:B:B:BYFB^B\BBATTRIBUTE-INIT-LISTB:B:\B\BADJUST-ARRAYQC+QQC
FQQQBOBCPUT-FLAVOR@F$B:BV]FB:B:B:BYFB^B\BCATTR-LISTBB:\BBB\B\BBBBpBTMAKE-INSTANCEpBT,SET-IN-INSTANCEQ@QAQB@QBSASABA@OBCPUT-STRUCT6@F"$B:BV]FB:B:B:BYFB^B\BBBB:\STRUCTURE-TUPLEALTER-MACROÀTEMP1ÀTEMP2BB\B\pB\XR-BQ-LIST*BBBBMAKE-BBBBALTER-BB)\B,LIST*PPQ@P	PQAQDQEPQ
ESBDSCAQPBQPDED@O5BBFF$B:BV]FB:B:B:BYFB^B\BPROPERTYB:B:B:B֑BBْQPQP8BO?BPUTP
FF$B:BV]FB:B:B:BYFB^B@\BBB>B:B:B:B֑BBB*PUTPROPQPQPQPQQPOJB@B0ADF$B:BV]FB:B:B:BYFB^B\BBBÁSECONDARY-KEYBB:B:B:BBBBlRETRIEVE-l-BB,QTRIEVE-QPPPPP	P
@QQQQQۀQJ@PPPPP	P
@QQQQQ@OWBQTRIEVE-FLAVOR-HASH1ALF$B:BV]FB:B:B:BYFB^BX\BBBBSBB:\BB"B\B\BBBBBB*GETHASHFLAVORBBUBBS5@QBQB@@QBW@BQBBB@QQPQQPQ	AÁQQ
OfBXQTRIEVE-FLAVOR-HEAP	%	@F$B:BV]FB:B:B:BYFB^Bg\BBBBSBB`\CTUPLE-LIST\BB\B8BB:B:B:BBFLAVORBBBvQP	QQQPQQQQQQQOuBgCQTRIEVE-STRUCT-AVL
"%
@F$B:BV]FB:B:B:BYFB^Bv\BBBBSBB`\Bq\ÂAVL-INORDER-TRAVERSAL\BB\B8BB:B:B:BBBSTRUCTBBBߒvQP	QQQPQQQQQQQ	OBvQTRIEVE-LIST-AVL
%	@F$B:BV]FB:B:B:BYFB^B\BBBBSBB`\Bq\B\BB\B8BB:B:B:BBBҬLISTBBvQP	QQQPQQQROBCQTRIEVE-FLAVOR-AVL
"%
@F$B:BV]FB:B:B:BYFB^B\BBBBSBB`\Bq\B\BB\B8BB:B:B:BBBFLAVORBBBvQP	QQQPQQQQQQQ	OBCQTRIEVE-LIST-HASH1ALF$B:BV]FB:B:B:BYFB^B\BBBBSBB:\BB"B\B\BBBBBBBdҬLISTBBUBBS5@QBQB@@QBW@BQBBB@QQPQQPQ	AÁQQ
OBCQTRIEVE-LIST-HEAP	%@F$B:BV]FB:B:B:BYFB^B\BBBBSBB`\Bq\BB\B8BB:B:B:BBҬLISTBBvQP	QQQPQQQROBQTRIEVE-STRUCT-HASH1ALF$B:BV]FB:B:B:BYFB^B\BBBBSBB:\BB"B\B\BBBBBBBdSTRUCTBBUBBS5@QBQB@@QBW@BQBBB@QQPQQPQ	AÁQQ
OBQTRIEVE-STRUCT-HEAP	%	@F$B:BV]FB:B:B:BYFB^B\BBBBSBB`\Bq\BB\B8BB:B:B:BBSTRUCTBBBߒvQP	QQQPQQQQQQQOBÁVALIDATE-NAME/$@F$B:BV]FB:B:B:BYFB^B\OBJECT-NAMEB`\DONOT-FLAG-ERRORB:B:B:\B\BBQUOTEBBERROR - improperly specified name --> BBBݒ5PSW5QCSPQ	ۀ7Q
OBB.$@F$B:BV]FB:B:B:BYFB^B\BB`\ÁALLOW-STRINGSB:B:B:\B\BBQUOTEBBBERROR - Improperly specified name --> BBl        All names in RTMS must be SYMBOLS5PSW7QP	Q
P	ۀOBCDEFINE-TRANSACTIONG`F,$B:BV]FB:B:B:BYFB^B\	TRANSACTIONÀFORMSBB3&KEYB`B7*PATHNAMEj&ALLOW-OTHER-KEYSB:\B3B7B	B9B3\B\BBDOCUMENTATIONDefine a transaction, a list of database calls.

   TRANSACTION - Name of the transaction.
   FORMS       - List of RTMS calls.
   DIRECTORY   - Name of the directory in which this transaction will be stored.
   PATHNAME    - Name of the file in which it will be stored.BA\BO)PATHNAMEpB\STORE-KEYARGSBcB\B9PATHBj\B9BCSAVE-DIRECTORYB@\BFILEFORMS@@QPARQR@QDSDDS5DQ@P@Q	@Q
P@QBCCQPPQP@QBPQQPOBCBEGIN-TRANSACTION`F$B:BV]FB:B:B:BYFB^B\BBB:\B\B\BBStart transaction processing - postpone any save-related operations.*TRANSACTION-ON*SO*BEND-TRANSACTION
	`
F$B:BV]FB:B:B:BYFB^B+\BBB:\BB:\B\BBBB,End transaction processing. Revert to normal processing after executing any save-related operations
    postponed during transaction processing.C*PROVIDE-STATUS-MESSAGES*Ã*TRANSACTION-FORMS-POSTPONED*B)BBlWARNING - There is no active transaction.B
PAASARP	RO;B+CABORT-TRANSACTION	`	F$B:BV]FB:B:B:BYFB^B<\BBB:\B\B\BB,Abort the ongoing transaction processing - Do not perform any postponed save-related operations.B8B9B)BlWARNING - There is no active transaction.BRPROJB<CMODIFY-TRANSACTION3\놀`3hF$B:BV]FB:B:B:BYFB^BK\BBB3BB`B7B	B
B:\
B3B7B	B9FILEB3B:B:pB\.FILE-ABORTED-FLAG.B:\B\B*WITH-OPEN-STREAMWITH-OPEN-FILEBBBBBB&BBBEdit the database calls in a transaction.
   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction can be found.
   PATHNAME    - Name of the file in which it is stored.Bj*STANDARD-OUTPUT*BBA\BOBBBcB\B9BBjBB\BBCB\B9B*BjPROBE-FILEBjEDҬ~%ERROR - The transaction file ~S does not exist; ~@
                              ~7T the transaction ~S has not been defined yet.BBpBG9178FBBpB4DIRECTORY-LISTBBERROR - The directory of file BB, does not exist.ABORTFiCHARACTERSiDIRECTIONÀOUTPUTOPENe(BBPRINTe)pBTERRORPCLOSE@@QPA	RQ
R@QESEES5EQ@P@Q@QP!P@QBPP@QBC@QPQDDQPPDQQRP@QBP@QBCP@QQ
QPPQPQDPPTPPPJCFPJCGDQ J!BJ!B\\
!"P#DQ$%P#RG&PH'PJUDQ(P)P*P+G,PGQ-Q.PIISGQ/I!0PGQ-H]ZGGQ12PHQGOxBKSAVE-TRANSACTION4X䆀`4lF$B:BV]FB:B:B:BYFB^By\BBB3BB`B7B	B
B:\B3B7B	B9BUKEYSB3B:B:BWB:\B\BBZB[BBBBBB&BBBB,Save a transaction on disk.

   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction is to be stored.
   PATHNAME    - Name of the file in which it is to be stored.BB9B)B\BOBBBcBBBBB,ERROR - The transaction BBl has not been defined yet.ByB8BB\B9BBj\BBC\B9BB*BBpBG9259FBBBiERROR - The directory of file , does not exist.BlF
BnBoOUTPUTBqBrBBBsBtBvBw@@QPA	RQ
R@QFSFFS5FQ@EQP
PQPRPPPQPEQP@Q@P@QBP@QBCP@QQ
QPPQPQD P!PT"P#P PJCGPJCHDQ$J!BJ!B\\
%PDQ&PRH'PI(PJUDQ)P*P+P,H-PHQ.Q/PJJSHQ0J1PHQ.I]ZHHQ23PIQHOByCCOMMIT-TRANSACTION#F`#hFi$B:BV]FB:B:B:BYFB^B\BBB3BB`B7B	B
B:\
B3B7B	B9BBUBB3B:B:\B\BBBBExecute the database calls in a transaction.

   TRANSACTION - Name of the transaction to be commited.
   DIRECTORY   - Name of the directory in which this transaction can be found, if not in memory.
   PATHNAME    - Name of the file in which it can be found.B]BBA\BOBBBcBB\B9BBjBB\BBCB\B9B*BBbÂRTMS-READ-INSERT-FILEBB+Ҭ~%ERROR - The transaction file ~S does not exist; ~@
                              ~7T the transaction ~S has not been defined yet.BBERROR - The transaction file BB, does not exist.BBB@@@QPARQ	R@QGSGGS5GQ@
P@Q@QP)P@QBPP@QBC@QPQDDQFHHSHPPDQQRP@QBP@QBCP@QQEEQPEQPRQ PPQPQEQEQ!P"Q!PIISIOBMEMTUPLE4@F $B:BV]FB:B:B:BYFB^B\BB1B:\BB:B:B:B:\B\BBBBBBBBc\BGET-RELATIONEQUALB8BÀWHEREBRETRIEVEPAсQP	BQDCBBQPCSPDSCBCDCDAQ
C@Q	P@Q
PBOBDBLESSPF@F'$B:BV]FB:B:B:BYFB^B\CXCYB:B:\B\BBB*TYPE-OFҪSTRING-LESSPBBBcQQr11R1Q#_7QQQQ5QCQC|C@рQQCBA	AQBSCSCABCBC@QPFROBÀDBGTPF@F'$B:BV]FB:B:B:BYFB^B\BBB:B:\B\BBBB*STRING-GREATERPBBBcQQr11R1Q%_7QQQQ5QCQC|C@рQQCBA	AQBSCSCABCBC@QPFROBCQUICK-SORTC@F'$B:BV]FB:B:B:BYFB^B\BCSORT-ATTRSBB:\	B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGSORT-ATTRIBUTESTUPLE-ATTRIBUTESCATTRIBUTE%\B\BBBINTERNAL-FEF-OFFSETS\F
iVARIABLES-USED-IN-LEXICAL-CLOSURES\BBBBBB(҃LTPSORT\F\)INTERNALBQFۂQGFQHHS5HQBHQ
BHSHSHS]HGQHHS]HQQQQP	P
PCOBB-a@F4$B:BV]FB:B:B:BYFB^B\BBB:\B:B:BB:B:B:BNUMBERB:B:B:CATB8\B\BBBBiLEXICAL-PARENT-DEBUG-INFOBpB\lPOSITION*BpBTFIRSTNBcCPEDODQESFF5FQFSPG>RF+F5FGQQCGQQC0GQQCGQQCFW'HHFQPPJIIQJSKLK5KSKQPLÀQCLQQCrCCIJJHQPDCDEECQPFOBÂDEFINE-IMPLEMENTATION".~`"PFP$B:BV]FB:B:B:BYFB^B\IMPLEMENTATION-NAMEBB3BB`DOCUMENTATIONB
B:\B3BB!B3\B\BBBDefine a new implementation.

   IMPLEMENTATION-NAME - Name of the implementation to be defined. All the implementation-specific
                         accessor functions are expected to be defined.
   DOCUMENTATION       - Description of this implementation.B@B8BBBBу*PARAMETER-CHECKING*\BBBcBBB\BBpB\MEMBER-EQUALBҬERROR - The implementation BB, already exists in the l database,        and may not be redefinedDefine implementation \B!BjBCBÀINSERTDefinition of implementation  completed.@@Q
PA	QRQRQPPPPPQPPPPR@QCSCCS5CQ@PQP@Q@P@QBBPPQPBQ PQ!PO1BDEFINE-STORAGE-STRUCTURE#/`#PFR$B:BV]FB:B:B:BYFB^B2\ÂSTORAGE-STRUCTURE-NAMEBB3BB`BB
B:\B3BB!B3\B\BBBlDefine a new storage structure.

   STORAGE-STRUCTURE-NAME - Name of the storage-structure to be defined. All the storage-structure-specific
                            accessor functions are expected to be defined.
   DOCUMENTATION          - Description of this storage-structure.B@B8BBBBB#\BBBcBBBB	\B;BB'BERROR - The storage structure BB, already exists in the l database,        and may not be redefinedlDefine storage-structure \B!BjBCBB.,Definition of storage-structure  completed.@@Q
PA	QRQRQPPPPPQPPPPR@QCSCCS5CQ@PQP@Q@P@QBBPPQPBQ !PQ"POJB2B"@@"Fb$B:BV]FB:B:B:BYFB^B\BBB:\NONEB:B:BB:\B\BBBB>BBBBB*DATABASE-DOCUMENTATION*BB-B.~S is the current database.Bl~Sl ,The relations in this database include:B\RELATION-NAMEBBBB0BB1B,~% There are no relations defined in ~SBBl is the current database.BBBBҬ There are no relations defined in @݀G
	PAPPQA		PAPPPAPP		PAPPAPP	PPPPBBSCCSPP@	PDPPCSPDB@PPPPP	QPPP PP PPPPBBSCCSPP@CSB@!PPP ROaBBW@F8$B:BV]FB:B:B:BYFB^B\BBBB:B:\B\B>BB-B.,~S is a type of implementation.Bl B0OWNER-IDB6B:  ~SBB!,UMENTATION:  ~SBB is a type of implementation.BBBBҬOWNER-ID:  ,DOCUMENTATION:  'P@PPQ@PPP@P	P
PPPW@P@P	PPPP[@QPPPWP[ROtBB
W@F8$B:BV]FB:B:B:BYFB^B
\BB;BB:B:\B\B>BB-B.l~S is a type of storage structure.Bl B0BnB6B:  ~SBB!,UMENTATION:  ~SBB, is a type of storage structure.BBBBҬOWNER-ID:  ,DOCUMENTATION:  'P@PPQ@PPP@P	P
PPPW@P@P	PPPP[@QPPPWP[ROB
B)l@FC$B:BV]FB:B:B:BYFB^B\BCVIEW-NAMEBB:B:\B\B>BB-B.~S is a view.Bl B0VIEW-DEFINITIONB6B:  ~SBnBpBTlVIEW-DOCUMENTATIONBBҬ is a type of view.BBBBlVIEW DEFINITION:  OWNER-ID:  VIEW DOCUMENTATION:  5P@PPQ@PPP@P	P
PPPW@P@P	PPPP[@P@P	PPPPQB@QPPPWP[PQBROBBE@Fb$B:BV]FB:B:B:BYFB^B\BBBB:\B:CVIEW-TUPLEB:\B\	B)B*B+BBB>BBBBB-B.l ~S is an index on relation ~s.BBB0B;B6B:  ~SBPRIORITYB!BBBBBl is an index on relation BBSTORAGE-STRUCTURE:  KEY:  PRIORITY:  DOC:  TQ@O@SAPPPPPBPPQAS	BPPPBP
PPPPA[	BPBP
PPPPAQB	BPBP
PPPPAUB	BPBP
PPPPAYB	B@űQ@/@SAPPQPASPPPA[PAQBPAUBPAYB@OBB3@FP$B:BV]FB:B:B:BYFB^B\BDOMAIN-NAMEBB:B:\B\B*B>BB-B.,~S is a domain.Bl B0BnB6B:  ~SB҃DEFAULT-PRINT-WIDTHBbB!,UMENTATION:  ~SBB is a domain.BBBBҬOWNER ID:  DEFAULT PRINT WIDTH:  ,DEFAULT VALUE:  lDOCUMENATATION:  CP@PPQ@PPP@P	P
PPPW@P@P	PPPP[@P@P	PPPPQB@P@P	PPPPUB@QPPPWP[PQBPUBROBB>FF'$B:BV]FB:B:B:BYFB^B\BBB:B:B:B~%~S is a function.BҬ~%~SB~%The syntax of ~S is:*ARGLISTBB, is a function.BThe syntax of  is:PPQPPQPPQPPQQ	
C
QP
Q
PQP
QQ	
CROB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B[F\BZ)\B0N\B+x\B*Zi\B){Ĳ\B(2=\B9\B.ً\B-i\B~z\B<p\B`sN\B|\Bz(\B:}n\B{\B>aM*\B&6\B[\B(̢\B*j\B=#list
      (project-list (eval-where tuple-list  attribute-list where-clause "FLAVOR" relation-name)
    attribute-list project-list)
      (project-flavor tuple-list attribute-list project-list relation-name)))

(defun qtrieve-struct-avl (relation-name attribute-list project-list secondary-key where-clause
    &optional (tuple-list (avl-inorder-traversal (getp relation-name 'entry-point))))
  secondary-key
  (if tuple-liLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540715. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "GLOBAL-VARS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846126. :AUTHOR "REL3" :LENGTH-IN-BYTES 9991. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
'(declare (setq obsolete-function-warning-switch nil))
(defvar *active-db* nil)
(defvar *attach-detach-data* nil)
(defvar *auto-save-relations* nil)
(defvar *auto-save* nil)
(setq *auto-save* nil)
(defvar *ban-unknowns* nil)
(defvar *bf* 1)
(defvar *command-submenu* nil)
(defvar *completion-checks* nil)
(defvar *completion-help* nil)
(defvar *database-documentation* "")
(defvar *db-prinlength* 2)
(defvar *db-prinlevel* 2)
(defvar *db-saveable* t)
(defvar *dbms-commands* '(defdb defrel restoredb restorerel defview
  delete insert modify destroydb destroyrel
  select project retrieve join set-intersection
  set-union set-difference
  mapon-alltuples printrel savedb saverel))
(defvar *default-anyp-width* nil)
(defvar *default-anyp-value* "?")
(defvar *default-atom-width* nil)
(defvar *default-atom-value* "?")
(defvar *default-keyword-value* nil)
(defvar *default-listp-width* 20)
(defvar *default-listp-value* '(quote (?)))
(defvar *default-numberp-width* 8)
(defvar *default-numberp-value* 0)
;
;1  Temporary solution until the values get changed on the band*
;
(setq *default-anyp-width* 10)
(setq *default-atom-width* 10)
(setq *default-listp-width* 20)
(setq *default-numberp-width* 8)
(setq *default-stringp-width* 20)
(defvar *default-pkg* "user")
(defvar *default-stringp-width* 20)
(defvar *default-stringp-value* "")
(defvar *default-t-width* nil)
(defvar *display-submenu* nil)
(defvar *doc* nil)
(defvar *domain-list* '("anyp" "atom" "listp" "numberp" "stringp"))
(setq *domain-list* '(anyp atom listp numberp stringp))
(defvar *donot-commit* nil)
(defvar *environment-name* nil)
(defvar *equal-inserted* nil)
(defvar *help-submenu* nil)
(defvar *interaction* nil)
(defvar *long-string* '------------------------------------------------------------------------------------------------------------------------------------------)
(defvar *memory-management* t)
(defvar *menupane* nil)
(defvar *node-inserted* nil)
(defvar *non-qfasl-restore* nil)
(defvar *other-width* 12)
(defvar *output-window* nil)
(defvar *parameter-checking* t)
(defvar *password* nil)
(defvar *pkg-name* "RTMS:")
(defvar *pkg-string* "RTMS")
(defvar *print* t)
(defvar *print-style* nil)
(defvar *project-forms* t)
(defvar *provide-error-messages* t)
(defvar *provide-status-messages* t)
(defvar *provide-warning-messages* t)
(defvar *query-optimization* t)
(defvar *recover-attempted* nil)
(defvar *relation-implementation* "LIST-HEAP")
(setq *relation-implementation* "LIST-HEAP")
(defvar *rel-imp* "LIST")
(defvar *rel-sto* "HEAP")
(defvar *restore-operation* nil)
(defvar *restore/define-database-auto-save* t)
(defvar *save-directory* nil)
(defvar *save-user-id* nil)
(defvar *suppress-warning-messages* nil)
(defvar *suppress-error-messages* nil)
(defvar *system-attribute-attributes* nil)
(defvar *system-attribute-key* nil)
(defvar *system-attribute-key-domains* nil)
(defvar *system-domain-attributes* nil)
(defvar *system-domain-key-domains* nil)
(defvar *system-domain-key* nil)
(defvar *system-implementation-attributes* nil)
(defvar *system-implementation-key* nil)
(defvar *system-implementation-key-domains* nil)
(defvar *system-index-attributes* nil)
(defvar *system-index-key-domains* nil)
(defvar *system-index-key* nil)
(defvar *system-optfunc-attributes* nil)
(defvar *system-optfunc-key-domains* nil)
(defvar *system-optfunc-key* nil)
(defvar *system-relation-attributes* nil)
(defvar *system-relation-key-domains* nil)
(defvar *system-relation-base-implementation* "LIST")
(defvar *system-relation-key* nil)
(defvar *system-relation-storage-structure* "HEAP")
(setq *system-relation-storage-structure* "HEAP")
(defvar *system-relations* nil)
(defvar *system-storage-structure-attributes* nil)
(defvar *system-storage-structure-key-domains* nil)
(defvar *system-storage-structure-key* nil)
(defvar *system-view-attributes* nil)
(defvar *system-view-key-domains* nil)
(defvar *system-view-key* nil)
(defvar *system-whereopt-attributes* nil)
(defvar *system-whereopt-key-domains* nil)
(defvar *system-whereopt-key* nil)
(defvar *temp-reader-package* "RTMS")
(defvar *transaction-forms-postponed* nil)
(defvar *transaction-on* nil)
(defvar *temporary* nil)
(defvar *typeout-window* nil)
(defvar *validity-checking* t)
(defvar *where-opt* '())
(defvar *where-opt-macros* '())
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;1       Interface global variables*
;1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*
(defvar dbms-comtab nil)
(defvar dbms-frame1 nil)
(defvar *line-area-values-modifiedp* nil)
(defvar *ucl-count-attr* '(:label "Attribute name:"
  :default nil
  :type (:documentation
  "Name of the attribute in the above relation." :sexp)))
(defvar *ucl-count-unique* '(:label "Unique?"
    :default nil
    :type (:documentation
    "If true, only the unique values of the attribute will be used in the calculations." :boolean)))
(defvar *ucl-by* '(:label "By"
  :default nil
  :type (:documentation
  "Specify the attribute to be used in grouping the data into categories." :sexp)))
(defvar *ucl-attributes* '(:label "Attributes: "
  :default nil
  :type (:documentation
  "Provide a list of attributes. If not all attributes all used." :sexp)))
(defvar *ucl-where* '(:label "Where clause: "
     :default *ui-where*
     :type (:documentation
     "Provide a selection criteria."
     :sexp)))
(defvar *ucl-into* '(:label "INTO :"
    :default *ui-into*
    :type (:documentation
    "Specify the relation to insert the resultant tuples into. If none specified, they are just printed out." :sexp)))
(defvar *ucl-dir* '(:label "Directory:"
   :default *ui-directory*
   :type (:documentation
   "Specify the save directory for the relation."
   :sexp)))
(defvar *ucl-doco* '(:label "Documentation:"
   :default *ui-doc*
   :type (:documentation
   "Specify the documentation for the output relation."
   :string)))
(defvar *ucl-doci* '(:label "Documentation:"
   :default ".."
   :type (:documentation
   "Specify the documentation for this relation."
   :string)))
(defvar *ucl-key* '(:label "Key:"
   :default *ui-key*
   :type (:documentation
   "Specify the key as a list of attributes."
   :sexp)))
(defvar *ucl-imp* '(:label "Implementation Type:"
   :default *ui-imp*
   :type (:documentation
   "Specify the implementation type."
   :sexp)))
(defvar *ucl-sto* '(:label "Storage Structure:"
   :default *ui-ss*
   :type (:documentation
   "Specify the storage structure type."
   :sexp)))
(defvar *ucl-qprint* '(:label "Formatted Output: "
     :default t
     :type (:documentation
     "Should the tuples returned be formatted?. If no, tuples are printed in the interaction pane." :boolean)))
(defvar *ucl-out* '(:label "Output File:"
   :default *ui-file*
   :type (:documentation
   "If the output is to be sent to a file, specify a pathname." :sexp)))
(defvar *ucl-sort* '(:label "Sort: "
    :default *ui-sort*
    :type (:documentation
    "Should the output be sorted? Legal values are: (<attribute-name order>) - order could be ASC or DES." :sexp)))
(defvar *ucl-format* '(:label "Tuple Format :"
      :default *ui-format*
      :type (:documentation
      "Specify the tuple format as a list of numbers representing the column width for each attribute. If not specified, the default format for this relation is used." :sexp)))
(defvar *ucl-wide* '(:label "Wide-Format :"
    :default *ui-wide*
    :type (:documentation
    "Should the tuples be printed in wide format instead of tabular format? - Wide format will be of the type <attribute: value>." :boolean)))
(defvar *ucl-num* '(:label "Number of attributes per line:"
   :default *ui-num*
   :type (:documentation
   "How many attributes per line if the tuples are printed using wide format?. Default is -1 indicating as many tuples per line as possible." :number)))
(defvar *ucl-print* '(:label "Print?:"
     :default t
     :type (:documentation
     "Should the results be printed or not?" :boolean)))
(defvar *ucl-tuples* '(:label "Tuples:"
      :default nil
      :type (:documentation
      "Should the results be returned as a list of tuples?" :boolean)))
(defvar *ucl-quick-sort* '(:label "Quick Sort:"
  :default nil
  :type (:documentation
  "Similar to sort except that it does not take user defined domains into consideration." :sexp)))
(defvar *ucl-stream* '(:label "Stream:"
      :default nil
      :type (:documentation
      "If the output is to be sent to a stream other than the output window, specify the stream name." :sexp)))
(defvar *ucl-unique* '(:label "Unique?:"
      :default nil
      :type (:documentation
  "If only unique tuples are desired, then this must be true." :boolean)))
(defvar *ucl-index-name* '(:label "2Index-name*:"
      :default nil
      :type (:documentation
  "2If the data is to come from an index instead of the base relation*." :sexp)))
(defvar *ucl-attr-desc* '(:label "Attribute descriptor pair:"
 :default *ui-attr-desc*
 :type (:documentation
 "List of attributes and their domains default, and documentation. EX. (a1 (dom <something> def <something>) a2) . If any values are not given there is a default for everything. So, the minimum necessary input is a list of attributes."
 :sexp)))
(defvar *ucl-pathname* '(:label "Pathname:"
:default *ui-file*
:type (:documentation
"Specify the name of the input file."
:sexp)))
(defvar *ucl-retrieve-rel* '(:label "Relation: "
    :default *ui-relation*
    :type (:documentation
    "Specify a relation whose tuples are to be retrieved."
    :sexp)))
TCHELP-VIEWBlRETRIEVE-l-BB҃SYSTEM-INDEXCINDEX-NAMEBCHELP-INDEXÂSYSTEM-IMPLEMENTATIONHELP-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTUREÂHELP-STORAGE-STRUCTUREÁSYSTEM-DOMAINHELP-DOMAINjFUNCLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540718. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "GLOBAL-VARS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359671. :AUTHOR "REL3" :LENGTH-IN-BYTES 4652. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8GLOBAL-VARS\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISP1\pSYS,DEFVAR-1*ACTIVE-DB*B:1\BS*ATTACH-DETACH-DATA*B:1\BSÂ*AUTO-SAVE-RELATIONS*B:1\BS*AUTO-SAVE*B:B:N:B]1\BSÁ*BAN-UNKNOWNS*B:1\BS*BF*F1\BSC*COMMAND-SUBMENU*B:1\BS*COMPLETION-CHECKS*B:1\BSC*COMPLETION-HELP*B:1\BS*DATABASE-DOCUMENTATION*,1\BS*DB-PRINLENGTH*F1\BSÁ*DB-PRINLEVEL*F1\BSÁ*DB-SAVEABLE*jT1\BS*DBMS-COMMANDS*\B8\ÀDEFDBÀDEFRELCRESTOREDBCRESTORERELDEFVIEWDELETEÀINSERTÀMODIFYCDESTROYDBCDESTROYRELpTICLSELECTPROJECTRETRIEVEJOINSET-INTERSECTIONCSET-UNIONSET-DIFFERENCEMAPON-ALLTUPLESPRINTRELÀSAVEDBSAVEREL1\BS*DEFAULT-ANYP-WIDTH*B:1\BS*DEFAULT-ANYP-VALUE*l?1\BS*DEFAULT-ATOM-WIDTH*B:1\BS*DEFAULT-ATOM-VALUE*l?1\BS*DEFAULT-KEYWORD-VALUE*B:1\BSÂ*DEFAULT-LISTP-WIDTH*F1\BSÂ*DEFAULT-LISTP-VALUE*\B8\B8\C?1\BS*DEFAULT-NUMBERP-WIDTH*F1\BS*DEFAULT-NUMBERP-VALUE*F
NBF
NBFNBFNBFN*DEFAULT-STRINGP-WIDTH*1\BSÁ*DEFAULT-PKG*user1\BSBF1\BS*DEFAULT-STRINGP-VALUE*,1\BSC*DEFAULT-T-WIDTH*B:1\BSC*DISPLAY-SUBMENU*B:1\BSÀ*DOC*B:1\BSÁ*DOMAIN-LIST*\B8\anypatomlistp,numberp,stringp\ANYPATOMLISTP*NUMBERP*STRINGPNB1\BSÁ*DONOT-COMMIT*B:1\BSC*ENVIRONMENT-NAME*B:1\BS*EQUAL-INSERTED*B:1\BSÁ*HELP-SUBMENU*B:1\BSÁ*INTERACTION*B:1\BSÁ*LONG-STRING*\B8C------------------------------------------------------------------------------------------------------------------------------------------1\BS*MEMORY-MANAGEMENT*B}1\BSC*MENUPANE*B:1\BS*NODE-INSERTED*B:1\BS*NON-QFASL-RESTORE*B:1\BSÁ*OTHER-WIDTH*F1\BS*OUTPUT-WINDOW*B:1\BS*PARAMETER-CHECKING*B}1\BSC*PASSWORD*B:1\BSC*PKG-NAME*RTMS:1\BS*PKG-STRING*RTMS1\BS*PRINT*B}1\BSÁ*PRINT-STYLE*B:1\BS*PROJECT-FORMS*B}1\BS*PROVIDE-ERROR-MESSAGES*B}1\BSC*PROVIDE-STATUS-MESSAGES*B}1\BSC*PROVIDE-WARNING-MESSAGES*B}1\BS*QUERY-OPTIMIZATION*B}1\BS*RECOVER-ATTEMPTED*B:1\BSC*RELATION-IMPLEMENTATION*lLIST-HEAPlLIST-HEAPN:B71\BSC*REL-IMP*LIST1\BSC*REL-STO*HEAP1\BS*RESTORE-OPERATION*B:1\BS*RESTORE/DEFINE-DATABASE-AUTO-SAVE*B}1\BS*SAVE-DIRECTORY*B:1\BSÁ*SAVE-USER-ID*B:1\BS*SUPPRESS-WARNING-MESSAGES*B:1\BSC*SUPPRESS-ERROR-MESSAGES*B:1\BSÃ*SYSTEM-ATTRIBUTE-ATTRIBUTES*B:1\BSÂ*SYSTEM-ATTRIBUTE-KEY*B:1\BSÃ*SYSTEM-ATTRIBUTE-KEY-DOMAINS*B:1\BSC*SYSTEM-DOMAIN-ATTRIBUTES*B:1\BS*SYSTEM-DOMAIN-KEY-DOMAINS*B:1\BS*SYSTEM-DOMAIN-KEY*B:1\BSC*SYSTEM-IMPLEMENTATION-ATTRIBUTES*B:1\BS*SYSTEM-IMPLEMENTATION-KEY*B:1\BS*SYSTEM-IMPLEMENTATION-KEY-DOMAINS*B:1\BSC*SYSTEM-INDEX-ATTRIBUTES*B:1\BSC*SYSTEM-INDEX-KEY-DOMAINS*B:1\BSC*SYSTEM-INDEX-KEY*B:1\BS*SYSTEM-OPTFUNC-ATTRIBUTES*B:1\BS*SYSTEM-OPTFUNC-KEY-DOMAINS*B:1\BS*SYSTEM-OPTFUNC-KEY*B:1\BS*SYSTEM-RELATION-ATTRIBUTES*B:1\BSÃ*SYSTEM-RELATION-KEY-DOMAINS*B:1\BSÄ*SYSTEM-RELATION-BASE-IMPLEMENTATION*LIST1\BSÂ*SYSTEM-RELATION-KEY*B:1\BS*SYSTEM-RELATION-STORAGE-STRUCTURE*HEAPHEAPNB1\BSC*SYSTEM-RELATIONS*B:1\BSÄ*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*B:1\BSÄ*SYSTEM-STORAGE-STRUCTURE-KEY-DOMAINS*B:1\BSÃ*SYSTEM-STORAGE-STRUCTURE-KEY*B:1\BS*SYSTEM-VIEW-ATTRIBUTES*B:1\BSC*SYSTEM-VIEW-KEY-DOMAINS*B:1\BSC*SYSTEM-VIEW-KEY*B:1\BS*SYSTEM-WHEREOPT-ATTRIBUTES*B:1\BSÃ*SYSTEM-WHEREOPT-KEY-DOMAINS*B:1\BSÂ*SYSTEM-WHEREOPT-KEY*B:1\BSÂ*TEMP-READER-PACKAGE*RTMS1\BSÃ*TRANSACTION-FORMS-POSTPONED*B:1\BS*TRANSACTION-ON*B:1\BS*TEMPORARY*B:1\BS*TYPEOUT-WINDOW*B:1\BS*VALIDITY-CHECKING*B}1\BS*WHERE-OPT*\B8B:1\BSC*WHERE-OPT-MACROS*\B8B:1\BSDBMS-COMTABB:1\BSDBMS-FRAME1B:1\BS*LINE-AREA-VALUES-MODIFIEDP*B:1\BS*UCL-COUNT-ATTR*\B8\LABEL,Attribute name:)DEFAULTB:TYPE\DOCUMENTATIONName of the attribute in the above relation.SEXP1\BSC*UCL-COUNT-UNIQUE*\B8\B,Unique?BB:B\BlIf true, only the unique values of the attribute will be used in the calculations.)BOOLEAN1\BS*UCL-BY*\B8\BlByBB:B\BSpecify the attribute to be used in grouping the data into categories.B1\BS*UCL-ATTRIBUTES*\B8\BAttributes: BB:B\BProvide a list of attributes. If not all attributes all used.B1\BS*UCL-WHERE*\B8\BWhere clause: BC*UI-WHERE*B\BProvide a selection criteria.B1\BSC*UCL-INTO*\B8\BINTO :BC*UI-INTO*B\B,
Specify the relation to insert the resultant tuples into. If none specified, they are just printed out.B1\BSC*UCL-DIR*\B8\BlDirectory:BÁ*UI-DIRECTORY*B\BSpecify the save directory for the relation.B1\BSC*UCL-DOCO*\B8\BDocumentation:B*UI-DOC*B\BlSpecify the documentation for the output relation.STRING1\BSC*UCL-DOCI*\B8\BDocumentation:Bl..B\BSpecify the documentation for this relation.B1\BSC*UCL-KEY*\B8\BKey:B*UI-KEY*B\B,Specify the key as a list of attributes.B1\BSC*UCL-IMP*\B8\BImplementation Type:B*UI-IMP*B\B,Specify the implementation type.B1\BSC*UCL-STO*\B8\BlStorage Structure:B*UI-SS*B\BSpecify the storage structure type.B1\BS*UCL-QPRINT*\B8\BlFormatted Output: BB}B\BShould the tuples returned be formatted?. If no, tuples are printed in the interaction pane.B1\BSC*UCL-OUT*\B8\BOutput File:BC*UI-FILE*B\BlIf the output is to be sent to a file, specify a pathname.B1\BSC*UCL-SORT*\B8\BSort: BC*UI-SORT*B\BShould the output be sorted? Legal values are: (<attribute-name order>) - order could be ASC or DES.B1\BS*UCL-FORMAT*\B8\BTuple Format :B*UI-FORMAT*B\B,Specify the tuple format as a list of numbers representing the column width for each attribute. If not specified, the default format for this relation is used.B1\BSC*UCL-WIDE*\B8\BWide-Format :BC*UI-WIDE*B\BShould the tuples be printed in wide format instead of tabular format? - Wide format will be of the type <attribute: value>.B1\BSC*UCL-NUM*\B8\BNumber of attributes per line:B*UI-NUM*B\B,How many attributes per line if the tuples are printed using wide format?. Default is -1 indicating as many tuples per line as possible.NUMBER1\BS*UCL-PRINT*\B8\B,Print?:BB}B\BShould the results be printed or not?B1\BS*UCL-TUPLES*\B8\B,Tuples:BB:B\BShould the results be returned as a list of tuples?B1\BS*UCL-QUICK-SORT*\B8\BQuick Sort:BB:B\BSimilar to sort except that it does not take user defined domains into consideration.B1\BS*UCL-STREAM*\B8\B,Stream:BB:B\BIf the output is to be sent to a stream other than the output window, specify the stream name.B1\BS*UCL-UNIQUE*\B8\B,Unique?:BB:B\BlIf only unique tuples are desired, then this must be true.B1\BS*UCL-INDEX-NAME*\B8\BIndex-name:BB:B\BlIf the data is to come from an index instead of the base relation.B1\BS*UCL-ATTR-DESC*\B8\BlAttribute descriptor pair:BÁ*UI-ATTR-DESC*B\B,List of attributes and their domains default, and documentation. EX. (a1 (dom <something> def <something>) a2) . If any values are not given there is a default for everything. So, the minimum necessary input is a list of attributes.B1\BSÁ*UCL-PATHNAME*\B8\BlPathname:BBRB\BSpecify the name of the input file.B1\BSC*UCL-RETRIEVE-REL*\B8\BlRelation: BÁ*UI-RELATION*B\BSpecify a relation whose tuples are to be retrieved.B1\pBQ,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFVARFpubel "Attribute descriptor pair:"
 :default *ui-attr-desc*
 :type (:documentation
 "List of attributes and their domains default, and documentation. EX. (a1 (dom <something> def <something>) a2) . If any values are not given there is a default for everything. So, the minimum necessary input is a list of attributes."
 :sexp)))
(defvar *ucl-pathname* '(:label "Pathname:"
:default *ui-file*
:type (:documentation
"Specify the name of the input file."
:sexp)))
(defvar *ucl-retrieve-rel* '(:label "Relation: "
    :default *ui-relation*
    :type (:documentation
    "Specify a relation whose tuples are to be retrieved."
    :sexp)))
TCHELP-VIEWBlRETRIEVE-l-BB҃SYSTEM-INDEXCINDEX-NAMEBCHELP-INDEXÂSYSTEM-IMPLEMENTATIONHELP-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTUREÂHELP-STORAGE-STRUCTUREÁSYSTEM-DOMAINHELP-DOMAINjFUNCLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540721. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "HASH-OPT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846142. :AUTHOR "REL3" :LENGTH-IN-BYTES 17754. :LENGTH-IN-BLOCKS 18. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; HASH-OPT*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     errset*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;*

(defun extract-key-hash (attribute-list key-list domains where-clause package-name
 &aux opt-func opt-func-list result key-domains)
  domains
  ;1;*
  ;1;  This should be done before any of the extract key functions are called in retrieve*
  ;1;*
  (setf attribute-list (unconvert-attributes attribute-list package-name)
key-list (unconvert-attributes key-list package-name)
domains (unconvert-attributes domains package-name))
  (cond ((not (or (not (listp where-clause)) (equal where-clause '(t))))
 (setf key-domains (project-list (list domains) attribute-list key-list))
 (cond ((listp where-clause)
;1;*
;1; Obtain a list of the optimization functions which are known to RTMS at this time. The values come back from*
;1; retrieve as a list of lists. Remove the extra set of lists from the values. This list will be used in all of the *
;1; optimization functions.*
;1;*
(setf opt-func-list
      (funcall (find-symbol (concatenate 'string "RETRIEVE-"
 *system-relation-base-implementation*
 "-" *system-relation-storage-structure*) *pkg-string*)
       'system-optfunc *system-optfunc-attributes* '(symbol-name optimize-function)
       *system-optfunc-key* (list 'string-equal 'storage-structure-type "HASH") nil
       'system-optfunc)))
       (t
(setf opt-func-list nil)))
 (cond ((setf opt-func (cadr (assoc (car where-clause) opt-func-list :test 'string-equal)))
(cond ((string-equal opt-func "OPT-HASH-AND")
       (setf result (opt-hash-and attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-HASH-EQUAL")
       (setf result (opt-hash-equal attribute-list key-list where-clause opt-func-list)))
      ((string-equal opt-func "OPT-HASH-OR")
       (setf result (opt-hash-or attribute-list key-list where-clause opt-func-list)))
      (t
       (setf result (funcall (find-symbol opt-func *pkg-string*)
     attribute-list key-list where-clause opt-func-list))))
(cond ((string-equal (car result) "k")
       (setf result (caddr result)))
      (t
       (setf result nil))))
       (t
(setf result nil))))
(t
 (setf result nil)))
  result)


;1;*;1 This function will process the rest of the where clause and determine if a hash key may be extracted. If so, the hash key is returned.*
;1;*;
;1;*;1 For a hash key to be formed from an AND clause all of the attributes which make up the key must be present and present only once. *
;1;; Also, a key attribute may not be contained in the same leaf clause as a key attribute.*
;1;*;
;1;*;1 The results returned from this function, as well as all optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;*; 1list--of-lists-of-key-attributes-present*
;1;*;1 list-of-constant-values*
;1;*;1 list-of-non-key-attributes-present)*
;1;*;1  where*
;1;*;1stat-character - is one of the following :*
;1;*;1k - a valid key has been formed*
;1;*;1n - no key can be formed from where*
;1;*;1    clause (ever).*
;1;*;1p - it is still possible to form a*
;1;*;1    but this sub-clause will not*
;1;*;1    contribute to it.*
;1;*;1c - constant sub-clause - nothing to*
;1;*;1    add to the key.*
;1;;*
(defun opt-hash-and (attribute-list key-list where-clause opt-func-list
       &aux do-continue element opt-func (result '("p" (nil) (nil) (nil))) (where-aux-list nil)
            (where-key-list nil) (where-val-list nil))
  ;;
1   *;;  1 Process for all sub-clauses of the where-clause
   *;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond ((listp (car where-clause))
   ;;
1    *;;1  The element is a list, must be a function call. Call the appropriate optimization*
1    *;;1 function if one exists. Add the results from the function to the current results. The optimization functions which*
1    *;;1 are defined by RTMS initially are used as selections in the following COND clause to improve the speed of calling*
   ;;1 these functions. If the function in the sub-clause is not from this group, the function name must be formed before*
   ;;1 it can be invoked.*
   ;;
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-HASH-AND")
 (setf result (opt-hash-and attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-HASH-EQUAL")
 (setf result (opt-hash-equal attribute-list key-list
      (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-HASH-OR")
 (setf result (opt-hash-or attribute-list key-list (car where-clause) opt-func-list)))
(t
 (setf result (funcall (find-symbol opt-func *pkg-string*)
       attribute-list key-list (car where-clause) opt-func-list))))
  (setf where-key-list (append where-key-list (second result))
where-val-list (append where-val-list (third result))
where-aux-list (append where-aux-list (fourth result))))))
  ((symbolp (car where-clause))
   ;;
   ;;B The element is a symbol - either it is an attribute or a variable. In either case,*
   ;;B nothing concerning the key can be gained here.*
   ;;
           (if (member (car where-clause) attribute-list :test 'equal)
       ;;
       ;;  1Symbol is an attribute - imporperly formed where clause - no key possible*
       ;;
       (setf result '("n" (nil) (nil) (nil)))))))
  ;;
  ;;  1The where-clause has been parsed, now let us see what we have*
  ;;
  (cond ((string-equal (car result) "n"))
((and where-key-list where-val-list)
 ;;
 ;; 1We have a possible key. To make final determination, all key attributes must be present in the where-key-list and they must*
 ;1; not repeated. If they are all there, they must be put in order. *
 ;;
 (setf result '(()()()))
 (setf do-continue 't)
 ;;
 ;;  1Determine if a key attribute is repeated in the where-key-list. If it is,*
 ;;1 an illegal where clause was specified and no key can be found*
 ;;
 (do ((where-key-list where-key-list where-key-list))
     ((or (null where-key-list) (null do-continue)))
   (setf element (car where-key-list)
 where-key-list (cdr where-key-list))
   (cond ((member element where-key-list :test 'equal)
  (setf do-continue nil)
  (setf result '("n" (nil) (nil) (nil))))))
 ;;
 ;;  1Determine if all of the key attributes were contained in the where clause*
 ;;
 (do ((key-list key-list (cdr key-list)))
     ((or (null key-list) (null do-continue)) do-continue)
   (if (setf do-continue (member (car key-list) where-key-list :test 'equal))
       (setf result
     (do ((where-key-list where-key-list (cdr where-key-list))
  (where-val-list where-val-list (cdr where-val-list))
  (where-aux-list where-aux-list (cdr where-aux-list)))
 ((equal (car where-key-list) (car key-list))
  (if (car key-list)
      (list (append (car result) (list (car where-key-list)))
    (append (cadr result) (list (car where-val-list)))
    (append (caddr result) (list (car where-aux-list))))))))))
 ;;
 ;;  1Result contains the list of key attribute names found in the where-clause in the order in which they are present in the*
 ;1; key-list. If the two lists are equal, we have a key, otherwise no key is possible.*
 ;;
 (if (and (equal (car result) key-list) result)
     (setf result (append (list "k") (list (list key-list)) (list (list (cadr result)))
  (list (cddr result))))
   (setf result '("n" (nil) (nil) (nil)))))
;;
;;  1Constant expression - nothing to add*
;;
((and (null where-key-list) (null where-aux-list))
 (setf result '("c" (nil) (nil) (nil))))
;;
;; 1A key is not possible from this where clause*
;;
(t
 (setf result '("n" (nil) (nil) (nil)))))
  result)

;1;*;1 This function will process the rest of the where clause and determine if a hash key may be extracted. If so, the hash key is returned.*
;1;;*
;1;*;1 For a hash key to be completely formed from an EQUAL clause all of the attributes which make up the key must be present and*
;1;; present only once. However, only two elements may be present in and EQUAL clause and only one may be an attribute. If the key is *
;1;; made up of more than one attribute, a complete key is not possible from this function, a partial key might be formed in this case.*
;1;;*
;1;*;1The results returned from this function, as well as all optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;*; 1list--of-lists-of-key-attributes-present*
;1;*;1 list-of-constant-values*
;1;*;1 list-of-non-key-attributes-present)*
;1;*;1  where*
;1;*;1stat-character - is one of the following :*
;1;*;1k - a valid key has been formed*
;1;*;1n - no key can be formed from where clause (ever).*
;1;*;1p - it is still possible to form a but this sub-clause will not contribute to it.*
;1;*;1c - constant sub-clause - nothing to add to the key.*
;1;;*
(defun opt-hash-equal (attribute-list key-list where-clause opt-func-list
       &aux opt-func (result '("p" (nil) (nil) (nil))) (where-aux-list nil)
       (where-key-list nil) (where-val-list nil))
  ;;
  ;;1  Process for all sub-clauses of the where-clause*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond ((and (listp (car where-clause)) (equal 'quote (caar where-clause)))
   (if (null where-val-list)
       (setf where-val-list (cadar where-clause))
       (setf result (append (list "c") (cdr result)))))
  ;;
  ;;1  The element is a list, must be a function call. Call the appropriate optimization*
  ;;1 function if one exists. Add the result from the function to the current results.*
  ;;1 For this functin, only a constant value may be returned from the function call,*
  ;;1 otherwise an improperly formed where-clause has been passed.*
  ;;
  ((listp (car where-clause))
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-HASH-AND")
 (setf result (opt-hash-and attribute-list key-list (car where-clause) opt-func-list)))
((string-equal opt-func "OPT-HASH-EQUAL")
 (setf result (opt-hash-equal attribute-list key-list (car where-clause)
      opt-func-list)))
((string-equal opt-func "OPT-HASH-OR")
 (setf result (opt-hash-or attribute-list key-list (car where-clause) opt-func-list)))
(t
 (setf result (funcall (find-symbol opt-func *pkg-string*)
       attribute-list key-list (car where-clause) opt-func-list))))
  (if (null where-val-list)
      (setf where-val-list (car (third result))))
  ;;
  ;;1  No key may be formed if the key list or the aux list is non-nil. Also, all values returned must be single.*
  ;;
  (if (or (car (second result)) (car (fourth result)) (cdr (third result)))
      (setf result '("n" (nil) (nil) (nil)))))))
  ((symbolp (car where-clause))
   ;;
   ;;1 The element is a symbol, add the fact to the proper list*
   ;;
           (if (member (car where-clause) attribute-list :test 'equal)
       ;;
       ;;1  Symbol is an attribute*
       ;;
       (if (member (car where-clause) key-list :test 'equal)
   ;;
   ;;1  Attribute is a key attribute*
   ;;
     (if (null where-key-list)
       (setf where-key-list (car where-clause)))
   ;;
   ;;1  Attribute is not a key attribute*
   ;;
   (if (null where-aux-list)
       (setf where-aux-list (car where-clause))))
       ;;1  The symbol is not an attribute, must return a value, so EVALuate the symbol*
       ;;
       (if (null where-val-list)
   (setf where-val-list (or (car (errset (eval (car where-clause)) nil)) (car where-clause)))
   (setf result (append (list "c") (cdr result))))))
  ;;
  ;;1  Not a symbol, must be a value.*
  ;;
          (t
   (if (null where-val-list)
       (setf where-val-list (car where-clause))
       (setf result (append (list "c") (cdr result)))))))
  ;;
  ;;1  The where-clause has been parsed -- let us see what we have*
  ;;
  (cond ((string-equal (car result) "n"))
((string-equal (car result) "c"))
((and where-key-list where-val-list)
 ;;
 ;;1 We have a possible key. To make final determination, all key attributes must be present in the where-key-list. If they are*
 ;1; all there they must be in order. However this optimization function only allows two parameters to be specified in the equal*
 ;1; clause, therefore the where-key-list and the key-list must be equal. If they are not equal, a key is still possible but not*
 ;1; completely from this routine*
 ;;
         (if (equal (list where-key-list) key-list)
     (setf result (append (list "k") (list (list (list where-key-list)))
  (list (list (list where-val-list))) (list (list (list where-aux-list)))))
     (setf result (append (list "p") (list (list (list where-key-list)))
  (list (list (list where-val-list))) (list (list (list where-aux-list)))))))
((and (null where-key-list) (null where-aux-list))
 (setf where-clause (append (list 'equal) where-clause))
 (setf where-val-list (eval where-clause))
 (setf result (append (list "c") (list (list (list where-key-list)) )
(list (list (list where-val-list))) (list (list (list where-aux-list))))))
;;
;;1  Determine if two attributes were specified, if so this invalidates the possibility of there being a key*
;;
((or (and (null where-aux-list) (null where-val-list)) (and where-key-list where-aux-list))
 (setf result '("n" (nil) (nil) (nil) (nil))))
(t
 (setf result '("p" (nil) (nil) (nil)))))
  result)

;1;*;1 This function will process the rest of the where clause and determine if a hash key may be extracted. If so, the hash key is returned.*
;1;;*
;1;*;1 For a hash key to be formed from an OR clause all of the results from the sub-clauses must be keys or constant expressions. *
;1;; (stat = k or c). Because of this, it is possible for several keys to be returned from this function.*
;1;;*
;1;*;1The results returned from this function, as well as all optimization functions, are in the following form :*
;1;*;1(stat-character*
;1;*; 1list--of-lists-of-key-attributes-present*
;1;*;1 list-of-constant-values*
;1;*;1 list-of-non-key-attributes-present)*
;1;*;1  where*
;1;*;1stat-character - is one of the following :*
;1;*;1k - a valid key has been formed*
;1;*;1n - no key can be formed from where clause (ever).*
;1;*;1p - it is still possible to form a but this sub-clause will not contribute to it.*
;1;*;1c - constant sub-clause - nothing to add to the key.*
(defun opt-hash-or (attribute-list key-list where-clause opt-func-list
       &aux a-result opt-func (result '("f" (nil) (nil) (nil))))
  ;;
  ;;1  Process all of the sub-clauses of the where-clause*
  ;;
  (do ((where-clause (cdr where-clause) (cdr where-clause)))
      ((or (null where-clause) (string-equal (car result) "n")) result)
    (cond ((listp (car where-clause))
   ;;
   ;;1  The element is a list, must be a function call. Call the appropriate optimization function if one exists.*
   ;;
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-HASH-AND")
 (setf a-result (opt-hash-and attribute-list key-list (car where-clause)
      opt-func-list)))
((string-equal opt-func "OPT-HASH-EQUAL")
 (setf a-result (opt-hash-equal attribute-list key-list (car where-clause)
opt-func-list)))
((string-equal opt-func "OPT-HASH-OR")
 (setf a-result (opt-hash-or attribute-list key-list (car where-clause)
     opt-func-list)))
(t
 (setf a-result (funcall (find-symbol opt-func *pkg-string*)
       attribute-list key-list (car where-clause) opt-func-list))))
  (cond ((string-equal (car a-result) "k")
 ;;
 ;;1  The sub-clause returned a valid key, add it to the list of keys formed.*
 ;;
 (cond ((string-equal (car result) "f")
(setf result a-result))
       (t
(setf result (list "k"
   (append (second result) (second a-result))
   (append (third result) (third a-result))
   (append (fourth result) (fourth result)))))))
((string-equal (car a-result) "c"))
;;
;;1  Result returned from the optimization function was not a constant expression or a valid key, therefore no*
;1; key may be formed from this OR sub-clause*
;;
((or (string-equal (car a-result) "n") (string-equal (car a-result) "p"))
 (setf result '("n" (nil) (nil) (nil))))))))
  ((symbolp (car where-clause))
   ;;
   ;;1 The element i as a symbol*
   ;;
           (if (member (car where-clause) attribute-list :test 'equal)
       ;;
       ;;1  Symbol is an attribute*
       ;;
               (setf result '("n" (nil) (nil) (nil)))))))
  result)
:B:BBBBlRETRIEVE-l-BB,QTRIEVE-QPPPPP	P
@QQQQQۀQJ@PPPPP	P
@QQQQQ@OWBQTRIEVE-FLAVOR-HASH1ALF$B:BV]FB:B:B:BYFB^BX\BBBBSBB:\BB"B\B\BBBBBB*GETHASHFLAVORBBUBBS5@QBQB@@QBW@BQBBB@QQPQQPQ	AÁQQ
OfBXQTRIEVE-FLAVOR-HEAP	%	@F$B:BV]FB:B:B:BYFB^Bg\BBBBSBB`\CTUPLE-LIST\BB\B8BB:B:B:BBFLAVORBBBLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540725. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "HASH-OPT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360110. :AUTHOR "REL3" :LENGTH-IN-BYTES 2146. :LENGTH-IN-BLOCKS 5. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8,HASH-OPT\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPEXTRACT-KEY-HASH5ATFT$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁATTRIBUTE-LISTKEY-LISTDOMAINSWHERE-CLAUSEPACKAGE-NAMEB:\OPT-FUNCÁOPT-FUNC-LISTÀRESULTKEY-DOMAINSB:\)MACROS-EXPANDED\SETF*SYSTEM-OPTFUNC-KEY*у*SYSTEM-OPTFUNC-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*UNCONVERT-ATTRIBUTES\BYLIST҃PROJECT-LISTSTRINGlRETRIEVE-l-CONCATENATEҪFIND-SYMBOLÁSYSTEM-OPTFUNC\SYMBOL-NAMECOPTIMIZE-FUNCTIONSTRING-EQUALÂSTORAGE-STRUCTURE-TYPEHASHpB\lASSOC-TESTҬOPT-HASH-ANDpB\STRING-EQUAL*҃OPT-HASH-ANDOPT-HASH-EQUALÁOPT-HASH-EQUALҬOPT-HASH-OROPT-HASH-ORlkQQQQQQ5YQ	*VQ
QQC5PPPPPPDPPPPPPP
PJDAAۃSAQPB@/@QPQQQAQ@QPQQQAQ@QPQQQAQ	@QPDQQQAQDBBSPB[BBBBOBPB\ІA4Ft$B:BV]FB:B:B:BYFB^B\B`BaBcBgB:\DO-CONTINUEELEMENTBfBhÁWHERE-AUX-LISTÁWHERE-KEY-LISTÁWHERE-VAL-LISTBcB:BBaBB\Bk\FOURTHTHIRDSECONDBmPROGBp\lp\B:\B:\B:BBҬOPT-HASH-ANDBBOPT-HASH-EQUALBҬOPT-HASH-ORBB{pB\,*APPENDpB\MEMBER-EQUAL\ln\B:\B:\B:ln\B:B:B:BulkAPPEND\lc\B:\B:\B:PCUGJGS5>GQBQPBB>BQPQQGSQ	BQ
PQQGSQBQPQQGSQ	BQPHQQGSQHCEQCWEFQC[FDQCQBDGGSQPCGCSPCSP^EVFRPC@EQIISAIAQIQ@PCI@QJ'JSEQ@!EQIFQKDQLIKLISJSrJCSISCWKSC[LSCCJ@CS+CPQCWCYEDPPCCOBB gA $F$B:BV]FB:B:B:BYFB^B\B`BaBcBgB:\	BfBhBBBBcB:B:B:\Bk\
pBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETBBBBmBplEH*CONDITION-HANDLERS*Bp\lp\B:\B:\B:B8BBҬOPT-HASH-ANDBBOPT-HASH-EQUALBҬOPT-HASH-ORBB{\ln\B:\B:\B:Bp,G3643FERRORpB\ERRSET-HANDLEREVALBulclnlklpBEQUAL\ln\B:\B:\B:\B:PAUEES5
EQB&D|EQ
BD|ES5@EQBQPB@q@Q	P
QQESQ@QP
QQESQ@QP
QQESQ	@QPFQQESQFADAQBDAQ	AUAQ;P8E1ESQESQC-ESC*B(ESB%DPPTPPPJCGPJCHESJ!BJ!B\BESDDPAU
CAEASP
qASP
5ASP
1CDCQ+PPCQDQBQC	BP]DPBDCBPPAAOBB6AFN$B:BV]FB:B:B:BYFB^B\B`BaBcBgB:\A-RESULTBfBhBcB:\Bk\BBBBmBBp\lf\B:\B:\B:BBҬOPT-HASH-ANDBBOPT-HASH-EQUALBҬOPT-HASH-ORBB{lklfBBulclnlpB\ln\B:\B:\B:PBUC`CS5TCQBQPBATAQPQQCSQ	AQ
PQQCSQAQPQQCSQ	AQPDQQCSQD@@SPBSP@Q!PBW@WB[@[BQBBQB@SP@SP
@SPCCSQPBCBSPBOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B҆-i\BІ~z\BΆ<p\B̆`sN\Bʆ|\B=#\B{\B:}n\Bx\Bm[result)
    (cond ((listp (car where-clause))
   ;;
1    *;;1  The element is a list, must be a function call. Call the appropriate optimization*
1    *;;1 function if one exists. Add the results from the function to the current results. The optimization functions which*
1    *;;1 are defined by RTMS initially are used as selections in the following COND clause to improve the speed of calling*
   ;;1 these functions. If the function in the sub-clause is not from this group, the function name must be formed before*
   ;;1 it can be invoked.*
   ;;
   (cond ((setf opt-func (cadr (assoc (caar where-clause) opt-func-list :test 'string-equal)))
  (cond ((string-equal opt-func "OPT-HASH-AND")
 (setf result (opt-hash-and attribute-list key-list (car where-clause) opt-func-list)))
((string-equLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540728. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "INDEX" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846153. :AUTHOR "REL3" :LENGTH-IN-BYTES 25813. :LENGTH-IN-BLOCKS 26. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;1;; Copyright (c) by Texas Instruments, Incorporated*
;1;; All rights reserved*
;1;; INDEX*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     errset*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     index-insert-flavor-hash*
;1;;     index-insert-flavor-heap*
;1;;     index-insert-flavor-avl*
;1;;*

(defun define-index (relation-name
     &rest keyword-list
     &key &optional name documentation storage-structure key priority
     &allow-other-keys
     &aux index-doc index-key index-name index-priority index-type relation-attributes
     relation-implementation relation-storage-structure temp-relation-name)
  "2Define an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index will be defined.
    NAME - Name of the index to be defined
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index."*
  name documentation storage-structure key priority
  (block define-index
  (cond (*parameter-checking*
 (if (not (active-database relation-name))
     (return-from define-index nil))))
  (if (not (setf relation-name (validate-sym relation-name)))
      (return-from define-index nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf keyword-list (get-keyword-value-prereq '(name sto key doc priority) keyword-list))
  (setf index-name (get-keyword-value '(name sto key doc priority) keyword-list)
index-type (second index-name)
index-key (convert-attributes (third index-name))
index-doc (fourth index-name)
index-priority (fifth index-name)
index-name (first index-name))
  (setf temp-relation-name (get-relation relation-name '(attributes implementation-type storage-structure) nil)
relation-attributes (caadr temp-relation-name)
relation-implementation (second (second temp-relation-name))
relation-storage-structure (third (second temp-relation-name))
temp-relation-name (car temp-relation-name))
  (cond ((not relation-attributes)
 (cond (*provide-error-messages*
(format *standard-output* "2~%ERROR - The relation ~s does not exist in the ~s database"*
relation-name *active-db*)))
 (return-from define-index nil))
(t
 (setf relation-name temp-relation-name)))
  ;1;*
  ;1;  Determine if there is an index on the current relation with the same name as that requested. If so, it is an error.*
  ;1;*
  (cond ((null index-name)
 (setf index-name (string (gensym))))
(t
 (setf index-name (string-upcase index-name))
 (cond ((setf temp-relation-name (car (qtrieve 'system-index *system-index-attributes*
       '("2RELATION-NAME"* "2INDEX-NAME"*) *system-index-key*
       `(string-equal index-name ,(string-upcase index-name)))))
(if *provide-error-messages*
    (format *standard-output*
    "2~%ERROR - An index with the name of ~s has already been defined on the relation ~s"*
    (second temp-relation-name) (first temp-relation-name)))
(return-from define-index nil)))))

  ;1;*
  ;1;  Determine if the requested storage structure is defined in the current database*
  ;1;*
  (cond ((null index-type)
 (setf index-type "2AVL"*))
(t
 (cond ((not (car (qtrieve 'system-storage-structure *system-storage-structure-attributes*
   '("2STORAGE-STRUCTURE*-NAME") *system-storage-structure-key*
   `(string-equal storage-structure-name ,(string-upcase index-type)))))
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is an undefined 2storage structure in the ~s database*"
    index-type *active-db*))
(return-from define-index nil)))))
  ;;
  ;;1  Determine if the priority specified is within acceptable limits*
  ;;
  (cond ((null index-priority)
 (setf index-priority 2))
((< index-priority 1)
 (cond (*provide-error-messages*
(format *standard-output* "2~%ERROR - ~s is an illegal value for the value of priority."* index-priority)
(format *standard-output* "2~%        Priority must be a positive number."*)))
 (return-from define-index nil)))
  (cond ((null index-key)
 (setf index-key (list (car relation-attributes)))))
  ;;
  ;;1  Everything seems to be in order proceed*
  ;;
  (if *provide-status-messages*
      (format *standard-output* "~%Define 2index* ~s 2on relation ~s *in database ~s"
      (read-from-string index-name) (read-from-string (string-upcase relation-name))
      (read-from-string *active-db*)))
  (if (null (create-index-relation relation-name index-name relation-attributes index-key
   index-type relation-implementation relation-storage-structure))
      (return-from define-index nil))
  ;;
  ;;1  Insert the index tuple into the SYSTEM-INDEX relation*
  ;;
  (insert 'system-index 'tuples (list (list (string-upcase relation-name) index-name
    (string-upcase index-type) index-key index-priority index-doc)))

  (if *provide-status-messages*
      (format *standard-output* "~%2Index* ~s 2has been defined on relation ~s *in database ~s"
      (read-from-string index-name)
      (read-from-string (string-upcase relation-name))
      (read-from-string *active-db*)))
  ;;
  ;;1  Create the actual index structure and insert the tuples into it using the new index*
  ;;
  (return-from define-index index-name)))

(defun create-index-relation (relation-name index-name relation-attributes index-key index-type
      relation-implementation relation-storage-structure
      &aux tuples)
  ;;
  ;;1  Create the structure of the type of the storage structure of the index and insert the tuples into the new index. The DEFREL-sto*
  ;1; function will validate the attributes and the key and define the appropriate structure.*
  ;;
  (cond ((null (errset
 (setf index-key (funcall (find-symbol (concatenate 'string "DEFREL-"
    (string-upcase index-type)) *pkg-string*)
  index-name relation-attributes
  (list 'key (convert-attributes index-key))))
       nil))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is an undefined storage structure" index-key))
 (setf index-name nil))
(t
 (setf tuples (funcall (find-symbol (concatenate 'string "OBTAIN-2TUPLES-"*
 (string-upcase relation-storage-structure))
    *pkg-string*)
       relation-name))
 (funcall (find-symbol (concatenate 'string 2"INDEX-INSERT-"* (string-upcase relation-implementation)
    "2-"* (string-upcase index-type))
       *pkg-string*)
  index-name tuples relation-attributes index-key relation-name)))
  index-name)

(defun obtain-tuples-heap (relation-name)
  (getp relation-name 'entry-point))

(defun obtain-tuples-hash (relation-name &aux tuple-list)
  (maphash (function (lambda (key-val tuples)
       key-val
       (setf tuple-list (append tuples tuple-list))))
   (getp relation-name 'entry-point))
  tuple-list)

(defun obtain-tuples-avl (relation-name)
  (avl-inorder-traversal (getp relation-name 'entry-point)))

(defun index-insert-flavor-hash (index-name tuples attributes key-list relation-name
 &aux key hash-relation)
  attributes relation-name key-list
  (setf key (project-flavor tuples attributes key-list relation-name)
hash-relation (getp index-name 'entry-point))
  (mapcar (function
    (lambda (tuple keyval)
      ;;
      ;;1Insert the tuple into the hash table using heap formation for collisions.*
      ;;
      (puthash keyval (cons tuple (gethash keyval hash-relation)) hash-relation)))
  tuples key))


(defun index-insert-struct-hash (index-name tuples attributes key-list relation-name
 &aux key hash-relation)
  attributes relation-name key-list
  (setf key (project-struct tuples attributes key-list relation-name)
hash-relation (getp index-name 'entry-point))
  (mapcar (function
    (lambda (tuple keyval)
      ;;
      ;;1Insert the tuple into the hash table using heap formation for collisions.*
      ;;
      (puthash keyval (cons tuple (gethash keyval hash-relation)) hash-relation)))
  tuples key))

(defun index-insert-flavor-heap (index-name tuples attributes key-list relation-name)
  attributes key-list relation-name
  (putp index-name (nconc (getp index-name 'entry-point) tuples) 'entry-point))

(defun index-insert-struct-heap (index-name tuples attributes key-list relation-name)
  attributes key-list relation-name
  (putp index-name (nconc (getp index-name 'entry-point) tuples) 'entry-point))

(defun index-insert-flavor-avl (index-name tuples attributes key-list relation-name
       &aux domain-list domain-key-list key new-element tree)
  (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
 *system-relation-key*
 (list 'string-equal 'relation-name (string-upcase relation-name))))
domain-key-list (car (project-list (list domain-list) attributes key-list))
key (project-flavor tuples attributes key-list)
tree (getp index-name 'entry-point))
  ;;
  ;;1 Insert one tuple at a time into the AVL tree*
  ;;
  (do ((tuple% tuples (cdr tuple%))
       (key% key (cdr key%)))
      ((null tuple%) t)
    ;;
    ;;1  Form the new element in a form suitable for insertion*
    ;;
    (setf new-element (cons (list (car tuple%)) (append (list 0) (list nil) (list nil)))
  tree (insert-avl-flavor new-element tree (car key%) key-list attributes domain-key-list nil
  index-name)))
  (putp index-name tree 'entry-point))

(defun index-insert-struct-avl (index-name tuples attributes key-list relation-name
       &aux domain-list domain-key-list key new-element tree)
  (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
   *system-relation-key*
 (list 'string-equal 'relation-name (string-upcase relation-name))))
domain-key-list (car (project-list (list domain-list) attributes key-list))
key (project-struct tuples attributes key-list relation-name)
tree (getp index-name 'entry-point))
  ;;
  ;;1 Insert one tuple at a time into the AVL tree*
  ;;
  (do ((tuple% tuples (cdr tuple%))
       (key% key (cdr key%)))
      ((null tuple%) t)
    ;;
    ;;1  Form the new element in a form suitable for insertion*
    ;;
    (setf new-element (cons (list (car tuple%)) (append (list 0) (list nil) (list nil)))
  tree (insert-avl-struct new-element tree (car key%) key-list attributes domain-key-list nil
  relation-name)))
  (putp index-name tree 'entry-point))

(defun index-insert-list-heap (index-name tuples attributes key-list relation-name)
  relation-name key-list attributes
  (putp index-name (nconc (getp index-name 'entry-point) tuples) 'entry-point))

(defun index-insert-list-hash (index-name tuples attributes key-list relation-name &aux hash-relation key)
  relation-name
  (setf hash-relation (getp index-name 'entry-point)
key (project-list tuples attributes key-list))
   (mapcar
     (function (lambda (tuple keyval)
 ;;
 ;;1Here the tuple (val.1 val.2 .......val.n) itself is stored in the the hash table.*
 ;;
 (puthash keyval (cons tuple (gethash keyval hash-relation)) hash-relation)))
     tuples key))

(defun index-insert-list-avl (index-name tuples attributes key-list relation-name
       &aux domain-list domain-key-list key new-element tree)
  (setf domain-list (caar (qtrieve 'system-relation *system-relation-attributes* '(domains)
 *system-relation-key*
 (list 'string-equal 'relation-name (string-upcase (string relation-name)))))
domain-key-list (car (project-list (list domain-list) attributes key-list))
key (project-list tuples attributes key-list)
tree (getp index-name 'entry-point))
  ;;
  ;;1 Insert one tuple at a time into the AVL tree*
  ;;
  (do ((tuple% tuples (cdr tuple%))
       (key% key (cdr key%)))
      ((null tuple%) t)
    ;;
    ;;1  Form the new element in a form suitable for insertion*
    ;;
    (setf new-element (cons (list (car tuple%)) (append (list 0) (list nil) (list nil)))
  tree (insert-avl-list new-element tree (car key%) key-list attributes domain-key-list nil
   index-name)))
  (putp index-name tree 'entry-point))


(defun extract-key (relation-name attributes key domains relation-storage-structure where-clause index-name
    &aux index-key index-list index-type (key-value nil)
    (string-relation-name (string relation-name)) package-name)
  ;;
  ;;1  First attempt to obtain a key from the main relation if an index name is not passed*
  ;;
  (setf package-name (package-name (or (symbol-package relation-name) *pkg-string*)))
  (cond ((null index-name)
 (setf key-value (funcall (find-symbol (concatenate 'string "EXTRACT-KEY-" relation-storage-structure)
       *pkg-string*)
  attributes key domains where-clause package-name)
       index-type relation-storage-structure
       index-key key)))
  ;;
  ;;1  If no key could be obtained attempt to find an index which will do*
  ;;
  (cond ((and (null key-value) (not (member string-relation-name *system-relations*
    :test 'string-equal)))
  (cond ((null index-name)
(setf index-name relation-name
      index-list (project-list (process-quick-sort (qtrieve 'system-index
    *system-index-attributes*
    *system-index-attributes*
    *system-index-key*
    `(string-equal relation-name
   ,string-relation-name
   ))
   '(priority) *system-index-attributes*)
       *system-index-attributes* '(index-name index-type key))))
       (t
(cond ((setf index-list
     (qtrieve 'system-index *system-index-attributes* '(index-name index-type key)
      *system-index-key*
      `(and (string-equal relation-name ,string-relation-name)
    (string-equal index-name ,(string-upcase index-name)))))
       (cond ((stringp index-name)
      (setf relation-name (find-symbol (string-upcase index-name) *pkg-string*))))))))
 (cond (index-list
(do ((index-list index-list (cdr index-list)))
    ((or (null index-list) key-value) key-value)
  (setf key-value (funcall (find-symbol (concatenate 'string "EXTRACT-KEY-"
       (second (car index-list))) *pkg-string*)
   attributes (third (car index-list)) domains where-clause
   package-name)
index-name (find-symbol (string-upcase (first (car index-list))) *pkg-string*)
index-type (second (car index-list))
index-key (third (car index-list))))
(cond ((and (null index-name)
    (null key-value))
       (setf index-name relation-name
     index-type relation-storage-structure
     index-key key))))
       (t
(setf key-value nil
      index-name relation-name
      index-type relation-storage-structure
      index-key key))))
((null index-name)
 (setf index-name relation-name)))
  (values index-name key-value index-type index-key))

(defun modify-index (relation-name index-name
     &rest keyword-list
     &key &optional new-name documentation storage-structure key priority
     &allow-other-keys
     &aux index-doc index-info index-key index-priority index-type new-index-name
          relation-attributes relation-implementation relation-key relation-storage-structure
  temp-relation-name tuples)
  "2Modify an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index to be modified is defined
    INDEX-NAME - Name of the index to be modified
    NEW-NAME - New name for the specified index
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index."*
  new-name documentation storage-structure key priority
  (block modify-index
  (cond (*parameter-checking*
 (if (not (active-database relation-name))
     (return-from modify-index nil))))
  (if (not (setf relation-name (validate-sym relation-name)))
      (return-from modify-index nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf index-name (string-upcase index-name))
  (setf keyword-list (get-keyword-value-prereq '(new sto key doc priority) keyword-list))
  (setf new-index-name (get-keyword-value '(new sto key doc priority) keyword-list)
index-type (second new-index-name)
index-key (third new-index-name)
index-doc (fourth new-index-name)
index-priority (fifth new-index-name)
new-index-name (first new-index-name))
  ;;
  ;;1  Must determine if the relation upon which the index is requested does indeed exist in the current database.*
  ;;1 We must also know the attributes which are defined in the relation so that the validity of the key can be verified.*
  ;;
  (setf temp-relation-name (get-relation relation-name '(attributes implementation-type storage-structure key)
 nil)
relation-attributes (caadr temp-relation-name)
relation-implementation (second (second temp-relation-name))
relation-storage-structure (third (second temp-relation-name))
relation-key (fourth (second temp-relation-name))
temp-relation-name (car temp-relation-name))
  (cond ((not relation-attributes)
 (cond (*provide-error-messages*
(format *standard-output* "2~%ERROR - The relation ~s does not exist in the ~s database"*
relation-name *active-db*)))
 (return-from modify-index nil))
(t
 (setf relation-name temp-relation-name)))
  ;;
  ;;1  Determine if there is an index on the current relation with the same name as that requested. If not, it is an error.*
  ;;
  (setf index-info (car (funcall (find-symbol (concatenate 'string "2RETRIEVE-"*
   *system-relation-base-implementation*
   "2-"* *system-relation-storage-structure*)
      *pkg-string*)
 'system-index *system-index-attributes* '("2INDEX-TYPE" *"2PRIORITY" *"2DOC"* "2KEY")*
 *system-index-key*
 `(and (string-equal index-name ,index-name)
       (string-equal relation-name ,(string-upcase relation-name)))
 nil 'system-index)))
  (cond ((null index-info)
 (if *provide-error-messages*
     (format *standard-output* "2~%ERROR - An index with the name of ~s has not been defined on the relation ~s"*
      index-name relation-name))
 (return-from modify-index nil)))
  ;;
  ;;1  Determine if there is an index defined on this relation with the new-index-name already. If so it is an error*
  ;;
  (cond ((null new-index-name)
 (setf new-index-name index-name))
(t
 (cond ((caar (funcall (find-symbol (concatenate 'string "2RETRIEVE-"*
 *system-relation-base-implementation* "2-"*
 *system-relation-storage-structure*) *pkg-string*)
       'system-index *system-index-attributes* '("2INDEX-NAME")* *system-index-key*
       `(and (string-equal index-name ,(string-upcase new-index-name))
     (string-equal relation-name ,(string-upcase relation-name)))
       nil 'system-index))
(if *provide-error-messages*
    (format *standard-output*
    "2~%ERROR - An index with the name of ~s has already been defined on the relation ~s"*
    new-index-name relation-name))
(return-from modify-index nil)))))
  ;;
  ;;1  Determine if the requested storage structure is defined in the current database*
  ;;
  (cond ((null index-type)
 (setf index-type (first index-info)))
(t
 (setf index-type (string-upcase index-type))
 (cond ((not (car (qtrieve 'system-storage-structure *system-storage-structure-attributes*
   '("2STORAGE-STRUCTURE*-NAME") *system-storage-structure-key*
   `(string-equal storage-structure-name ,index-type))))
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is an undefined 2storage structure in the ~s database*"
    index-type *active-db*))
(return-from modify-index nil)))))
  ;;
  ;;1  Determine if the priority specified is within acceptable limits*
  ;;
  (cond ((null index-priority)
 (setf index-priority (second index-info)))
((< index-priority 1)
 (cond (*provide-error-messages*
(format *standard-output* "2~%ERROR - ~s is an illegal value for the value of priority."* index-priority)
(format *standard-output* "2~%        Priority must be a positive number."*)))
 (return-from modify-index nil)))
  (setf index-doc (or index-doc (third index-info)))
  (setf index-key (or (convert-attributes index-key) (fourth index-info)))
;
;1  Everything seems to be in order proceed*
;
  (if *provide-status-messages*
      (format *standard-output* "~%2Modify* 2index* ~s 2on relation ~s *in database ~s" (read-from-string index-name)
      (read-from-string (string-upcase relation-name)) (read-from-string *active-db*)))
  ;;
  ;;1  Must determine if the index relation needs to be recreated. This is the case if either the key or the*
  ;;1 storage structure has been modified.*
  ;;
  (cond ((not (and (equal (fourth index-info) index-key) (string-equal (first index-info) index-type)))
 ;;
 ;;1  Create the structure of the type of the storage structure of the index and insert the tuples into the new index.*
 ;;1 The DEFREL-sto function will validate the attributes and the key and define the appropriate structure.*
 ;;
 (cond ((null (errset
(setf index-key (funcall (find-symbol (concatenate 'string "DEFREL-" index-type)
      *pkg-string*)
       index-name relation-attributes (list 'key index-key))) nil))
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is an undefined storage structure" index-key))
(return-from modify-index nil)))
 (setf tuples (funcall (find-symbol (concatenate 'string "OBTAIN-2TUPLES-"* relation-storage-structure)
    *pkg-string*)
       relation-name))
 (funcall (find-symbol (concatenate 'string "2INDEX-INSERT-"* relation-implementation "2-"* index-type)
       *pkg-string*)
  index-name tuples relation-attributes index-key relation-name)))
  ;;
  ;;1  The index has been modified now modify the system-index relation to reflect the change.*
  ;;
  (delete-or-modify 'system-index t
    `(and (string-equal relation-name ,relation-name) (string-equal index-name ,index-name))
     '("2INDEX-NAME"* "2INDEX-TYPE"* "2KEY"* "2PRIORITY"* "2DOC"*)
     (list (string-upcase new-index-name) (string-upcase index-type) `(quote ,index-key)
    index-priority index-doc))
  (if *provide-status-messages*
      (format *standard-output* "~%2Index* ~s 2has been modified on relation ~s *in database ~s"
      (read-from-string index-name) (read-from-string (string-upcase relation-name))
      (read-from-string *active-db*)))
  (return-from modify-index new-index-name)))

(defun destroy-index (relation-name index-name
      &aux status?)
  "2Destroy the specified index which is defined on the specified relation.

   RELATION-NAME - The name of the relation upon which the relation is defined.
   INDEX-NAME - The name of the index to be deleted."*
  (block destroy-index
(cond (*parameter-checking*
       (if (not (active-database index-name))
   (return-from destroy-index nil))))
(cond ((not (setf relation-name (validate-sym relation-name)))
       (return-from destroy-index nil)))
(cond ((not (setf index-name (validate-sym index-name)))
       (return-from destroy-index nil)))
(cond ((not (member  (list (string-upcase relation-name)) (qtrieve 'system-relation
   *system-relation-attributes*
   '(relation-name)
   *system-relation-key* t)
     :test 'equal))
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The 2relation* ~s does not exist2 in the database ~s*."
  relation-name *active-db*))
      (return-from destroy-index nil)))
(cond ((not (member (list (string-upcase index-name))
    (qtrieve 'system-index  *system-index-attributes* '(index-name) *system-index-key*
     `(string-equal relation-name ,(string-upcase relation-name)))
    :test 'equal))
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - 2The index ~s is not defined on relation ~s in database ~s"*
  index-name relation-name *active-db*))
      (return-from destroy-index nil)))
(setf status? *provide-status-messages*
      *provide-status-messages* nil)
(delete-tuples 'system-index
       'where `(and (string-equal relation-name ,(string-upcase relation-name))
    (string-equal index-name ',(string-upcase index-name))))
(setf *provide-status-messages* status?)
(putp index-name nil 'entry-point)
(if *provide-status-messages*
    (format *standard-output* "~%Destruction of 2index* ~s 2on relation ~s *completed."
    index-name relation-name))
(return-from destroy-index index-name)))
BB`B7B	B
B:\
B3B7B	B9BBUBB3B:B:\B\BBBBExecute the database calls in a transaction.

   TRANSACTION - Name of the transaction to be commited.
   DIRECTORY   - Name of the directory in which this transaction can be found, if not in memory.
   PATHNAME    - Name of the file in which it can be found.B]BBA\BOBBBcBB\B9BBjBB\BBCB\B9B*BBbÂRTMS-READ-INSERT-FILEBB+Ҭ~%ERROR - The transaction file ~S does not exist; ~@
                              ~7T the transaction ~S has not been defined yet.BBERROR - The transaction file BB, does not exist.BBB@@@QPARQ	R@QGSGLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540731. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "INDEX" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360074. :AUTHOR "REL3" :LENGTH-IN-BYTES 6626. :LENGTH-IN-BLOCKS 13. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8INDEX\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPDEFINE-INDEX8v$8@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAME&RESTKEYWORD-LIST&KEYj&OPTIONALNAMEDOCUMENTATIONCSTORAGE-STRUCTUREKEYPRIORITYj&ALLOW-OTHER-KEYSB:\BbBeBfBgBhBiCINDEX-DOCCINDEX-KEYCINDEX-NAMEÁINDEX-PRIORITYCINDEX-TYPERELATION-ATTRIBUTESRELATION-IMPLEMENTATIONCRELATION-STORAGE-STRUCTURECTEMP-RELATION-NAMEBb\)MACROS-EXPANDED\pB\lXR-BQ-LISTFIRSTFIFTHFOURTHTHIRDSECONDPROGSETFDOCUMENTATIONTDefine an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index will be defined.
    NAME - Name of the index to be defined
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index. C*PROVIDE-STATUS-MESSAGES*Ã*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*у*PARAMETER-CHECKING*\NAMEBiSTORAGE-STRUCTUREKEY)PRIORITYpB\STORE-KEYARGSACTIVE-DATABASE҃VALIDATE-SYM\BeSTOBhDOCBiGET-KEYWORD-VALUE-PREREQCGET-KEYWORD-VALUECCONVERT-ATTRIBUTES\CATTRIBUTESIMPLEMENTATION-TYPEBgGET-RELATIONTERPRIERROR - The relation WRITE-STRINGPRIN1, does not exist in the l databaseGENSYMSTRINGSTRING-UPCASE҃SYSTEM-INDEX\RELATION-NAMElINDEX-NAMESTRING-EQUALBnLISTQTRIEVElERROR - An index with the name of l has already been defined on the relation AVLSYSTEM-STORAGE-STRUCTURE\STORAGE-STRUCTURE-NAMEÂSTORAGE-STRUCTURE-NAME,ERROR - l is an undefined storage structure in the , is an illegal value for the value of priority.        Priority must be a positive number.Define index *READ-FROM-STRING on relation  in database ÂCREATE-INDEX-RELATIONÀTUPLESÀINSERTIndex  has been defined on relation @@QPAQRQR@QOSOOS5OQ@P@Q@P@QHHWJH[GHQBFHUBIHSHQPN	BKNQBLNUBMNSNK
PQP	PPRNQHHHQHPP PP!P"PHQ#$BN
	%PNW&PNSRJ'PJ(PP)PP!P*PJQ#$
+PJQ,P	PPRIJIIQ

+PIQ-P.PRGKS#G/PHQ01PQ02P	P0QHQKQGQJQLQMQJ3RP4PQHQJQGQIQFQ##56PHQ07PQ02P	P0HOBPB*nAFD$B:BV]FB:B:B:BYFB^B\B`BnBqBmBpBrBsB:\BB:B:B:\Bv\BpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETplEH*CONDITION-HANDLERS*Bу*PKG-STRING*p,G3216F\ERRORpB\ERRSET-HANDLERB,DEFREL-BҪCONCATENATEҪFIND-SYMBOLBhBBB,ERROR - BBl is an undefined storage structureOBTAIN-TUPLES-INDEX-INSERT-l-PPTP	PPJCAPJCB
PPQPCQQPQCJ!BJ!B\\PQPہ
PPQPCQC@
PPQPQPCQ@QQQQCOBCOBTAIN-TUPLES-HEAP	F@F$B:BV]FB:B:B:BYFB^B\B`B:B:B:ENTRY-POINTGETPQPOBCOBTAIN-TUPLES-HASH@\F$B:BV]FB:B:B:BYFB^B\B`B:\B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGCTUPLE-LIST\INTERNAL-FEF-OFFSETS\FiVARIABLES-USED-IN-LEXICAL-CLOSURES\B\FF\)INTERNALBBB*MAPHASHPPCQPFOBB
@F$B:BV]FB:B:B:BYFB^B\KEY-VALBB:\B:B:B\Bv\BiLEXICAL-PARENT-DEBUG-INFOBpB\,*APPENDQPO)BCOBTAIN-TUPLES-AVL
F@F$B:BV]FB:B:B:BYFB^B*\B`B:B:B:BBÂAVL-INORDER-TRAVERSALQPO4B*INDEX-INSERT-FLAVOR-HASH0A`F$B:BV]FB:B:B:BYFB^B5\BnBBKEY-LISTB`B:\BhÁHASH-RELATIONB:B:B:B:ÀTUPLEÀKEYVAL\Bv\BpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSBÁPROJECT-FLAVORBB*GETHASHpBT,PUTHASHQQQQ@QPABсQ@QEDCCQDSESGFGQFQGQAQ
CAQCCDEDEBONB5INDEX-INSERT-STRUCT-HASH0A`F$B:BV]FB:B:B:BYFB^BO\BnBBB>B`B:\BhB@B:B:B:B:BABB\Bv\BBGBIBÁPROJECT-STRUCTBBBKBMQQQQ@QPABсQ@QEDCCQDSESGFGQFQGQAQ
CAQCCDEDEBO\BOINDEX-INSERT-FLAVOR-HEAP@F$B:BV]FB:B:B:BYFB^B]\BnBBB>B`B:B:B:BBpB\*NCONC҃PUTPQQPQPOiB]INDEX-INSERT-STRUCT-HEAP@F$B:BV]FB:B:B:BYFB^Bj\BnBBB>B`B:B:B:BBBgBhQQPQPOsBjINDEX-INSERT-FLAVOR-AVLQA\F2$B:BV]FB:B:B:BYFB^Bt\BnBBB>B`B:\DOMAIN-LISTDOMAIN-KEY-LISTBhNEW-ELEMENTTREEÀTUPLE%KEY%\Bv\BBÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*SYSTEM-RELATION\DOMAINSBB`BBB҃PROJECT-LISTBJBBAPPENDCINSERT-AVL-FLAVORBhPPPPPPQ	
B@
QQBAQQQBQPDQBQFEES
J



CCDQFSQQAQۀQJDEFEQDQPOBtINDEX-INSERT-STRUCT-AVLQA\F2$B:BV]FB:B:B:BYFB^B\BnBBB>B`B:\B~BBhBBBB\Bv\BBBBB\BBB`BBBBB[BBBCINSERT-AVL-STRUCTBhPPPPPPQ	
B@
QQBAQQQQBQPDQBQFEES
J



CCDQFSQQAQۄQJDEFEQDQPOBÂINDEX-INSERT-LIST-HEAP@F$B:BV]FB:B:B:BYFB^B\BnBBB>B`B:B:B:BBBgBhQQPQPOBÂINDEX-INSERT-LIST-HASH0A`F$B:BV]FB:B:B:BYFB^B\BnBBB>B`B:\B@BhB:B:B:B:BABB\Bv\BBGBIBBBBBKBMQP@QQQABсQAQEDCCQDSESGFGQFQGQ@Q
C@QCCDEDEBOBÂINDEX-INSERT-LIST-AVLQA\F2$B:BV]FB:B:B:BYFB^B\BnBBB>B`B:\B~BBhBBBB\Bv\BBBBB\BBB`BBBBBBBBINSERT-AVL-LISTBhPPPPPPQ	
B@QQBAQQQBQPDQBQFEESJ
CCDQFSQQAQۀQJDEFEQDQPOBEXTRACT-KEYGAFa$B:BV]FB:B:B:BYFB^B\B`BBhBBsWHERE-CLAUSEBnB:\BmCINDEX-LISTBpCKEY-VALUESTRING-RELATION-NAMEPACKAGE-NAMEB:B\Bv\BzB}B~BByBBBC*SYSTEM-RELATIONS*BܑBBBEXTRACT-KEY-BBBpB\MEMBER-TESTBB`BB\BiCPROCESS-QUICK-SORT\BnBpBhBҪANDBnBQDQCPE	P
PQPFQQQQEQFCQBQ@CeDQPP`QPPPPPPDQPPPPAPPPPPPPDQPPQA17QPA(AQG	P
PGQ
BPFQGQBQQEQFCGQBPGQ
BBGQB@GCCCۀQQBQ@QQCQBQ@QOBMODIFY-INDEXLLF$B:BV]FB:B:B:BYFB^B\B`BnBaBbBcBdNEW-NAMEBfBgBhBiBjB:\BbBBfBgBhBiBlCINDEX-INFOBmBoBpÁNEW-INDEX-NAMEBqBrRELATION-KEYBsBtBBbB:B:B:B:\Bv\BBBBBByBzB{B|B}B~BBBtModify an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index to be modified is defined
    INDEX-NAME - Name of the index to be modified
    NEW-NAME - New name for the specified index
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index.ABBBBBBBу*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*BBB\)NEW-NAMEBBBBBBBB\NEWBBhBBiBB\BBBgBhBBERROR - The relation BB, does not exist in the l databaseBlRETRIEVE-l-BBB\lINDEX-TYPE,PRIORITYDOCKEYBBBnBB`lERROR - An index with the name of  has not been defined on the relation \lINDEX-NAMEl has already been defined on the relation B\STORAGE-STRUCTURE-NAMEBB,ERROR - l is an undefined storage structure in the , is an illegal value for the value of priority.        Priority must be a positive number.BModify index B on relation  in database pB\STRING-EQUAL*pBG3393FBB,DEFREL-Bhl is an undefined storage structureOBTAIN-TUPLES-INDEX-INSERT-\lINDEX-NAMElINDEX-TYPEKEY,PRIORITYDOCB8DELETE-OR-MODIFYIndex , has been modified on relation @@QPAQRQR@QRSRRS5RQ@QP@Q@P@QKKWJK[HKQBFKUBIKSKQPP	BLPQBMPUBOPWBNPSPLPQPPPRPQ P!PP"PP#
P$S%P	P&PP'P(P)PQ*(P+PQ**%PJSBG	,PQ-PQRKQK+ P!PP"PP#
P$S%P	P.PP'P(P)PKQ*(P+PQ**%PJS	,PKQ/PQRJGSJJQJ0PP1PP(P2PJQ*34PJQ5PPPRIGWIIQ
4PIQ6P7PRFQG[FHQ8GQBH9PQ:;PQ:<PP:GQBH+GSJQ=L>P?PT@PAP>PJCTPJCU PBPJQ#
P$VQLQCPHQ*VH*J!BJ!B\\
4PHQDPR PEPOQ#
P$VQVQ PFPMQ"PJQ#
P$VQQQLQHQQV%P'P(P+PQ*(P)PQ**GPKQJQHPHQ*IQFQ*IJPQ:KPQ:<PP:KO!BÁDESTROY-INDEX+8@+Fc$B:BV]FB:B:B:BYFB^B"\B`BnB:\STATUS?\Bv\ByBBDestroy the specified index which is defined on the specified relation.

   RELATION-NAME - The name of the relation upon which the relation is defined.
   INDEX-NAME - The name of the index to be deleted.BBBBBBBBBBBBB\B`BpB\MEMBER-EQUALBERROR - The relation BB, does not exist in the database e.jWRITE-CHARB\BnBB`lERROR - The index  is not defined on relation  in database ÀWHEREBBnB8ÁDELETE-TUPLESBBhDestruction of index  on relation  completed.
QRQRQRQP	PPPPQPPPRQPPPPPPQPQPQ PPRP@P!P"PPPQP#P$PQ%@QQ&P'(PQ)PQ*PO@B"1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\BI(̢\BG*j\B؆-i\Bֆ~z\BԆ<p\B҆`sN\BІ|\B[\B=#\B~{\B}:}n\B|x\B{Zi\Bzz(\By.ً (package-name (or (symbol-package relation-name) *pkg-strinLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540734. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "INSERT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2755196698. :AUTHOR "REL3" :LENGTH-IN-BYTES 19826. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; INSERT*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     deff*
;1;;     :string-in*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     insert-flavor-hash*
;1;;     insert-flavor-heap*
;1;;*

;1;; Change History --*
;1;; 04.20.87 MRR  Removed *&optional1 from INSERT lambda list.*


(defun rtms-read-insert-file (pathname
      &aux (beg-index 0) end-index index value (extend-size 4096) (total-length 0))
  (setf value (make-array extend-size)
end-index extend-size)
  (with-open-file (stream1  pathname)
    (do ((eof-flag nil))
(eof-flag t)
      (multiple-value-setq (index eof-flag)
(funcall stream1 ':string-in nil value beg-index end-index))
      (setf total-length (+ total-length index))
      (cond ((not eof-flag)
     (setf value (adjust-array value (+ total-length extend-size)))
     (setf beg-index end-index
           end-index (+ total-length extend-size))))))
  (read-from-string value nil nil :start 0 :end total-length))

1;*************************************************************************
;1           For the sake of old references to this function             *
;*************************************************************************
(defun insert1 (rel tuples &optional attribute-list)
  (insert rel (list 'tuples tuples 'attr attribute-list)))

(deff insert-tuples 'insert)

(defun insert (relation-name &rest keyword-list
       &key tuples attributes pathname
       &allow-other-keys
       &aux (attr-val-list nil) (sub-list nil) tuple project-list path attribute-list (key nil) ss imp
       card qtrieve-var mod-tuples qtrieve-var1 qtrieve-var2 indices)
  "Insert a list of tuples or data from a file.

   RELATION-NAME   - Name of the relation into which the data is to be inserted.
   TUPLES     - List of tuples to be inserted. Tuples are expected to be in the list-of-values format.
   ATTRIBUTES - If the values in the tuples do not correspond to the attribute-list specified during
                relation-defintion, specify a list of attributes to determine the order.
   PATHNAME   - If the data is in a file, specify the name of the file."
   tuples attributes pathname

  (block insert
  (setf keyword-list (de-nest-keyword-list keyword-list))
  (cond (*parameter-checking*
 (if (or (not (active-database)) (null (setf relation-name (validate-sym relation-name))))
     (return-from insert nil))
 (setf keyword-list (get-keyword-value-prereq '(tuple attr path) keyword-list))))
  (setf tuple (car (get-keyword-value '(tuple) keyword-list))
project-list (car (get-keyword-value '(attr) keyword-list))
path (car (get-keyword-value '(path) keyword-list)))
  (if (and *parameter-checking* project-list (not (listp project-list)))
      (setf project-list (list project-list)))
  (cond ((and *parameter-checking* tuple path)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - List of tuples as well as a pathname provided."))
 (return-from insert nil)))
  ;;
  ;;1  INSERT has been called by one of the restore operations (LOAD-RELATION) and in reference to one of the system-relations*
  ;;1 insert the tuples without further processing and return.*
  ;;
  (if (and *restore-operation* (member (string-upcase relation-name) *system-relations*
       :test 'string-equal))
      (return-from insert
(funcall
  (find-symbol (concatenate 'string "INSERT-" *system-relation-base-implementation* "-"
      *system-relation-storage-structure*) *pkg-string*)
  relation-name
  (eval (read-from-string (concatenate 'string *pkg-name* "*" (string relation-name)
       "-ATTRIBUTES*")))
  tuple
  (eval (read-from-string (concatenate 'string *pkg-name* "*" (string relation-name) "-KEY*")))
  relation-name)))
  ;;
  ;;1  If there multiple indices defined on this relation, the tuples inserted into the base relation must also be inserted into each of the*
  ;1; secondary indice relations. Not only do the tuples have to be inserted but the* 1SAME tuples.*
  ;;
  (cond ((not (member (string relation-name) *system-relations* :test 'string-equal))
 (setf indices (qtrieve 'system-index *system-index-attributes* '("INDEX-NAME" "INDEX-TYPE" "KEY")
*system-index-key*
`(string-equal relation-name ,(string relation-name))))))
  ;;
  ;;1  Obtain some information of the relation into which the tuples will be inserted.*
  ;;
  (setf qtrieve-var (get-relation relation-name
  '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY" "CARDINALITY")
  t))
  (cond ((null (cadr qtrieve-var))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Relation ~S is not defined in the database ~S"
     relation-name *active-db*))
 (return-from insert nil)))
  (setf relation-name (car qtrieve-var)
qtrieve-var (cadr qtrieve-var)
imp (second qtrieve-var)
ss (third qtrieve-var)
key (fourth qtrieve-var)
card (fifth qtrieve-var)
attribute-list (convert-attributes (first qtrieve-var)))
  ;;
  ;;1  Validate that the attribues specified in the project list supplied by the user are actually attributes of the*
  ;;1 relation and place them into the proper form.*
  ;;
  (if *parameter-checking*
      (if project-list
  (setf project-list (mapcar #'(lambda (attr)
 (if (null (validate-sym attr t))
     (return-from insert nil)
     (validate-sym attr t)))
     project-list)))
      (setf project-list (convert-attributes project-list)))
  ;;
  ;;1  If the data is stored in a file, read it into the TUPLE.*
  ;;
  (cond (path
 (if (probe-file path)
     (setf tuple (rtms-read-insert-file path))
     (if *provide-error-messages*
 (format *standard-output* "~%ERROR - File ~S does not exist." path)))))
  (cond ((null tuple)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - No tuples provided."))
 (return-from insert nil)))
  ;;
  ;;1  Obtain information about the attributes of the insert relation*
  ;;
  (if (not (or (member (string relation-name) *system-relations* :test 'string-equal) *restore-operation*
       (not *validity-checking*)))
      (setf qtrieve-var
    (funcall (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation* "-"
       *system-relation-storage-structure*) *pkg-string*)
     'system-attribute *system-attribute-attributes*
     '("ATTRIBUTE-NAME" "DOMAIN-FUNCTION" "DEFAULT-VALUE") *system-attribute-key*
     (list 'string-equal 'relation-name  (string relation-name)) nil 'system-attribute)))
  ;;
  ;;1 Check for various possibilities of INSERT format. First see if tuple is a list of tuples. Store the attribute names*
  ;;
  (cond ((or (member (string-upcase relation-name) *system-relations* :test 'string-equal) *restore-operation*)
 (setf attr-val-list tuple))
((null (listp tuple))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - List of tuples not provided."))
 (return-from insert nil))
;;
;;1 Check for form 2 ...Multiple inserts AND the optional attribute list is provided,*
;;
(project-list
 ;;
 ;;1 Make sure that all attributes provided are actually the attributes in the relation.*
 ;;
 (if *parameter-checking*
     (mapl (function (lambda (cdr-attr &aux attr)
       (setf attr (car cdr-attr))
       (cond ((not (member attr attribute-list :test 'string-equal))
      (if *provide-error-messages*
  (format *standard-output*
  "~%ERROR - ~S is not an attribute in the relation ~S"
  attr relation-name))
      (return-from insert nil))
     ((member attr (cdr cdr-attr) :test 'string-equal)
      (if *provide-warning-messages*
  (format *standard-output*
  "~%WARNING - Attribute ~S has been specified more than once in the attribute list."
  attr))))))
   project-list))
 ;;
 ;;1  CHeck the length of the tuple provided against the length of the attribute list provided. If they are different in length*
 ;;1 inform the user that RTMS is substituting the default values for the missing attributes.*
 ;;
 (mapc
   (function (lambda (sub-tuple &aux (actual-p-l project-list))
       (cond
 ((listp sub-tuple)
  (if (and *parameter-checking* (< (length actual-p-l)(length sub-tuple)))
      (mapc #'(lambda (attr)
(if (not (or (member attr actual-p-l :test 'string-equal)
     (equal (length actual-p-l) (length sub-tuple))))
    (setf actual-p-l (append actual-p-l (list attr)))))
    attribute-list))
  (if (and *parameter-checking* (> (length actual-p-l)(length sub-tuple)))
      (progn
(setf actual-p-l (firstn (length sub-tuple) actual-p-l))
(if *provide-warning-messages*
    (format *standard-output*
    "~%WARNING - The tuple ~S is smaller in length than the attribute-list. The extra attributes will get the default values for this tuple."
    sub-tuple))))
  (setf sub-list nil)
  (mapc
    (function
      (lambda (attr &aux test)
(cond ((member attr actual-p-l :test 'string-equal)
       (setf sub-list
     (cons
       (if (setf test (caar (project-list (list sub-tuple)
  actual-p-l
  (list attr))))
   test
   (caddr (assoc (string-upcase attr) qtrieve-var
 :test 'string-equal)))
       sub-list)))
      (t
       (setf sub-list
     (cons (caddr (assoc (string-upcase attr) qtrieve-var
 :test 'string-equal))
   sub-list))))))
    (reverse attribute-list))
  (setf attr-val-list (cons sub-list attr-val-list)))
 (t
  (cond (*provide-warning-messages*
 (format *standard-output* "~%WARNING - The tuple ~S is not a list."
 sub-tuple)
 (format *standard-output* "~%          It will not be inserted.")))))))
   tuple))
;;
;;1It is of form 1.*
;;
(*parameter-checking*
 (mapc
   (function
     (lambda (sub-tuple)
       (cond ((not (listp sub-tuple))
      (cond (*provide-warning-messages*
     (format *standard-output* "~%WARNING - The tuple ~S is not a list."
     sub-tuple)
     (format *standard-output* "~%          It will not be inserted."))))
     ((< (length sub-tuple) (length attribute-list))
      (setf attr-val-list
    (cons
      (append sub-tuple
      (mapcar
(function
  (lambda (attr)
    (caddr (assoc (string-upcase attr) qtrieve-var
  :test 'string-equal))))
(nthcdr (length sub-tuple) attribute-list)))
      attr-val-list)))
     ((> (length sub-tuple) (length attribute-list))
      (setf attr-val-list (cons (firstn (length attribute-list) sub-tuple) attr-val-list)))
     (t
      (setf attr-val-list (cons sub-tuple attr-val-list))))))
   tuple))
(t
 (setf attr-val-list tuple)))
  ;;
  ;;1  Perform validity checking on the tuples to be inserted if some requested*
  ;;
  (cond ((and *validity-checking* (not (member (string-upcase relation-name) *system-relations*
       :test 'string-equal))
      (not *restore-operation*))
 (setf mod-tuples attr-val-list
       attr-val-list nil
       qtrieve-var1 nil
       qtrieve-var2 nil)
 (mapc #'(lambda (attr &aux fun dom)
     (setf fun (read-from-string
 (concatenate 'string *pkg-name*
(setf dom (cadr (assoc attr qtrieve-var
       :test 'string-equal))))))
     (push fun qtrieve-var1)
     (push dom qtrieve-var2))
 (reverse attribute-list))
 (do ((tuples mod-tuples (cdr tuples)))
     ((null tuples) t)
   (if (domain-check attribute-list qtrieve-var1 qtrieve-var2 (car tuples))
       (setf attr-val-list (cons (car tuples) attr-val-list))
       (cond (*provide-warning-messages*
      (format *standard-output* "~%WARNING - ~S is not a valid tuple." (car tuples))
      (format *standard-output* "~%          It will not be inserted."))))))
(t
 (setf attr-val-list (reverse attr-val-list))))
  (if (null attr-val-list)
      (return-from insert (format *standard-output* "~%ERROR - No valid tuples to be inserted.")))
  ;;
  ;;1  Perform the actual insertation by calling the low level insert functions. The tuple must be inserted into all of*
  ;;1 secondary index structures as well as the base relation. The low level accessor functions return a list of the tuples*
  ;;1 which were inserted. Use this list to insert into the index relations.*
  ;;
  ;;  These insert functions need to be surrounded by a UNWIND-PROTECT. The entry points need to saved else
  ;;1 *where and restored if there is a problem
  ;;
  (setf tuples (funcall (find-symbol (concatenate 'string "INSERT-" imp "-" ss) *pkg-string*)
(string relation-name) attribute-list attr-val-list key (string relation-name)))
  (cond (indices
 (mapc (function (lambda (key%)
   (funcall (find-symbol (concatenate 'string "2INDEX-*INSERT-" imp "-" (second key%))
 *pkg-string*)
    (first key%) tuples attribute-list (third key%) relation-name)))
       indices)))
  ;;
  ;;1Reset the modified flag* 1and increment the cardinality.*
  ;;
  (cond ((not *restore-operation*)
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name (string-upcase relation-name))
   '("MODIFIEDP" "CARDINALITY") (list t (+ card (length attr-val-list))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-RELATION")
   '("MODIFIEDP") (list t))
 (if *provide-status-messages*
     (format *standard-output* "~%~s tuple~:P inserted into the ~s relation"
     (length attr-val-list) relation-name))
 (return-from insert relation-name))
(t
 (return-from insert relation-name)))))

(defun insert-flavor-hash (relation-name attr-list tuples key index-name &aux hash-relation)
  (setf key (project-list tuples attr-list key)
hash-relation (getp index-name 'entry-point))
  (setf attr-list (unconvert-attributes attr-list))
  (setf relation-name (read-from-string (concatenate 'string *pkg-name* (string-upcase relation-name))))
  (mapcar (function (lambda (tuple keyval &aux %tuple)
      ;;
      ;;1Insert the tuple into the hash table using heap formation for collissions. Form the instance to be stored in the*
      ;1; hash table.*
      ;;
      (setf %tuple (make-instance relation-name))
      (do ((tuple tuple (cdr tuple))
   (attr-list attr-list (cdr attr-list)))
  ((null tuple) %tuple)
(set-in-instance %tuple (car attr-list) (car tuple)))
      (puthash keyval (cons %tuple (gethash keyval hash-relation)) hash-relation)
      %tuple))
  tuples key))

(defun insert-flavor-heap (relation-name attr-list tuples key index-name)
  key attr-list
  (setf attr-list (unconvert-attributes attr-list))
  (setf relation-name (read-from-string (concatenate 'string *pkg-name* (string-upcase relation-name))))
  (let (flavor-tuples (relation-tuples (getp index-name 'entry-point)) (tuples-length (length tuples)))
    (if (nth tuples-length relation-tuples)
(putp index-name (append (setf flavor-tuples (mapcar #'(lambda (tuple &aux %tuple)
 (setf %tuple (make-instance relation-name))
 (do ((tuple tuple (cdr tuple))
      (attr-list attr-list (cdr attr-list)))
     ((null tuple) %tuple)
   (set-in-instance %tuple (car attr-list)
    (car tuple))))
     tuples))
 (getp index-name 'entry-point))
      'entry-point)
(putp index-name (append (getp index-name 'entry-point)
 (setf flavor-tuples (mapcar #'(lambda (tuple &aux %tuple)
 (setf %tuple (make-instance relation-name))
 (do ((tuple tuple (cdr tuple))
      (attr-list attr-list (cdr attr-list)))
     ((null tuple) %tuple)
   (set-in-instance %tuple (car attr-list)
    (car tuple))))
     tuples)))
      'entry-point))
    flavor-tuples))

(defun insert-list-hash (relation attr-list tuples key index-name &aux hash-relation)
  relation
  (setf key (project-list tuples attr-list key)
hash-relation (getp index-name 'entry-point))
  (mapc
    (function (lambda (tuple keyval)
;;
;;1Here the tuple (val.1 val.2 .......val.n) itself is stored in the the hash table.*
;;
(puthash keyval (cons tuple (gethash keyval hash-relation)) hash-relation)))
    tuples key)
  tuples)

(defun insert-list-heap (relation attr-list tuples key index-name)
  key attr-list relation
  (let ((relation-tuples (getp index-name 'entry-point)) (tuples-length (length tuples)))
1     *;1; The idea here is that append copies all arguments except the last, therefore for speed reasons the small list should
     *;1; be the first argument to append. Length takes too long so a faster determination of the probable shortest list must be made.*
    (if (nth tuples-length relation-tuples)
(putp index-name (append tuples relation-tuples) 'entry-point)
(putp index-name (append relation-tuples tuples) 'entry-point)))
  tuples)

(defun insert-struct-hash (relation-name attr-list tuples key index-name
   &aux hash-relation relation-macro (string-relation-name (string relation-name)))
    (setf key (project-list tuples attr-list key)
  hash-relation (getp index-name 'entry-point))
  ;;
  ;;1Instead of calling the project for each tuple after the instance is created we are calling PROJECT-LIST so that we need to call*
  ;1; PROJECT only once.*
  ;;
  (setf relation-macro (read-from-string (concatenate 'string *pkg-name* "MAKE-"
      string-relation-name)))
    (setf attr-list
  (mapcar #'(lambda (attr)
      (read-from-string (concatenate 'string ":" string-relation-name attr)))
  attr-list))
    (mapcar (function (lambda (tuple keyval &aux %tuple attr-val)
;;
;;1Insert the instance into the hash table*
;;
(do ((tuple tuple (cdr tuple))
   (attr-list attr-list (cdr attr-list)))
  ((null tuple) attr-val)
(push `(quote ,(car tuple)) attr-val)
(push (car attr-list) attr-val))
(setf %tuple (eval `(,relation-macro ,@attr-val)))
(puthash keyval (cons %tuple (gethash keyval hash-relation)) hash-relation)
%tuple))
    tuples key))

(defun insert-struct-heap (relation-name attr-list tuples key index-name
   &aux relation-macro struct-tuples
   (string-relation-name (string relation-name)))
  key attr-list
  (setf relation-macro (read-from-string (concatenate 'string *pkg-name* "MAKE-"
      string-relation-name)))
  (setf attr-list
(mapcar #'(lambda (attr)
    (read-from-string (concatenate 'string ":" string-relation-name attr)))
  attr-list))
  (setf struct-tuples (mapcar (function (lambda (tuple &aux attr-val)
  (do ((tuple tuple (cdr tuple))
       (attr-list attr-list (cdr attr-list)))
      ((null tuple) attr-val)
    (push `(quote ,(car tuple)) attr-val)
    (push (car attr-list) attr-val))
  (eval `(,relation-macro ,@attr-val))))
      tuples))
  (let ((relation-tuples (getp index-name 'entry-point)) (tuples-length (length struct-tuples)))
1     *;1; The idea here is that append copies all arguments except the last, therefore for speed reasons the small list should
     *;1; be the first argument to append. Length takes too long so a faster determination of the probable shortest list must be made.*
    (if (nth tuples-length relation-tuples)
(putp index-name (append struct-tuples relation-tuples) 'entry-point)
(putp index-name (append relation-tuples struct-tuples) 'entry-point)))
  struct-tuples)
E")* *system-index-key*
       `(and (string-equal index-name ,(string-upcase new-index-name))
     (string-equal relation-name ,(string-upcase relation-name)))
       nil 'system-index))
(if *provide-error-messages*
    (format *standard-output*
    "2~%ERROR - An index with the name of ~s has already been defined on the relation ~s"*
    new-index-name relation-name))
(return-from modify-index nil)))))
  ;;
  ;;1  Determine if the requested storage structure is defined in the current database*
  ;;
  (cond ((null index-type)
 (setf index-type (first index-info)))
(t
 (setf index-type (string-upcase index-type))
 (LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540738. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "INSERT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360272. :AUTHOR "REL3" :LENGTH-IN-BYTES 4353. :LENGTH-IN-BLOCKS 9. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             pp2\COMPILE-DATA\SW-MFG,GODZILLA`FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8INSERT\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPÂRTMS-READ-INSERT-FILE"T@`F2$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\*PATHNAMEB:\CBEG-INDEXCEND-INDEXÀINDEXÀVALUETOTAL-LENGTHB:pB\.FILE-ABORTED-FLAG.EOF-FLAG\)MACROS-EXPANDED\PROG*WITH-OPEN-STREAMWITH-OPEN-FILESETFFpB\lSIMPLE-MAKE-ARRAYABORTFMOPENiSTRING-INFADJUST-ARRAYpBTERRORPCLOSESTARTEND*READ-FROM-STRING@DPJCPAPFPJUQEPCQ@QAQ	PEQAGBDaDGCQDQ`
CAQ@DQ`AGF]RZ	EEQPFQECQPJPDQJOBPINSERT1$F$B:BV]FB:B:B:BYFB^B\RELÀTUPLESj&OPTIONALÁATTRIBUTE-LISTB:B:B:BATTRLISTÀINSERTQPQPQOBBOÁINSERT-TUPLESB`F솀`@F$B:BV]FB:B:B:BYFB^B\ÁRELATION-NAME&RESTKEYWORD-LIST&KEYBCATTRIBUTESB`j&ALLOW-OTHER-KEYSB:\!BBBB`ÁATTR-VAL-LISTSUB-LISTÀTUPLEPROJECT-LISTPATHB
KEYCSSIMPCARDQTRIEVE-VARCMOD-TUPLESQTRIEVE-VAR1QTRIEVE-VAR2INDICESB:B:B:BCSUB-TUPLECACTUAL-P-LB:TESTB:B:FUNDOMBKEY%\Bk\PUSHBmpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSFIRSTFIFTHFOURTHTHIRDSECONDpB\lXR-BQ-LISTBpDOCUMENTATIONInsert a list of tuples or data from a file.

   RELATION-NAME   - Name of the relation into which the data is to be inserted.
   TUPLES     - List of tuples to be inserted. Tuples are expected to be in the list-of-values format.
   ATTRIBUTES - If the values in the tuples do not correspond to the attribute-list specified during
                relation-defintion, specify a list of attributes to determine the order.
   PATHNAME   - If the data is in a file, specify the name of the file. C*PROVIDE-STATUS-MESSAGES*C*PROVIDE-WARNING-MESSAGES*Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*у*VALIDITY-CHECKING*у*ACTIVE-DB*C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*C*PKG-NAME*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*C*SYSTEM-RELATIONS*у*RESTORE-OPERATION**PROVIDE-ERROR-MESSAGES*у*PARAMETER-CHECKING*\TUPLESiATTRIBUTES)PATHNAMEpB\STORE-KEYARGS҃DE-NEST-KEYWORD-LISTACTIVE-DATABASE҃VALIDATE-SYM\BBBGET-KEYWORD-VALUE-PREREQ\BCGET-KEYWORD-VALUE\B\BBTERPRIERROR - List of tuples as well as a pathname provided.WRITE-STRINGSTRING-UPCASEҪSTRING-EQUALpB\MEMBER-TESTSTRING,INSERT-l-CONCATENATEҪFIND-SYMBOLl*BҬ-ATTRIBUTES*BҪEVAL-KEY*SYSTEM-INDEX\lINDEX-NAMElINDEX-TYPEKEYBQTRIEVE\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYCARDINALITYGET-RELATIONlERROR - Relation PRIN1, is not defined in the database CCONVERT-ATTRIBUTESjPROBE-FILEBPERROR - File , does not exist.ERROR - No tuples provided.lRETRIEVE-SYSTEM-ATTRIBUTE\ATTRIBUTE-NAME,DOMAIN-FUNCTIONDEFAULT-VALUEERROR - List of tuples not provided.,ERROR -  is not an attribute in the relation WARNING - Attribute l has been specified more than once in the attribute list.pB\,*APPENDpBTFIRSTNҬWARNING - The tuple , is smaller in length than the attribute-list. The extra attributes will get the default values for this tuple.*REVERSEBpB\lASSOC-TEST, is not a list.l          It will not be inserted.DOMAIN-CHECKlWARNING -  is not a valid tuple.,ERROR - No valid tuples to be inserted.INDEX-INSERT-SYSTEM-RELATION\lMODIFIEDPCARDINALITYDELETE-OR-MODIFY,SYSTEM-RELATION\lMODIFIEDP tupleesjWRITE-CHARҬ inserted into the l relation@@QPA@Q@QRP@Q@P@QBFP@QBGP@QBHGG5GQG
FH !P"R%Q#P$P%&P'PP(PP)P*SQ&PP+PQ,-P)./FQ&PP+PQ,0P)./QSQ,P$P%1PP2P
P$P3PQ,4RQ5P6NN	 7P"Q89P"	P8RNSNWNNWLN[KNQBJNUBMNS:IGSSGQUTTQUSVRVQCTUUSQGQ:GHHQ;HQ<F
 =P"HQ8>P"F ?P"RQ,P$P%&P@PP(PP)P*UAPPBPP$P3PQ,APJUNQ#P$P%F5 CP"RG&GQT#VTSVIQ$P%	 DP"VQ8EP"Q8RVQTU$P%	 FP"VQ8GP"TFQTTSWGQXW5Y1GQCWQCxIQYYSVXQ$P%XQCWQC|XQVQHXYXQWQCWQCXQIX JP"WQ8KP"EIQLSSSVZVQXQ$P%WQXQVQMBZZQVQ#NQ$PNBE]ESEQD]D
 JP"WQ8OP" PP"TœIEFQUDUSWW59 JP"WQ8OP" PP".WQCIQCxWQTTWQCIQ
C\[[Q\SV#NQ$PNBC[\\TQHWQIQCIQCWQIWQD]DUſFQDCQ#P$P%=;DQODPQIQL[[SV]^&PPVQNQ$PNB^).]P]P^QQ]Q[OQ_IQPQQQ_SQ_SD]D
 RP"_S8SP" PP"_DQLDD TP"R&P'PLQ(PKQ)P*\Q,IQDQJQQ,\ARRQ[[S`&PUPLQ(P`W)P*Y`SAQIQ`[QY[,VP$P3PQ#WPDQCMaXVP$P3PYPZPX DQC8[P"DQC\P]^P"Q8_P"O4BCINSERT-FLAVOR-HASH"TAhF2$B:BV]FB:B:B:BYFB^B5\BCATTR-LISTBBCINDEX-NAMEB:\
ÁHASH-RELATIONB:B:B:B:BÀKEYVALÀ%TUPLEBB>\Bk\BmBBBpBБB҃ENTRY-POINTGETP҃UNCONVERT-ATTRIBUTESBBBBpBTMAKE-INSTANCEpBT,SET-IN-INSTANCE*GETHASHpBT,PUTHASHQQQQP@QPPQ	
AтQQDCB$BQCSDSFEGۀQGEQHQIGQISHSHIHFQGQFQ@Q
C@QGQCBCDCDAOPB5CINSERT-FLAVOR-HEAP3uAlFB$B:BV]FB:B:B:BYFB^BQ\BB>BBB?B:\ÁFLAVOR-TUPLESRELATION-TUPLESÁTUPLES-LENGTHB:B:B:BBCBB>B:\Bk\BmBBBpBБBHBBBBBFBGBJBLB҃PUTPQPPQQ	P
QCBAQBQAQ&CтQEDDQESFGۀQGFQHQIGQISHSHIHGQCDEECQ@ÄQ	P
&Q	P
EEтQCJJQCSHGۀQGHQFQIGQISFSFIFGQCJCCEQ@	P@OaBQINSERT-LIST-HASH*ATF$B:BV]FB:B:B:BYFB^Bb\RELATIONB>BBB?B:\BAB:B:BBB\Bk\BmBBpBBFBGBMBOQQQQP@QQBAASBSDCDQCQDQ@Q
C@QABABOoBbINSERT-LIST-HEAPAHF$B:BV]FB:B:B:BYFB^Bp\BkB>BBB?B:\B\B]B:BFBGBB`QPQCA@QAQ@QQ@Q@QQPOzBpCINSERT-STRUCT-HASH0rA|FB$B:BV]FB:B:B:BYFB^B{\BB>BBB?B:\BAÁRELATION-MACROSTRING-RELATION-NAMEB:B:B:BB:B:BBBBCATTR-VALBB>\Bk\pB\lXR-BQ-CONSBBBmBBBpBБBBBFBGBMAKE-BBl:B8BBBMBOQBQQQQP@PP	PBQ
ACсQEDDQESFPPBQFQ
CDEECQEEтQQCHG*GQHSCSJIKLIQMQN
PMSL]LNSL]LMNMAQL]KJQKQJQ@Q
C@QKQCGHCHCEOB{CINSERT-STRUCT-HEAP.mAxF?$B:BV]FB:B:B:BYFB^B\BB>BBB?B:\BÁSTRUCT-TUPLESBB:B:B:BB:BBBB>B\B]\Bk\BBBBmBBBpBБBBMAKE-BBl:B8BBBFBGBB`QBPPPBQ@CсQEDDQESFP	PBQFQCDEECQEEтQCGGQCSHIHQJQK

PJSI]IKSI]IJKJ@QI]CGCCEQAQPAQCMLQMQLQAQLQLQAQPAOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\B\BĆ.ً\B{\B:}n\Bx\BZi\Bz(\B(̢\B*j\B\Bp[\BoF\Bn)\Bm=#'(lambda (attr)
(if (not (or (member attr actual-p-l :test 'string-equal)
     (equal (length actual-p-l) (length sub-tuple))))
    (setf actual-p-l (append actual-p-l (list attr)))))
    attribute-list))
  (if (and *parameter-checking* (> (length actual-p-l)(length sub-tuple)))
      (progn
(setf actual-p-l (firstn (length sub-tuple) actual-p-l))
(if *provide-warning-messages*
    (format *standard-output*
    "~%WARNING - The tuple ~S is smaller in length than LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540741. :SYSTEM-TYPE :LOGICAL :VERSION 3. :TYPE "LISP" :NAME "INTERFACE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2757594269. :AUTHOR "REL3" :LENGTH-IN-BYTES 131948. :LENGTH-IN-BLOCKS 129. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(WIDER-MEDFNT MEDFNB MEDFNB HL7); Base:10 -*-
;1;; Copyright (c) by Texas Instruments, Incorporated*
;1;; All rights reserved*
;**************************************************************************
;1                             USER INTERFACE                                       **
;1                                                                                  **
;1                                                                                  **
;1 1. Issues to be considered later.                                                **
;1   a) Output-window  ----> a specified file.                                      **
;1   b) Parts of output (ex. a relation) to a ZMACS window.                         **
;1   c) Use line area scrolling for interactive maintenance of database.            **
;1                                                                                  **
;1                                                                                  **
;1                                                                                  **
;1                                                                                  *
;  AUTHOR*1                *1  *
;*1CSL*1           *
;*1Texas Instruments*1           **
;1.....*1           *
;*1Version 0.0*1           **
;**************************************************************************
;;;Change History
;;;  03.31.87  MRR  Changed DBMS-RC defflavor to make scroll-bar always appear.
;;;                 Changed references to XFASL files to XLD for Save-relation command.
;;;  04.01.87  MRR  Changed DBMS-RC defflavor to prevent pixel overlap of scroll-bar.
;;;  04.06.87  MRR  Fixed HELP-LINE-AREA-DEL to delete tuples using the display.
;;;                 Fixed mouse documentation strings for various windows.
;;;                 Fixed method (DBMS-RC :handle-unknown-input) to call Relation help functions
;;;                 correctly.
;;;  04.07.87  MRR  Fixed HELP-LINE-AREA. Made references to w:*remove-typeout-standard-message*
;;;                 for typeout windows. Fixed HELP-LINE-AREA-MOD for the case when the current
;;;                 package is not RTMS. (SPR #4197)
;;;  04.09.87  MRR  Added :sensitive-item-types initialization option to 1DBMS-RC* defflavor so
;;;                 that only valid types are made mouse-sensitive. (see SPR #1858)
;;;                 Fixed command for sending display output to file.

;**************************************************************************
;                          1INTERFACE GLOBAL VARIABLES                           **
;1     These global variables are used to hold the latest user-values for the       **
;1     variables in the choose-variables windows associated with various commands.  *        *
;**************************************************************************
(PUTPROP 'display nil 'ucl:items)
(PUTPROP 'display nil 'ucl:commands-wanting-on)
(PUTPROP 'command-menu nil 'ucl:items)
(PUTPROP 'command-menu nil 'ucl:commands-wanting-on)
(PUTPROP 'system-menu nil 'ucl:items)
(PUTPROP 'system-menu nil 'ucl:commands-wanting-on)
;1;*
(SETQ rtms:*default-pkg* *PACKAGE*)
(PKG-GOTO *pkg-string*)
(UCL:MAKE-SYNONYM '*ui-relation* nil)
(UCL:MAKE-SYNONYM '*ui-tuples* nil)
(UCL:MAKE-SYNONYM '*ui-transaction* nil)
(UCL:MAKE-SYNONYM '*ui-function* nil)
(UCL:MAKE-SYNONYM '*ui-attributes* nil)
(UCL:MAKE-SYNONYM '*ui-format* nil)
(UCL:MAKE-SYNONYM '*ui-file* nil)
(UCL:MAKE-SYNONYM '*ui-database* *active-db*)
(UCL:MAKE-SYNONYM '*ui-directory* (STRING-APPEND "SYS:" user-id ";"))  ;mrr 03.31.87
(UCL:MAKE-SYNONYM '*ui-type* 'xld)     ;mrr 03.31.87
(UCL:MAKE-SYNONYM '*ui-attr-desc* nil)
(UCL:MAKE-SYNONYM '*ui-doc* ".....")
(UCL:MAKE-SYNONYM '*ui-key* nil)
(UCL:MAKE-SYNONYM '*ui-imp* *system-relation-base-implementation*)
(UCL:MAKE-SYNONYM '*ui-ss* *system-relation-storage-structure*)
(UCL:MAKE-SYNONYM '*ui-viewdef* nil)
(UCL:MAKE-SYNONYM '*ui-where* T)
(UCL:MAKE-SYNONYM '*ui-values* nil)
(UCL:MAKE-SYNONYM '*ui-join-into* nil)
(UCL:MAKE-SYNONYM '*ui-over* T)
(UCL:MAKE-SYNONYM '*ui-into* nil)
(UCL:MAKE-SYNONYM '*ui-from* nil)
(UCL:MAKE-SYNONYM '*ui-wide* nil)
(UCL:MAKE-SYNONYM '*ui-num* -1)
(UCL:MAKE-SYNONYM '*ui-sort* nil)
(UCL:MAKE-SYNONYM '*ui-object* nil)
(UCL:MAKE-SYNONYM '*ui-rel2* nil)

(defparameter *line-area-documentation*
      '(:documentation ""
:mouse-L-1 "To see the entire line."
:mouse-M-2 "To delete the tuple."
:mouse-R-1 "To modify the tuple.")
  "The wholine documentation string when a line is selected.")

(defparameter *dbms-window-wholine-documentation*
      '(:documentation "Window for database output. Some items are made mouse-sensitive for inspection."
:mouse-R-1 "RTMS Command Menu"
:mouse-R-2 "System Menu")
      "The wholine documentation string when in the RTMS interface output window.")

(defparameter *interaction-wholine-documentation*
      '(:documentation "This window accepts user input. Input can also be provided through the command menu."
:mouse-R-1 "RTMS Command Menu"
:mouse-R-2 "System Menu"))
(defparameter *attribute-wholine-documentation*
      '(:mouse-any "To see this ATTRIBUTE's definition." ))
(defparameter  *dbms-object-wholine-documentation*    ;mrr 04.06.87
      '(:mouse-any "To see this object's definition." ))
(defparameter *relation-wholine-documentation* ;mrr 04.06.87
      '(:documentation ""
:mouse-L-1 "To see the RELATION definition."
:mouse-M-1 "To modify the RELATION features."
:mouse-R-1 "To retrieve this RELATION."))
(defparameter *database-wholine-documentation*
      '(:mouse-any "List the relations in this DATABASE, if it is active."))

;**************************************************************************
;1                      FLAVORS AND METHODS                                         **
;1                                                                                  **
;1     MENU-PANE  ... Used for the main menu that appears in the interface.         **
;1     DBMS-WINDOW .. The output-window in the interface .. text-scrolling, mouse-  **
;1                    sensitive and line-area-scrolling window.                     **
;1     DBMS-WINDOW-WITH-TYPEOUT .. The actual flavor used for output-window. It is  **
;1                                 the above flavor with typeout-mixin added to it  **
;1                                 such that temporary, unimportant and informatory **
;1                                 messages can be printed on the typeout-window and**
;1                                 it disappears when the user hits any character.  **
;1     INTERACTION-PANE .. The flavor used for interaction. It is basically the     **
;1                         universal command loop typein flavor.                    **
;1     DBMS-RC  ..  Flavor for the entire interface screen. Inclusion of the command**
;1                  loop mixin makes the database interface to run under the        **
;1                  UCL package.                                                    **
;**************************************************************************
(DEFFLAVOR MENU-PANE ()
   (w:menu)
  (:default-init-plist :command-menu t
                       :dynamic t))
(DEFFLAVOR DBMS-WINDOW ()
   (W:LINE-AREA-TEXT-SCROLL-MIXIN
    W:FUNCTION-TEXT-SCROLL-WINDOW
    W:MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW
    W:MARGIN-REGION-MIXIN
    W:SCROLL-BAR-MIXIN
    W:ANY-TYI-MIXIN
    W:WINDOW))
(DEFMETHOD (DBMS-WINDOW :line-area-mouse-documentation) ()
   *line-area-documentation*)

(DEFFLAVOR DBMS-WINDOW-WITH-TYPEOUT ()
   (W:TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN DBMS-WINDOW)
  (:DEFAULT-INIT-PLIST :typeout-window '(W:typeout-window
  :Deexposed-typeout-action
  (:expose-for-typeout))))

(defmethod (DBMS-WINDOW-WITH-TYPEOUT :who-line-documentation-string) ()       ;mrr 04.06.87
  (multiple-value-bind
    (ignore m-s-i-type)
      (send *output-window* :mouse-sensitive-item w:mouse-x w:mouse-y)
    (case m-s-i-type
      (attribute  *attribute-wholine-documentation*)
      (relation   *relation-wholine-documentation*)
      (database   *database-wholine-documentation*)
      (dbms-object *dbms-object-wholine-documentation*)
      (t *dbms-window-wholine-documentation*))))

(DEFFLAVOR INTERACTION-PANE () (UCL:COMMAND-AND-LISP-TYPEIN-WINDOW
W:PREEMPTABLE-READ-ANY-TYI-MIXIN))
(defmethod (INTERACTION-PANE  :who-line-documentation-string) ()
   *interaction-wholine-documentation*)       ;mrr 04.06.87

(DEFMETHOD (INTERACTION-PANE :before :SELECT) (&rest ignore)
    (SEND dbms-frame1 :expose))
(DEFMETHOD (INTERACTION-PANE :after :SELECT) (&rest ignore)
;  (PKG-GOTO "RTMS")
 )


(DEFFLAVOR DBMS-RC () (UCL:COMMAND-LOOP-MIXIN W:STREAM-MIXIN
       W:INFERIORS-NOT-IN-SELECT-MENU-MIXIN
       W:BORDERED-CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER)
  (:DEFAULT-INIT-PLIST :menu-panes '((s-m-pane system-menu))
                       :active-command-tables '(dbms-comtab)
       :all-command-tables '(dbms-comtab)
       :typein-handler :handle-typein-input
;1The following change is being made to prevent the first character going *
;1into the interface* 1buffer.*
;       :io-buffer W:kbd-io-buffer
       :minimum-width (SEND W:default-screen :width)
       :minimum-height (SEND W:default-screen :height)
       :basic-help '(help)
       :print-function 'new-print
       :print-results? #'(LAMBDA () T)
       :panes
  `((o-pane dbms-window-with-typeout
    :blinker-p NIL              ;:blink
    :print-function DBMS-PRINTER
    :print-function-arg NIL
    :scroll-bar-side :right
    :scroll-bar-mode :maximum  ;mrr 03.31.87
    :borders1 *nil       ;mrr 04.01.87
    :label ,(LIST :bottom :string "OUTPUT"
  :font fonts:cptfont)
    :font-map ,(LIST fonts:cptfontb)
    :sensitive-item-types ,(list 'relation 'attribute ;mrr 04.09.87
 'database 'dbms-object))
    (i-pane interaction-pane
    :save-bits T
    :blinker-p :OFF            ;:blink
    :label ,(LIST :bottom :string "Rtms Interface"
  :font fonts:medfnt)
    :borders 1
    :font-map ,(LIST fonts:medfnb))
    (s-m-pane menu-pane
    :font-map ,(LIST fonts:hl12b)
    :rows 1.
             :label NIL))
              :constraints  '((main . ((o-pane i-pane s-m-pane)
    ((s-m-pane 1 :lines))
    ((o-pane .8))
    ((i-pane :even))))))
  (:INIT-KEYWORDS :TYPEIN-HANDLER :handle-typein-input))

(DEFMETHOD (DBMS-RC :handle-unknown-input) (&AUX item)
  (case UCL:input-mechanism
    (UCL1:*menu (beep))
    (UCL1:*key-or-button (BEEP))
    (UCL1:*typein (SEND *terminal-io* :send-if-handles :fresh-line)
    (BEEP)
    (FORMAT *STANDARD-OUTPUT* " ** ~a"
    (OR UCL:error-message "Unrecognized input")))
    (OTHERWISE (IF (LISTP ucl:kbd-input)
      (CASE (FIRST ucl:kbd-input)
(:line-area (CASE (FOURTH ucl:kbd-input)
      (#\mouse-l-1 (HELP-LINE-AREA (CADR ucl:kbd-input)))
      (#\mouse-r-1 (HELP-LINE-AREA-MOD (CADR ucl:kbd-input)))
      (#\mouse-m-2 (HELP-LINE-AREA-DEL (CADR ucl:kbd-input)))))
;I think this help can be made lot faster now that we can recognize the type of
;the object right away.
(attribute (HELP-OBJECT (STRING
  (IF (LISTP (SETQ item (CADR ucl:kbd-input)))
      (CADR item)
    item))))
(database (HELP-OBJECT (STRING
  (IF (LISTP (SETQ item (CADR ucl:kbd-input)))
      (CADR item)
    item))))
(dbms-object (HELP-OBJECT (STRING
    (IF (LISTP (SETQ item (CADR ucl:kbd-input)))
(CADR item)
      item))))
(relation (CASE (FOURTH ucl:kbd-input)
    (#\mouse-r-1 (retrieve
   (if (stringp (setq item (CADR ucl:kbd-input)))
       (read-from-string item) ;mrr 04.06.87
       item)))
    (#\mouse-m-1 (HELP-MODIFY
   (if (stringp (setq item (CADR ucl:kbd-input)))
       (read-from-string item) ;mrr 04.06.87
       item)))
    (otherwise (HELP-OBJECT (STRING
  (IF (LISTP (SETQ item (CADR ucl:kbd-input)))
      (CADR item)
    item))))))
(OTHERWISE (BEEP)))))))


;**************************************************************************
;1                          DEFCOMMANDS FOR ALL DATABASE COMMANDS                   **
;1                                                                                  **
;1     Each defcommand definition enables individual database commands and a few    **
;1     help commands to become part of the database command table. If the reader    **
;1     is familiar with UCL, the following DEFCOMMAND definitions will be           **
;1     self-explanatory.                                                            **
;**************************************************************************
;**************************************************************************
;1            DEFCOMMAND FOR ACTIVE DATABASE                                        **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC active-database)()
            `(:description "Returns the name of the active database. (ACTIVE-DATABASE)"
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Returns the name of the active database."
      :keys ((#\SUPER-F #\SUPER-A)))
  (SEND *output-window* :append-item (FORMAT nil "~S" '(ACTIVE-DATABASE)))
  (SEND *output-window* :append-item (FORMAT nil "~S" (ACTIVE-DATABASE))))
;**************************************************************************
;1            DEFCOMMAND FOR ABORT TRANSACTION                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC abort-transaction)()
            `(:description "Terminates the special transaction processing. (ABORT-TRANSACTION)"
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Terminates the special transaction processing."
      :keys ((#\SUPER-T #\SUPER-A)))
  (SEND *output-window* :append-item (FORMAT nil "~S" '(ABORT-TRANSACTION)))
  (SEND *output-window* :append-item (FORMAT nil "~S" (ABORT-TRANSACTION))))
;**************************************************************************
;1            DEFCOMMAND FOR BEGIN TRANSACTION                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC begin-transaction)()
            `(:description "Begins the special transaction processing. (BEGIN-TRANSACTION)"
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Begins the special transaction processing."
      :keys ((#\SUPER-T #\SUPER-B)))
  (SEND *output-window* :append-item (FORMAT nil "~S" '(BEGIN-TRANSACTION)))
  (SEND *output-window* :append-item (FORMAT nil "~S" (BEGIN-TRANSACTION))))
;**************************************************************************
;1            DEFCOMMAND FOR END TRANSACTION                                        **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC end-transaction)()
            `(:description "Executes the database calls postponed due to special transaction processing and terminates the transaction.  (END-TRANSACTION)"
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Executes the database calls postponed due to special transaction processing and terminates the transaction."
      :keys ((#\SUPER-T #\SUPER-E)))
  (SEND *output-window* :append-item (FORMAT nil "~S" '(END-TRANSACTION)))
  (SEND *output-window* :append-item (FORMAT nil "~S" (END-TRANSACTION))))
;**************************************************************************
;1            DEFCOMMAND FOR ENVIRONMENT STATUS*  1                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC environment-status)()
            `(:description "Returns the values of the environment variables. (ENVIRONMENT-STATUS)"
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Returns the values of the environment variables."
      :keys ((#\SUPER-F #\SUPER-E)))
  (SEND *output-window* :append-item (FORMAT nil "~S" '(ENVIRONMENT-STATUS)))
  (ENVIRONMENT-STATUS))
;**************************************************************************
;1            DEFCOMMAND FOR ATTACH RELATION *  1                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC attach-relation) (relation att path tup dir doc key
        imp ss mem &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'attach-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'attach-relation
     (ARGLIST 'attach-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
   "Name of the relation to be attached."
   :sexp))
 ,*ucl-attr-desc*
                                         ,*ucl-pathname*
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doci*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
                                         (:label "Memory:"
  :default nil
  :type (:documentation
   "If the data is stored in the memory, then give the name of the variable that contains the data."
   :sexp))
     :label "Give parameters for ATTACH RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "used to attach a relation."
      :keys (#\SUPER-A))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'ATTACH-RELATION
      relation
      (SETQ keywords
    (LIST 'format tup 'dir dir 'doc doc 'path path
  'key key 'imp imp 'sto ss 'att att 'mem mem)))))
  (ATTACH-RELATION relation keywords))
;**************************************************************************
;1            DEFCOMMAND FOR RENAME ATTRIBUTE*  1                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC rename-attribute) (relation old-new)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'rename-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'rename-attribute
     (ARGLIST 'rename-attribute))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation whose attributes are to be renamed."
   :sexp))
                                         (:label "Attributes and their new names:"
  :default nil
  :type (:documentation
   "Specify a list of the attributes and their new names. For ex. (a1 new-a1 a2 new-a2...)"
   :sexp))
     :label "Give parameters for RENAME ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "used to rename attributes in a relation."
      :keys ((#\SUPER-R #\SUPER-A)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(APPEND (LIST 'RENAME-ATTRIBUTE
      relation) old-new)))
  (EVAL `(RENAME-ATTRIBUTE* ,relation ,@old-new)))
;**************************************************************************
;1            DEFCOMMAND FOR RENAME RELATION *  1                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC rename-relation) (old-new)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'rename-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'rename-relation
     (ARGLIST 'rename-relation))))
      :arguments (:user-supplied (:label "Relations and their new names:"
  :default nil
  :type (:documentation
   "Specify a list of the relations and their new names. For ex. (rel-1 new-rel-1 rel-2 new-rel-2...)"
   :sexp))
     :label "Give parameters for RENAME RELATION:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "used to rename relations in the current database."
      :keys ((#\SUPER-R #\SUPER-R)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(CONS 'RENAME-RELATION
      old-new)))
  (EVAL `(RENAME-RELATION* ,@old-new)))
;**************************************************************************
;1            DEFCOMMAND FOR RENAME DATABASE *  1                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC rename-database) (old-new)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'rename-database)
   (FORMAT NIL "  ~S"
   (CONS
     'rename-database
     (ARGLIST 'rename-database))))
      :arguments (:user-supplied (:label "Databases and their new names:"
  :default nil
  :type (:documentation
   "Specify a list of the databases and their new names. For ex. (db-1 new-db-1 db-2 new-db-2...)"
   :sexp))
     :label "Give parameters for RENAME DATABASE:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "used to rename databases."
      :keys ((#\SUPER-R #\HYPER-D)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(CONS 'RENAME-DATABASE
      old-new)))
  (EVAL `(RENAME-DATABASE* ,@old-new)))
;**************************************************************************
;1            DEFCOMMAND FOR DETACH RELATION *  1                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC detach-relation) (relation path mem disk &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'detach-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'detach-relation
     (ARGLIST 'detach-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
   "Name of the relation to be Detached."
   :sexp))
                                         (:label "Pathname:"
  :default *ui-file*
  :type (:documentation
   "Specify the name of the file where the data is to be stored."
   :SEXP))
                                         (:label "Memory:"
  :default nil
  :type (:documentation
   "If the data is to be in the memory and not save it on the disk, give the name of a variable."
   :sexp))
 (:label "Disk:"
  :default nil
  :type (:documentation
   "Indicate if files corresponding to the relation are to be deleted from the disk."
   :boolean))
     :label "Give parameters for DETACH RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "used to detach a relation."
      :keys (#\SUPER-D))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DETACH-RELATION
      relation
      (SETQ keywords
    (LIST 'path path 'mem mem 'disk disk)))))
  (DETACH-RELATION relation keywords))
;**************************************************************************
;1            DEFCOMMAND FOR INSERT TUPLES                                          **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC insert-tuples) (relation-name list-of-tuples attributes
 pathname &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'insert)
   (FORMAT NIL "  ~S"
   (CONS
     'insert
     (ARGLIST 'insert))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (
    :documentation "Specify the relation into which the tuples are to be inserted."
    :sexp))
 (:label "List of tuples:"
  :default *ui-tuples*
  :type (:documentation "Give a list of tuples to be inserted." :SEXP))
 (:label "Attributes:"
  :default nil
  :type (:documentation "If a list of attributes is provided, then values in the tuples are assumed to be in the same order."
:SEXP))
 (:label "Pathname:"
  :default *ui-file*
  :type (:documentation "If a list of tuples is not provided, then specify the file which contains the data."
:SEXP))
 :label "Give parameters for INSERTING TUPLES:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to insert a list of tuples in a given relation."
      :keys (#\SUPER-I))
  (SEND *output-window* :append-item (FORMAT nil "~S"
        (LIST 'INSERT relation-name (SETQ keywords
  (LIST 'tuples list-of-tuples
'attr attributes
'path pathname)))))
  (INSERT relation-name keywords))

;**************************************************************************
;1                DEFCOMMAND FOR MAPON ALLTUPLES                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC maptuple) (relation dbfunction)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'maptuple)
   (FORMAT NIL "  ~S"
   (CONS
     'maptuple
     (ARGLIST
       'maptuple))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
       "Give the relation to be mapped." :sexp))
 (:label "Function Definition"
  :default *ui-function*
  :type (:documentation
    "Specify a function definition."
    :sexp))
  :label "Map a function on all tuples using MAPCAR:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Maps a given function on all the tuples in a relation using MAPCAR."
      :keys ((#\SUPER-F #\SUPER-M)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MAPTUPLE dbfunction relation)))
  (MAPTUPLE (EVAL dbfunction) relation))
;**************************************************************************
;1                DEFCOMMAND FOR MAPON ALLTUPLES                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC mapt) (relation dbfunction)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'mapt)
   (FORMAT NIL "  ~S"
   (CONS
     'mapt
     (ARGLIST
       'mapt))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
       "Give the relation to be mapped." :sexp))
 (:label "Function Definition"
  :default *ui-function*
  :type (:documentation
    "Specify a function definition."
    :sexp))
  :label "Map a function on all tuples using MAPC:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Maps a given function on all the tuples in a relation using MAPC."
      :keys (#\SUPER-HYPER-F))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MAPT dbfunction relation)))
  (MAPT (EVAL dbfunction) relation))
;**************************************************************************
;1                    DEFCOMMAND FOR PRINT RELATION                                 **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC print-relation) (relation
  into dir doc key imp sto
  qprint to-file sort
  format wide number print
  tuples qsort stream unique
  &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'print-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'print-relation
     (ARGLIST
       'print-relation))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 :label "Give parameters for PRINT RELATION ==>")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to print tuples in a relation."
      :keys ((#\SUPER-F #\SUPER-P)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RETRIEVE
      relation
      (SETQ keywords
    (LIST 'dir dir
  'doc doc
  'into into
  'qprint (NOT qprint) 'output-to-file to-file
  'sort sort 'format format
  'wide wide 'num number 'key key
  'print print 'tuples tuples
  'quick-sort qsort 'stream stream
  'unique unique 'imp imp 'sto sto)))))
  (RETRIEVE relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR RESTORE DATABASE                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC load-database) (database directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'load-database)
   (FORMAT NIL "  ~S"
   (CONS
     'load-database
     (ARGLIST
       'load-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default *ui-database*
  :type (
    :documentation "Name of the database to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is stored."
    :sexp))
 :label "Give parameters for LOAD DATABASE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load database from a given directory."
      :keys ((#\SUPER-L #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-DATABASE database (LIST 'dir directory))))
  (LOAD-DATABASE database (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR RESTORE ENVIRONMENT                               **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC load-environment) (environment directory)
`(:description ,(STRING-APPEND (DOCUMENTATION 'load-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'load-environment
     (ARGLIST
       'load-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default *ui-database*
  :type (
    :documentation "Name of the environment to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is stored."
    :sexp))
 :label "Give parameters for LOAD ENVIRONMENT:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load environment from a given directory."
      :keys ((#\SUPER-L #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-ENVIRONMENT environment (LIST 'dir directory))))
  (LOAD-ENVIRONMENT environment (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR RESTORE RELATION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC load-relation) (relation directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'load-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'load-relation
     (ARGLIST
       'load-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (
    :documentation "Name of the relation to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is saved."
           :sexp))
  :label "Give parameters for LOAD RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load a relation from a given directory."
      :keys ((#\SUPER-L #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-RELATION relation (LIST 'dir directory))))
  (LOAD-RELATION relation (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE DATABASE                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-database) (database directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-database)
   (FORMAT NIL "  ~S"
   (CONS
     'save-database
     (ARGLIST
       'save-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default *ui-database*
  :type (:documentation
     "Name of the database to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
    "Name of the directory to write to."
    :sexp))
  :label "Give parameters for SAVE DATABASE:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a database on a given directory."
      :keys ((#\SUPER-S #\HYPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-DATABASE database (LIST 'dir directory))))
  (SAVE-DATABASE database (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE ENVIRONMENT                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-environment) (environment directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'save-environment
     (ARGLIST
       'save-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default nil
  :type (:documentation
     "Name of the environment to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
    "Name of the directory to write to."
    :sexp))
  :label "Give parameters for SAVE environment:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save an environment on a given directory."
      :keys ((#\SUPER-S #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-ENVIRONMENT environment (LIST 'dir directory))))
  (SAVE-ENVIRONMENT environment (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE RELATION                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-relation) (relation directory type save
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'save-relation
     (ARGLIST
       'save-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (
    :documentation "Name of the relation to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory to write to."
    :sexp))
 (:label "Type of SAVE:"
  :default *ui-type*
  :type (:documentation "Save type. It can be either XLD or COMMAND." ;mrr 03.31.87
:sexp))
 (:label "Must Save:"
  :default nil
  :type (:documentation "Save the relation even if the relation has not been modified." :BOOLEAN))
 :label "Give parameters for SAVE RELATION:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a relation on a given directory."
      :keys ((#\SUPER-S #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-RELATION relation
      (SETQ keywords (LIST 'type type 'dir directory
   'save save)))))
  (SAVE-RELATION relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE TRANSACTION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-transaction) (transaction directory pathname
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'save-transaction
     (ARGLIST
       'save-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (
    :documentation "Name of the transaction to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory to write to."
    :sexp))
 (:label "Pathname:"
  :default *ui-file*
  :type (:documentation
  "The name of the file into which the transaction forms will be stored. It defaults to <transaction>.lisp"
  :SEXP))
 :label "Give parameters for SAVE TRANSACTION:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a transaction on a given directory."
      :keys ((#\SUPER-S #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-TRANSACTION transaction
      (SETQ keywords (LIST 'path pathname 'dir directory)))))
  (SAVE-TRANSACTION transaction keywords))

;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE IMPLEMENTATION                             **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-implementation) (implementation doc
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-implementation)
   (FORMAT NIL "  ~S"
   (CONS
     'define-implementation
     (ARGLIST 'define-implementation))))
      :arguments (:user-supplied (:label "Implementation Name:"
  :default nil
  :type (:documentation
    "Name of the implementation. Implementation-dependent routines are expected to be defined by the user."
    :sexp))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the implementation."
    :string))
  :label "Give parameters for DEFINE IMPLEMENTATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define an implementation."
      :keys ((#\SUPER-D #\SUPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-IMPLEMENTATION implementation
      (SETQ keywords (LIST 'doc doc
   )))))
  (DEFINE-IMPLEMENTATION implementation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE INDEX                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-index) (relation-name index-name key-attributes storage-structure priority
doc &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-index)
   (FORMAT NIL "  ~S"
   (CONS
     'define-index
     (ARGLIST 'define-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
    "Name of the 2relation upon which the index will be defined."*
    :sexp))
 (:label "2Index Name*:"
  :default nil
  :type (:documentation
    "2Name of the index to be defined*."
    :string))
 (:label "2Key Attributes*:"
  :default nil
  :type (:documentation
    "2List of attribute names which form the key for this index*."
    :sexp))
 (:label "2Storage Structure*:"
  :default "2AVL"*
  :type (:documentation
    "2The storage structure used to define the index*."
    :string))
 (:label "2Priority*:"
  :default 10
  :type (:documentation
    "2A numerical value which indicates the priority given to this index. 1 is the highest priority."*
    :number))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the 2index*."
    :string))
  :label "Give parameters for DEFINE 2INDEX*:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a2 secondary index on a relation*."
      :keys ((#\SUPER-D #\HYPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-INDEX relation-name
      (SETQ keywords (LIST 'name index-name 'key key-attributes 'sto storage-structure
   'priority priority 'doc doc
   )))))
  (DEFINE-INDEX relation-name keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY INDEX                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-index) (relation-name index-name new-index-name
key-attributes storage-structure priority
doc &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-index)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-index
     (ARGLIST 'modify-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
    "Name of the 2relation upon which the index to be modified is defined."*
    :sexp))
 (:label "2Index Name*:"
  :default nil
  :type (:documentation
    "2Name of the index to be modified*."
    :string))
 (:label "2New Index Name*:"
  :default nil
  :type (:documentation
    "2New name of the index*."
    :string))
 (:label "2Key Attributes*:"
  :default nil
  :type (:documentation
    "2List of attribute names which form the key for this index*."
    :sexp))
 (:label "2Storage Structure*:"
  :default nil
  :type (:documentation
    "2The storage structure used to define the index*."
    :string))
 (:label "2Priority*:"
  :default 10
  :type (:documentation
    "2A numerical value which indicates the priority given to this index. 1 is the highest priority."*
    :number))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the 2index*."
    :string))
  :label "Give parameters for DEFINE 2INDEX*:")
      :menus ((command-menu :COLUMN "2Manipulation*"))
      :documentation "Used to define a2 secondary index on a relation*."
      :keys ((#\SUPER-M #\HYPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-INDEX relation-name index-name
      (SETQ keywords (LIST 'new-name new-index-name 'key key-attributes 'sto storage-structure
   'priority priority 'doc doc
   )))))
  (MODIFY-INDEX relation-name index-name keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE STORAGE-STRUCTURE                          **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-storage-structure) (storage-structure doc
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-storage-structure)
   (FORMAT NIL "  ~S"
   (CONS
     'define-storage-structure
     (ARGLIST 'define-storage-structure))))
      :arguments (:user-supplied (:label "Storage structure name:"
  :default nil
  :type (:documentation
    "Name of the storage structure. Storage-structure-dependent routines are expected to be defined by the user."
    :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "Documentation for the storage structure."
    :string))
  :label "Give parameters for DEFINE STORAGE STRUCTURE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a storagestructure."
      :keys ((#\SUPER-D #\SUPER-S)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-STORAGE-STRUCTURE storage-structure
      (SETQ keywords (LIST 'doc doc
   )))))
  (DEFINE-STORAGE-STRUCTURE storage-structure keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE DOMAIN                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-domain) (domain def doc format
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'define-domain
     (ARGLIST 'define-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
    "Name of the domain. Domain predicate is expected to be defined prior to this."
    :sexp))
 (:label "Default value:"
  :default nil
  :type (:documentation
   "Default value for this domain."
   :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "Documentation for the domain."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The default width to be used for this domain."
    :sexp))
  :label "Give parameters for DEFINE DOMAIN:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a domain."
      :keys (#\SUPER-HYPER-D))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-DOMAIN domain
      (SETQ keywords (LIST 'default def
   'doc doc
   'format format)))))
  (DEFINE-DOMAIN domain keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY DOMAIN                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-domain) (domain def doc format
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-domain
     (ARGLIST 'modify-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
    "Name of the domain to be modified."
    :sexp))
 (:label "Default value:"
  :default nil
  :type (:documentation
   "New default value for this domain."
   :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "New documentation for the domain."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The new default width to be used for this domain."
    :sexp))
  :label "Give parameters for MODIFY DOMAIN:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify a domain."
      :keys ((#\SUPER-M #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-DOMAIN domain
      (SETQ keywords (LIST 'default def
   'doc doc
   'format format)))))
  (MODIFY-DOMAIN domain keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-transaction) (transaction forms dir path
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'define-transaction
     (ARGLIST 'define-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (:documentation
    "Name of the transaction."
    :sexp))
 (:label "Database calls:"
  :default nil
  :type (:documentation
   "A list of database calls."
   :sexp))
 ,*ucl-dir*
 (:label "Pathname :"
  :default *ui-file*
  :type (:documentation
    "The default file in which it will be saved."
    :SEXP))
  :label "Give parameters for DEFINE TRANSACTION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a transaction."
      :keys ((#\SUPER-D #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-TRANSACTION transaction forms
      (SETQ keywords (LIST 'dir dir
   'path path)))))
  (DEFINE-TRANSACTION transaction forms keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-transaction) (transaction dir path
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-transaction
     (ARGLIST 'modify-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (:documentation
    "Name of the transaction to be modified."
    :sexp))
 (:label "Directory:"
  :default *ui-directory*
  :type (:documentation
    "Default directory in which it can be found, if not in memory."
    :SEXP))
 (:label "Pathname :"
  :default *ui-file*
  :type (:documentation
    "The default file in which it can be found, if not in memory."
    :SEXP))
  :label "Give parameters for MODIFY TRANSACTION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify a transaction."
      :keys ((#\SUPER-M #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-TRANSACTION transaction
      (SETQ keywords (LIST 'dir dir
   'path path)))))
  (MODIFY-TRANSACTION transaction keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE DATABASE                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-database) (database directory doc env
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-database)
   (FORMAT NIL "  ~S"
   (CONS
     'define-database
     (ARGLIST 'define-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
    "Name of the database."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
   "Name of the save directory for this database."
   :sexp))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the database."
    :string))
 (:label "Environment:"
  :default nil
  :type (:documentation
    "Name of the environment to be used to replace the default settings."
    :sexp))
  :label "Give parameters for DEFINE DATABASE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a database in a given directory."
      :keys ((#\SUPER-D #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFDB database
      (SETQ keywords (LIST 'dir directory
   'doc doc
   'environment env)))))
  (DEFDB database keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY DATABASE                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-database) (database new-database directory doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-database)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-database
     (ARGLIST 'modify-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
    "Name of the database."
    :sexp))
 (:label "New Database Name:"
  :default nil
  :type (:documentation
    "If the database is to be renamed specify the new name."
    :sexp))
 (:label "Directory Name:"
  :default NIL
  :type (:documentation
   "To change the save directory for this database specify a new directory."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the database."
    :string))
  :label "Give parameters for MODIFY DATABASE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a database."
      :keys ((#\SUPER-M #\HYPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-DATABASE database
      (SETQ keywords (LIST 'database-name new-database
   'dir directory
   'doc doc
   )))))
  (MODIFY-DATABASE database keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY ATTRIBUTE                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-attribute) (relation attr new-attr def doc format
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-attribute
     (ARGLIST 'modify-attribute))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
    "Name of the relation."
    :sexp))
 (:label "Attribute Name:"
  :default nil
  :type (:documentation
    "Name of the attribute."
    :sexp))
 (:label "New Attribute Name:"
  :default nil
  :type (:documentation
    "If the attribute is to be renamed specify the new name."
    :sexp))
 (:label "Default Value:"
  :default NIL
  :type (:documentation
   "To change the default value of this attribute specify a new value."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the attribute."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The new default width to be used for this attribute."
    :sexp))
  :label "Give parameters for MODIFY ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a attribute."
      :keys ((#\SUPER-M #\SUPER-A)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-ATTRIBUTE relation attr
      (SETQ keywords (LIST 'attribute-name new-attr
   'def def
   'doc doc 'format format
   )))))
  (MODIFY-ATTRIBUTE relation attr keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY VIEW                                       **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-view) (view def doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-view)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-view
     (ARGLIST 'modify-view))))
      :arguments (:user-supplied (:label "View Name:"
  :default NIL
  :type (:documentation
    "Name of the view."
    :sexp))
 (:label "View Definition:"
  :default nil
  :type (:documentation
    "New definition of the view."
    :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the view."
    :string))
  :label "Give parameters for MODIFY VIEW:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a view."
      :keys ((#\SUPER-M #\SUPER-V)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-VIEW view
      (SETQ keywords (LIST
   'view-def def
   'view-doc doc
   )))))
  (MODIFY-VIEW view keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY RELATION                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-relation) (rel new-rel add-att del-att ren-att
   imp sto format key dir doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-relation
     (ARGLIST 'modify-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
    "Name of the Relation."
    :sexp))
 (:label "New Relation Name:"
  :default nil
  :type (:documentation
    "If the relation is to be renamed specify the new name."
    :sexp))
 (:label "Add attributes:"
  :default NIL
  :type (:documentation
   "Specify a list of attribute-descriptor pairs for attributes to be added to this relation."
   :sexp))
 (:label "Delete attributes:"
  :default NIL
  :type (:documentation
   "Specify a list of attributes in this relation which are to be deleted."
   :sexp))
 (:label "Rename attributes:"
  :default NIL
  :type (:documentation
   "To rename some of the attributes provide a list of the form (<old-attribute new-attribute>)."
   :sexp))
 (:label "Implementation Type:"
  :default NIL
  :type (:documentation
   "To change the implementation type of this relation specify a new value."
   :sexp))
 (:label "Storage structure:"
  :default NIL
  :type (:documentation
   "To change the storage structure of this relation specify a new value."
   :sexp))
 (:label "Format:"
  :default NIL
  :type (:documentation
   "To change the format for this relation specify a new format as a list of values."
   :sexp))
 (:label "Key:"
  :default NIL
  :type (:documentation
   "To change the key for this relation specify a new key as a list of attributes."
   :sexp))
 (:label "Directory Name:"
  :default NIL
  :type (:documentation
   "To change the save directory for this relation specify a new directory."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the relation."
    :string))
  :label "Give parameters for MODIFY RELATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a relation."
      :keys ((#\SUPER-M #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-RELATION rel
      (SETQ keywords (LIST 'relation new-rel
   'add-attributes add-att
   'delete-attributes del-att
   'rename-attributes ren-att
   'imp imp
   'sto sto
   'format format
   'key key
   'doc doc
   'dir dir
   )))))
  (MODIFY-RELATION rel keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE ENVIRONMENT                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-environment) (environment save dir err par-check
      rel-imp rel-sto status sys-imp
      sys-sto val-check warn
      &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'define-environment
     (ARGLIST 'define-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default nil
  :type (:documentation
    "Name of the environment."
    :sexp))
 (:label "Auto save:"
  :default nil
  :type (:documentation
   "Automatically saves all the modified relations after each function." :boolean))
 ,*ucl-dir*
 (:label "Errors:"
  :default T
  :type (:documentation
    "Controls the printing of the error messages."
    :boolean))
                                         (:label "Parameter Checking:"
  :default T
  :type (:documentation
    "Controls the checking of the parameters."
    :boolean))
                                         (:label "Relation Implementation:"
  :default *ui-imp*
  :type (:documentation
                                            "Default implementation of the user relations."
    :sexp))
                                         (:label "Relation storage structure:"
  :default *ui-ss*
  :type (:documentation
    "Default storage structure for the user relations."
    :sexp))
                                         (:label "Status:"
  :default T
  :type (:documentation
    "Controls the printing of the status messages."
    :boolean))
                                         (:label "System Implementation:"
  :default nil
  :type (:documentation
    "Default implementation of the system relations. Can not change this when a database is active."
    :sexp))
                                         (:label "System storage structure:"
  :default nil
  :type (:documentation
    "Default storage structure for the system relations. Can not change this when a database is active."
    :sexp))
                                         (:label "Validity Checking:"
  :default T
  :type (:documentation
    "Controls the checking of the values during insertion and modification for validity."
    :boolean))
                                         (:label "Warnings:"
  :default T
  :type (:documentation
    "Controls the printing of the warning messages."
    :boolean))
  :label "Give parameters for DEFINE ENVIRONMENT:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define an environment in a given directory."
      :keys ((#\SUPER-D #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFENV environment
      (SETQ keywords (IF *active-db*
 (LIST 'auto-save save 'para par-check
   'dir dir 'rel-imp rel-imp 'rel-sto
                                           rel-sto 'errors err 'status status
                                           'validity val-check 'warnings warn)
       (LIST 'auto-save save 'para par-check
   'dir dir 'rel-imp rel-imp 'rel-sto
                                           rel-sto 'errors err 'status status
   'sys-imp sys-imp 'sys-sto sys-sto
                                           'validity val-check 'warnings warn))))))
  (DEFENV environment keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE RELATION                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-relation) (relation attr-des tup
   dir doc key imp ss &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'define-relation
     (ARGLIST 'define-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
   "Name of the relation to be defined."
   :sexp))
 ,*ucl-attr-desc*
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doci*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
     :label "Give parameters for DEFINE RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "used to define a relation."
      :keys ((#\SUPER-D #\SUPER-R)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFREL
      relation attr-des
      (SETQ keywords
    (LIST 'tuple-format tup 'dir dir 'doc doc
  'key key 'imp imp 'sto ss)))))
  (DEFREL relation attr-des keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE VIEW                                       **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-view) (viewname view-definition doc)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-view)
   (FORMAT NIL "  ~S"
   (CONS
     'define-view
     (ARGLIST 'define-view))))
      :arguments (:user-supplied (:label "View Name:"
  :default nil
  :type (:documentation
     "Specify a name for the view."
  :sexp))
 (:label "View Definition:"
  :default *ui-viewdef*
  :type (:documentation
     "Specify a definition for the view."
  :sexp))
 (:label "View Documentation:"
  :default nil
  :type (:documentation
     "Specify documentation for the view."
  :sexp))
 :label "Give parameters for DEFINE VIEW:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a view."
      :keys ((#\SUPER-D #\SUPER-V)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFVIEW viewname view-definition doc)))
  (DEFVIEW viewname view-definition doc))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE ATTRIBUTE                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-attribute) (relation-name attr-des key
  &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'define-attribute
     (ARGLIST 'define-attribute))))
      :arguments (:user-supplied (:label "Relation name: "
  :default *ui-relation*
  :type (:documentation
     "The name of the relation to which new attributes are to be added." :SEXP))
 ,*ucl-attr-desc*
 (:label "Key: "
  :default nil
  :type (:documentation
     "New key for the relation if it is to be different from the previous value. Specify a list of attributes."
     :SEXP))
 :label "Give parameters for DEFINE ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to add attributes to relations."
      :keys ((#\SUPER-D #\SUPER-A)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFINE-ATTRIBUTE relation-name attr-des
      (SETQ keywords (LIST 'key key)))))
  (DEFINE-ATTRIBUTE relation-name attr-des keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-tuples) (relation where-clause attributes values
  &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-tuples
     (ARGLIST 'modify-tuples))))
      :arguments (:user-supplied (:label "Relation: "
  :default *ui-relation*
  :type (:documentation
     "Specify the relation whose tuples are to be modified."
  :sexp))
 ,*ucl-where*
 (:label "Attributes: "
  :default *ui-attributes*
  :type (:documentation
     "Specify a list of attributes in the above relation to be modified." :sexp))
 (:label "Values: "
  :default *ui-values*
  :type (:documentation
     "Specify a corresponding list of values to modify the above attributes." :sexp))
 :label "Give parameters for MODIFY TUPLES ==>")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify tuples in a relation."
      :keys ((#\SUPER-M #\HYPER-M)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'MODIFY relation (SETQ keywords (LIST 'where where-clause
    'attr attributes
    'values values)))))
  (MODIFY relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DELETE TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC delete-tuples) (relation where-clause)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'delete-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'delete-tuples
     (ARGLIST 'delete-tuples))))
      :arguments (:user-supplied (:label "Relation: "
  :default *ui-relation*
  :type (:documentation
     "Specify a relation whose tuples are to be deleted."
  :sexp))
 (:label "Where clause: "
  :default nil
  :type (:documentation
     "Deletes the tuples which satisfy this condition."
  :sexp))
 :label "Give parameters for DELETE TUPLES ==>")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to delete tuples in a relation."
      :keys (#\HYPER-D))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DELETE-TUPLES relation (LIST 'where where-clause))))
  (DELETE-TUPLES  relation (LIST 'where where-clause)))
;**************************************************************************
;1                DEFCOMMAND  FOR RETRIEVE TUPLES                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC retrieve-tuples) (relation attributes where-clause
   into dir doc key imp sto
   qprint to-file sort
   format wide number print
   tuples qsort stream unique index-name
   &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'retrieve)
   (FORMAT NIL "  ~S"
   (CONS
     'retrieve
     (ARGLIST 'retrieve))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-attributes*
 ,*ucl-where*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 ,*ucl-index-name*
 :label "Give parameters for RETRIEVE TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Retrieve tuples in a relation."
      :keys (#\HYPER-R))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RETRIEVE
      relation
      (SETQ keywords
    (LIST 'project
  (IF (EQUAL attributes T)
      NIL
    attributes)
  'where where-clause 'into into
  'dir dir 'doc doc 'key key 'imp imp 'sto sto
  'qprint (NOT qprint) 'output-to-file to-file
  'sort sort 'format format
  'wide wide 'num number
  'print print 'tuples tuples
  'quick-sort qsort 'stream stream
  'unique unique 'index-name index-name)))))
  (RETRIEVE relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SELECT TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC select) (relation where-clause
   into dir doc key imp sto
   qprint to-file sort
   format wide number print
   tuples qsort stream unique index-name
   &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'select-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'select-tuples
     (ARGLIST 'select-tuples))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-where*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 ,*ucl-index-name*
 :label "Give parameters for SELECT TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Select tuples in a relation."
      :keys ((#\SUPER-R #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SELECT-TUPLES
      relation
      (SETQ keywords
    (LIST
  'where where-clause 'into into
  'dir dir 'doc doc 'key key 'imp imp 'sto sto
  'qprint (NOT qprint) 'output-to-file to-file
  'sort sort 'format format
  'wide wide 'num number
  'print print 'tuples tuples
  'quick-sort qsort 'stream stream
  'unique unique 'index-name index-name)))))
  (RETRIEVE relation (APPEND (LIST 'project nil) keywords)))
;**************************************************************************
;1                DEFCOMMAND  FOR PROJECT TUPLES                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC Project) (relation attributes
    into dir doc key imp sto
    qprint to-file sort
    format wide number print tuples
    qsort stream unique
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'project)
   (FORMAT NIL "  ~S"
   (CONS
     'project
     (ARGLIST
       'project))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-attributes*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 :label "Give parameters for PROJECT TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Project tuples in a relation."
      :keys ((#\SUPER-R #\SUPER-P)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'PROJECT
      relation
      (SETQ keywords
    (LIST 'project (IF (EQUAL attributes T)
 nil
       attributes)
    'into into 'dir dir 'doc doc 'key key 'imp imp 'sto sto
    'qprint (NOT qprint) 'output-to-file to-file
    'sort sort 'format format
    'wide wide 'num number 'print print 'tuples tuples
    'quick-sort qsort 'stream stream 'unique unique)))))
  (RETRIEVE relation (APPEND (LIST 'where t) keywords)))
;**************************************************************************
;1                DEFCOMMAND  FOR COMMIT TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC commit-transaction) (trans dir path &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'commit-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'commit-transaction
     (ARGLIST
       'commit-transaction))))
      :arguments (:user-supplied (:label "Name of the transaction :"
  :default *ui-transaction*
  :type (:documentation
     "The name of an existing transaction." :SEXP))
 (:label "Name of the directory:"
  :default *ui-directory*
  :type (:documentation
     "Name of the directory which contains the transaction file, if the transaction is not in the memory." :SEXP))
 (:label "Pathname:"
  :default *ui-file*
  :type (:documentation
 "If the transaction is not in memory, provide the pathname for the transaction file. It defaults to <transaction>.lisp." :SEXP))
 :label "Give parameters for COMMIT TRANSACTION")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Commit a transaction - execute all the database calls in it."
      :keys ((#\SUPER-T #\SUPER-C)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'COMMIT-TRANSACTION trans (SETQ keywords
      (LIST 'dir dir
    'path path)))))
  (COMMIT-TRANSACTION trans keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR JOIN                                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC join) (into from project where
     tuples format dir doc key imp sto
             print unique &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'join)
   (FORMAT NIL "  ~S"
   (CONS
     'join
     (ARGLIST
       'join))))
      :arguments (:user-supplied (:label "Output relation :"
  :default *ui-join-into*
  :type (:documentation
     "If not provided, the result of JOIN is stored in a temporary relation unless only the resultant tuples are requested." :SEXP))
 (:LABEL "FROM :"
  :DEFAULT *ui-from*
  :TYPE (:DOCUMENTATION
  "Specify a list of two relations to be joined." :SEXP))
 (:label "Project :"
  :default NIL
  :type (:documentation
     "This gives the attributes in the output relation. Example: (rel1.* a3 (rel2.a1 a4)) ==> All the attributes in rel1, attribute A3 of rel2 and atribute A1 of rel2 renamed as A4." :SEXP))
 (:label "Where :"
  :default *ui-over*
  :type (:documentation
  "The join clause using the theta-operators. It is a where clause consisting of attributes from the relations being joined." :SEXP))
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
 :label "Give parameters for JOIN")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to join relations."
      :keys (#\SUPER-J))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'JOIN 'from from
      (SETQ keywords (LIST 'project project
   'into into
   'tuples tuples
   'format format
   'dir dir
   'doc doc
   'key key
   'imp imp
   'sto sto
   'print print
   'where where 'unique unique)))))
  (JOIN-INTERNAL (APPEND (LIST 'from from) keywords))
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY* 1DATABASE                                 **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-database) (database disk &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-database)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-database
     (ARGLIST
       'destroy-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
     "Name of the database to be destroyed." :SEXP))
 (:label "Delete from the DISK:"
  :default NIL
  :type (:documentation
  "IF YES all the files pertaining to this database are deleted but NOT EXPUNGED." :BOOLEAN))
 :label "Give parameters for DESTROY DATABASE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy databases"
      :keys ((#\SUPER-K #\SUPER-D)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-DATABASE database
      (SETQ keywords (LIST 'disk disk)))))
  (DESTROY-DATABASE database keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY DOMAIN                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-domain) (domain)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-domain
     (ARGLIST
       'destroy-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
     "Name of the domain to be destroyed." :SEXP))
 :label "Give parameters for DESTROY DOMAIN:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy domains."
      :keys (#\SUPER-HYPER-K))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-DOMAIN domain)))
  (DESTROY-DOMAIN domain))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY IMPLEMENTATION                            **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-implementation) (implementation)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-implementation)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-implementation
     (ARGLIST
       'destroy-implementation))))
      :arguments (:user-supplied (:label "Implementation Name:"
  :default nil
  :type (:documentation
     "Name of the implementation to be destroyed." :SEXP))
 :label "Give parameters for DESTROY IMPLEMENTATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy implementations."
      :keys ((#\SUPER-K #\SUPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-IMPLEMENTATION implementation)))
  (DESTROY-IMPLEMENTATION implementation))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY INDEX                            **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC DESTROY-INDEX) (relation-name index-name)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-index)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-index
     (ARGLIST
       'destroy-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
     "Name of the 2relation on which the index to be destroyed is defined*." :SEXP))
 (:label "2Index* Name:"
  :default nil
  :type (:documentation
     "Name of the 2index* to be destroyed." :SEXP))
2     *:label "Give parameters for DESTROY 2INDEX:*")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy 2indices*."
      :keys ((#\SUPER-K #\HYPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-INDEX relation-name index-name)))
  (DESTROY-INDEX relation-name index-name))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY STORAGE STRUCTURE                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-storage-structure) (storage-structure)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-storage-structure)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-storage-structure
     (ARGLIST
       'destroy-storage-structure))))
      :arguments (:user-supplied (:label "Storage structure name:"
  :default nil
  :type (:documentation
     "Name of the storage structure to be destroyed." :SEXP))
 :label "Give parameters for DESTROY STORAGE STRUCTURE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy storage structures."
      :keys ((#\SUPER-K #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-STORAGE-STRUCTURE storage-structure)))
  (DESTROY-STORAGE-STRUCTURE storage-structure))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY VIEW                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-view) (view)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-view)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-view
     (ARGLIST
       'destroy-view))))
      :arguments (:user-supplied (:label "View name:"
  :default nil
  :type (:documentation
     "Name of the view to be destroyed."
     :SEXP))
 :label "Give parameters for DESTROY VIEW:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy views."
      :keys ((#\SUPER-K #\SUPER-V)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-VIEW view)))
  (DESTROY-VIEW view))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROYREL                                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-relation) (relation disk &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-relation
     (ARGLIST
       'destroy-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
     "Name of the relation to be destroyed." :SEXP))
 (:label "Delete from the DISK:"
  :default NIL
  :type (:documentation
  "IF YES the file corresponding to this relation is deleted but NOT EXPUNGED." :BOOLEAN))
 :label "Give parameters for DESTROY RELATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy relations"
      :keys ((#\SUPER-K #\SUPER-R)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-RELATION
      relation (SETQ keywords (LIST 'disk disk)))))
  (DESTROY-RELATION relation keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY* 1ATTRIBUTE* 1                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-attribute) (relation attr key &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-attribute
     (ARGLIST
       'destroy-attribute))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
     "Name of the relation from which attributes are to be destroyed." :SEXP))
 (:label "Attributes:"
  :default nil
  :type (:documentation
     "List of attributes to destroy." :SEXP))
 (:label "Key:"
  :default NIL
  :type (:documentation
  "New key for the relation if it is to be different from the previous value or if any of the key attributes are destroyed." :SEXP))
 :label "Give parameters for DESTROY ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy attributes from relations"
      :keys ((#\SUPER-K #\SUPER-A)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-ATTRIBUTE relation (SETQ keywords (LIST 'attr attr
 'key key)))))
  (DESTROY-ATTRIBUTE relation keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR SET UNION                                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC union) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-union)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-union
     (ARGLIST
       'relation-union))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation union operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-union of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form union of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-U)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-UNION
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-UNION keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SET DIFFERENCE                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC difference) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-difference)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-difference
     (ARGLIST
       'relation-difference))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation difference operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-difference of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form difference of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-D)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-DIFFERENCE
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-DIFFERENCE keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SET INTERSECTION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC intersection) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-intersection)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-intersection
     (ARGLIST
       'relation-intersection))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation intersection operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-intersection of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form intersection of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-INTERSECTION
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-INTERSECTION keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR AVERAGE                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC average) (relation attribute unique where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'average)
   (FORMAT NIL "  ~S"
   (CONS
     'average
     (ARGLIST
       'average))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be averaged." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for average:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the average of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-A)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'AVERAGE relation attribute
      (SETQ keywords (LIST 'unique unique
   'where where 'by by 'tuples tuples)))))
  (AVERAGE relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SUM                                               **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC sum) (relation attribute unique where by tuples
&AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'sum)
   (FORMAT NIL "  ~S"
   (CONS
     'sum
     (ARGLIST
       'sum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be summed." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for sum:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the sum of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SUM relation attribute
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (SUM relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SIZE                         *   1                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC size) (relation unique where by tuples &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'size)
   (FORMAT NIL "  ~S"
   (CONS
     'size
     (ARGLIST
       'size))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation whose size is required." :SEXP))
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for size:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the size of the relation."
      :keys (#\SUPER-HYPER-S))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SIZE relation
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (SIZE relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR COUNT-RTMS                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC count) (relation attribute unique where by tuples
       &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'count-rtms)
   (FORMAT NIL "  ~S"
   (CONS
     'count-rtms
     (ARGLIST
       'count-rtms))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be used to find the number of tuples." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for count:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the count of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-C)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'COUNT-RTMS relation attribute
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (COUNT-RTMS relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MAXIMUM                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC maximum) (relation attribute where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'maximum)
   (FORMAT NIL "  ~S"
   (CONS
     'maximum
     (ARGLIST
       'maximum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be maximumd." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for maximum:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the maximum of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-M)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'MAXIMUM relation attribute
      (SETQ keywords (LIST 'where where 'by by 'tuples tuples)))))
  (MAXIMUM relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MINIMUM                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC minimum) (relation attribute where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'minimum)
   (FORMAT NIL "  ~S"
   (CONS
     'minimum
     (ARGLIST
       'minimum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be minimumd." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for minimum:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the minimum of the attribute values in a relation."
      :keys (#\SUPER-HYPER-M))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'MINIMUM relation attribute
      (SETQ keywords (LIST 'where where 'by by 'tuples tuples)))))
  (MINIMUM relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR HELP DBMS OBJECT                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC inspect-dbms-object) (object)
            `(:description "Information on any database object"
      :arguments (:user-supplied (:label "Database Object:"
  :default *ui-object*
  :type (:documentation
   "Specify a database object (COMMAND / RELATION / ATTRIBUTE)."
   :sexp))
  :LABEL "Help on the database object ->")
      :menus help
      :documentation "Used to inspect any database object."
      :keys (#\CONTROL-HELP))
  (SEND *output-window* :append-item
(FORMAT nil "(INSPECT-DBMS-OBJECT '~S)" object))
  (HELP-OBJECT object))
;**************************************************************************
;1                DEFCOMMAND  FOR REFRESH OUTPUT WINDOW                             **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC clear-output-window) ()
    `(:description "Clear the entire output window"
      :menus display
      :keys (#\CLEAR-SCREEN))
  (SEND *output-window* :set-items nil)
  (FUNCALL *OUTPUT-WINDOW* :SCROLL-TO
   (- 2 (W:SHEET-NUMBER-OF-INSIDE-LINES *OUTPUT-WINDOW*))
   :RELATIVE))
;**************************************************************************
;1                DEFCOMMAND  FOR SCROLL DOWN                                       **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC scroll-forward) ()
   `(:description "scrolling forward in the output-window"
     :menus display
     :keys (#\CONTROL-V))
  (FUNCALL *OUTPUT-WINDOW* :SCROLL-TO
   (- (W:SHEET-NUMBER-OF-INSIDE-LINES *OUTPUT-WINDOW*) 2)
   :RELATIVE))
;**************************************************************************
;1                DEFCOMMAND  FOR SCROLL UP                                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC scroll-backward) ()
   `(:description "scrolling backward in the output-window"
     :menus display
     :keys (#\META-V))
  (FUNCALL *OUTPUT-WINDOW* :SCROLL-TO
   (- 2 (W:SHEET-NUMBER-OF-INSIDE-LINES *OUTPUT-WINDOW*))
   :RELATIVE))
;**************************************************************************
;1                DEFCOMMAND  FOR SCROLL TO THE TOP                                 **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC scroll-to-top) ()
   `(:description "scrolling to the top in the output-window"
     :menus display
     :keys (#\META-<))
  (SEND *OUTPUT-WINDOW* :put-item-in-window
(SEND *OUTPUT-WINDOW* :item-of-number 0)))
;**************************************************************************
;1                DEFCOMMAND  FOR SCROLL TO THE BOTTOM                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC scroll-to-bottom) ()
   `(:description "scrolling to the bottom in the output-window"
     :menus display
     :keys (#\META->))
  (SEND *OUTPUT-WINDOW* :put-last-item-in-window))
;**************************************************************************
;1                DEFCOMMAND  FOR SCROLL TO A RELATION                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC scroll-to-a-relation) (relation &aux index)
     `(:description "Scroll to a particular relation"
       :arguments (:user-supplied (:label "Relation Name:"
   :default *ui-relation*
   :type (:documentation
   "Name of the relation to scroll to:"
   :sexp))
   :label "Scroll to the relation ==>")
       :menus display
       :keys (#\CONTROL-R))
  (IF (AND (SETQ index (GETP relation :index))
   (< index (LENGTH (SEND *output-window* :items))))
      (SEND *output-window* :put-item-in-window
    (SEND *output-window* :item-of-number index))
    (FORMAT *typeout-window* "~%The relation ~S is not in the output-window"
    relation)))
;**************************************************************************
;1                DEFCOMMAND  FOR SEND OUTPUT TO A FILE                             **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC send-output-to-file) (file &AUX pathname)
     `(:description "Send the contents of the output window to a file."
       :arguments (:user-supplied (:label "File name:"
   :default *ui-file*
   :type (:documentation
   "Name of the file to send the output to:" :sexp))
   :label "Send the output window contents to:")
       :menus display
       :keys (#\HYPER-F))
  (UNWIND-PROTECT
      (SETQ pathname (CAR (ERRSET
  (OPEN (SETQ pathname file) :characters t
                     :direction :output       ;mrr 04.09.87
                     :if-does-not-exist :create) nil)))
    (IF (null pathname)
(FORMAT *typeout-window* "~S is a bad file." file)
      (MAPCAR (FUNCTION (LAMBDA (line &AUX item)
       (COND ((OR (STRINGP line)
  (NUMBERP line)
  (SYMBOLP line))
      (PRINC line pathname))
     ((LISTP line)
      (DOLIST (element line)
(COND ((OR (STRINGP element)
   (NUMBERP element)
   (SYMBOLP element))
       (PRINC element pathname))
      ((NULL (LISTP element)) nil)
      ((NULL (EQUAL (CAR element) :item1))
       (PRINC (CAR element) pathname))
      (T (SETQ item (CADR element))
 (PRINC
   (IF (LISTP item)
       (CAR item)
     item)
   pathname)
 )))))
       (TERPRI pathname)))
      (LISTARRAY (SEND *output-window* :items)))))
  (IF pathname
      (CLOSE pathname)))
;**************************************************************************
;1                DEFCOMMAND  FOR INTRODUCTION                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC introduction) ()
    `(:description "Introduction to this interface."
      :menus help
      :keys (#\META-HELP))
  (HELP))

;**************************************************************************
;1                DEFCOMMAND  FOR SUB-MENU DBMS HELP                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC help) ()
    `(:description "Introduction to the interface. Help on any database object (COMMAND / RELATION / ATTRIBUTE)."
      :documentation "Introduction to the interface. Help on any database object (COMMAND/RELATION/ATTRIBUTE)."
      :menus system-menu)
  (LET ((command (SEND SELF :submenu-choose *help-submenu*)))
    (IF command (SEND command :execute SELF))))
;**************************************************************************
;1                DEFCOMMAND  FOR SUB-MENU DBMS COMMANDS                            **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC command-menu) ()
    `(:description "Select a database command from a menu. A choose-variable-values window will be presented to get the arguments for that command."
      :documentation "Select a database command from a menu. A choose-variable-values window will be presented to get the arguments for that command."
      :menus system-menu
      :keys (#\mouse-r-1))
  (LET ((command (SEND SELF :submenu-choose *command-submenu*)))
    (IF command (SEND command :execute SELF))))
;**************************************************************************
;1                DEFCOMMAND  FOR SUB-MENU DISPLAY COMMANDS                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC display) ()
    `(:description "Select an item from a menu to scroll in the output window."
      :documentation "Select an item from a menu to scroll in the output window."
      :menus system-menu)
  (LET ((command (SEND SELF :submenu-choose *display-submenu*)))
    (IF command (SEND command :execute SELF))))
;**************************************************************************
;1                DEFCOMMAND  FOR EXIT                                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC kill) ()
     `(:description "To exit the interface by killing the process."
      :documentation "To exit the interface by killing the process."
      :menus system-menu
      :keys (#\SUPER-END))
  (SEND dbms-frame1 :kill)
  (SETQ dbms-frame1 nil))
;**************************************************************************
;1                DEFCOMMAND  FOR QUIT                                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC exit) ()
     `(:description "To exit the interface by burying it."
      :documentation "To exit the interface by burying it."
      :menus system-menu
      :keys (#\END))
  (SEND dbms-frame1 :bury))
;**************************************************************************
;1              Build the command table                                             **
;**************************************************************************
(SETQ dbms-comtab (MAKE-INSTANCE 'UCL:COMMAND-TABLE
    :name "Database command table"
    :documentation "database help"))
(UCL:BUILD-COMMAND-TABLE 'dbms-comtab 'dbms-rc
 '(help command-menu display kill exit
   delete-tuples destroy-attribute
                 destroy-database destroy-relation
 destroy-domain destroy-implementation destroy-index
 destroy-storage-structure destroy-view
 modify-database modify-transaction
 modify-domain modify-relation
 modify-attribute modify-index modify-view modify-tuples
   union intersection difference join
         retrieve-tuples select project
 commit-transaction average sum count size maximum
 minimum
   define-view define-database define-relation
         define-attribute define-environment
 define-implementation define-storage-structure
 define-domain define-transaction define-index
 attach-relation detach-relation insert-tuples
         load-database load-relation load-environment
   maptuple print-relation save-database save-relation
         save-environment save-transaction
         active-database environment-status
 rename-attribute rename-relation
 rename-database mapt abort-transaction
 begin-transaction  end-transaction
   inspect-dbms-object introduction
   scroll-forward clear-output-window
   scroll-to-top scroll-to-bottom
   scroll-backward scroll-to-a-relation send-output-to-file))
;**************************************************************************
;1            Init method to define the submenus COMMAND-MENU HELP *    1    * 1       **
;1            DISPLAY as part of the system menu. *        1                         **
;**************************************************************************

(DEFMETHOD (dbms-rc :after :init) (&rest ignore)
  (declare (special command-menu))
  (SETQ
   *help-submenu*  (MAKE-INSTANCE 'W:menu
  :pop-up t
  :dynamic t
  :superior W:mouse-sheet
                                  :item-list-pointer 'help)
   *command-submenu*  (MAKE-INSTANCE 'W:menu
     :pop-up t
     :dynamic t
     :multicolumn t
                                     :superior W:mouse-sheet
                                     :column-spec-list command-menu)
   *display-submenu* (MAKE-INSTANCE 'W:menu
    :pop-up t
    :dynamic t
                                    :superior W:mouse-sheet
                                    :item-list-pointer 'display))
  (SETQ *menupane* (SEND SELF :get-pane 's-m-pane))
  (SEND *menupane* :set-item-list-pointer 'system-menu)
  (SEND *menupane* :update-item-list)
  (SETQ *interaction* (FUNCALL self :get-pane 'i-pane)
      *output-window* (FUNCALL self :get-pane 'o-pane))
  (SEND self :set-selection-substitute rtms:*interaction*)
  )
;**************************************************************************
;1                                        Build the submenus.                       **
;**************************************************************************
(UCL:BUILD-MENU 'system-menu 'dbms-rc
:item-list-order '(help kill command-menu exit display))
(UCL:BUILD-MENU 'help 'dbms-rc :item-list-order
'(introduction inspect-dbms-object))
(UCL:BUILD-MENU 'display 'dbms-rc :item-list-order
'(scroll-to-top scroll-backward clear-output-window
  send-output-to-file
  scroll-to-a-relation ucl:display-command-tables
  ucl:edit-command-tables scroll-forward scroll-to-bottom))
(PUTPROP 'command-menu '(dbms-comtab) 'ucl:items)
(UCL:BUILD-MENU 'command-menu 'dbms-rc
:item-list-order
'(define-database define-relation define-view define-attribute
  define-index define-environment define-domain define-transaction
  define-implementation define-storage-structure
  attach-relation detach-relation
  load-database load-relation load-environment
  insert-tuples delete-tuples modify-tuples
  modify-database modify-relation modify-attribute
  modify-index modify-domain modify-transaction modify-view
                  destroy-database destroy-relation destroy-attribute
  destroy-domain destroy-implementation destroy-index
  destroy-storage-structure destroy-view
  retrieve-tuples join union intersection difference
  select project commit-transaction
  average sum size count maximum minimum
  print-relation save-database save-relation
  save-environment save-transaction maptuple mapt
  active-database environment-status
  rename-attribute rename-relation
  rename-database abort-transaction
  begin-transaction end-transaction)
:column-list-order
'(("Definition" :FONT FONTS:hl12bi)
  ("Manipulation" :FONT FONTS:hl12bi)
  ("Operators" :FONT FONTS:hl12bi)
  ("Other Features" :FONT FONTS:hl12bi)))
;**************************************************************************
;1         Define the variable to hold the instance of the application flavor.      **
;**************************************************************************
(SETQ dbms-frame1 nil)
;**************************************************************************
;1         Method used to get input from submenus.                                  **
;**************************************************************************
(DEFMETHOD (dbms-rc :submenu-choose) (submenu)
  (LET ((sup (SEND submenu :superior)))
    (UNWIND-PROTECT
      (PROGN
(SEND (CAR (SEND *interaction* :blinker-list)) :set-visibility NIL)
(SEND submenu :set-superior W:mouse-sheet)
(SEND submenu :choose))
      (SEND submenu :set-superior sup)
      (SEND (CAR (SEND *interaction* :blinker-list)) :set-visibility :blink)
      )))
;**************************************************************************
;1                              Some initializations                                **
;**************************************************************************
(DEFMETHOD (dbms-rc :before :command-loop) ()
    (SETQ *typeout-window* (FUNCALL *output-window* :typeout-window))
    (SEND *interaction* :clear-screen)
    (SEND *output-window* :clear-screen)
    (SEND *typeout-window* :set-io-buffer
  (SEND *interaction* :io-buffer)))
;**************************************************************************
;1    Method to be executed before each time it enters the command-loop. Used       **
;1    to refresh the output window if its typeout window is exposed.                **
;**************************************************************************

(DEFMETHOD (dbms-rc :before :fetch-and-execute) (&rest ignore)
  (DECLARE (SPECIAL ch))
  (IF (SEND *typeout-window* :active-p)
      (PROGN
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window*
w:*remove-typeout-standard-message*)   ;mrr 04.07.87
(SETQ ch (FUNCALL dbms-frame1 :any-tyi))
(SEND *output-window* :flush-typeout))))
;(SEND dbms-frame1 :set-basic-help '(help))
;(SEND dbms-frame1 :set-print-function 'NEW-PRINT)
(DEFUN NEW-PRINT (x &AUX ch)
  (IF (SEND *typeout-window* :active-p)
      (PROGN
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window*
w:*remove-typeout-standard-message*)   ;mrr 04.07.87
(SETQ ch (FUNCALL dbms-frame1 :any-tyi))
(SEND *output-window* :flush-typeout)))
  (SEND *output-window* :append-item (FORMAT nil "~S" x)))
(DEFMETHOD (dbms-rc :before :execute-command) (&rest ignore)
;  (setq ucl:inhibit-results-print? T)
  (IF (EQ ucl:input-mechanism 'ucl:typein)
      (SEND *output-window* :append-item (FORMAT nil "~S" -))))
(DEFMETHOD (dbms-rc :after :execute-command) (&rest ignore &AUX ch)
  (IF (SEND *typeout-window* :active-p)
      (PROGN
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window* "~%")
(FORMAT *typeout-window*
w:*remove-typeout-standard-message*)   ;mrr
(SETQ ch (FUNCALL dbms-frame1 :any-tyi))
(SEND *output-window* :flush-typeout)))
  '(MAPC #'(LAMBDA (val)
    (IF val
(PROGN
  (SEND *output-window* :append-item (FORMAT NIL "~S" val))
  (SEND *output-window* :put-last-item-in-window))))
//)
  )

;**************************************************************************
;1      Sets the I/O streams the appropriate panes in the interface.                **
;**************************************************************************
(DEFMETHOD (dbms-rc :designate-io-streams) ()
  (DECLARE (special *standard-output* error-output debug-io
    *terminal-io*))
  (SETQ *terminal-io* *interaction*
*standard-output* *interaction*
error-output *typeout-window*
debug-io *typeout-window*))
;**************************************************************************
;1      The function to be called from lisp-listener to get use the interface.      **
;**************************************************************************
(COMPILE-FLAVOR-METHODS dbms-rc)
(DEFUN Interface (&rest ignore)
  (IF (W:FIND-WINDOW-OF-FLAVOR 'RTMS:dbms-rc)
      dbms-frame1
    (SETQ dbms-frame1 (W:MAKE-WINDOW 'RTMS:dbms-rc)))
  (SEND dbms-frame1 :expose)
  (SEND *interaction* :select))
;**************************************************************************
;             1Add the database interface to the system keys and system menu      **
;**************************************************************************
(DEFUN CREATE-KEYS ()
  (W:ADD-SYSTEM-KEY #\D 'RTMS:dbms-rc
     "Rtms Interface"
     '(RTMS:interface))
  (W:ADD-TO-SYSTEM-MENU-COLUMN :PROGRAMS
    "RTMS" '(RTMS:interface) "Rtms interface"))
(CREATE-KEYS)
;**************************************************************************
;1              Function used to scroll down in the output window.                  **
;**************************************************************************
(DEFUN scroll-to-bottom ()
  (SEND *output-window* :append-item " ")
  (SEND *output-window* :put-last-item-in-window)
  (FUNCALL *OUTPUT-WINDOW* :SCROLL-TO
   (- (W:SHEET-NUMBER-OF-INSIDE-LINES *OUTPUT-WINDOW*) 2)
   :RELATIVE))
;**************************************************************************
;1           Function used to print items in the output window.                     **
;**************************************************************************
(DEFUN DBMS-PRINTER (line arg stream item-no)
  (LET (item)  ;item was declared special locally in Rel 2 -mrr
  arg
  item-no    1  *
  (COND ((STRINGP line) (PRINC line stream))
((NUMBERP line) (PRINC line stream))
((SYMBOLP line) (PRINC line stream))
((LISTP line)
   (DOLIST (element line)
     (COND ((STRINGP element) (PRINC element stream))
   ((SYMBOLP element) (PRINC element stream))
   ((NUMBERP element) (PRINC element stream))
   ((NULL (LISTP element)) nil)
   ((NULL (EQUAL (CAR element) :item1))
    (IF (STRINGP (CAR element))
(PRINC (CAR element) stream)
(PRIN1 (CAR element) stream)))
   (T (SETQ item (CADR element))
      (FUNCALL stream :item1 item (CADDR element)
       #'(LAMBDA (item stream)
   (PRINC
     (IF (LISTP item)
 (CAR item)
       item)
     stream))))))))))
;**************************************************************************
;               1Function*s1 used to provide help on line-area scrolling.            **
;**************************************************************************
(DEFUN HELP-LINE-AREA (line &AUX item)
  (COND ((OR (STRINGP line)
     (NUMBERP line)
     (SYMBOLP line))
 (PRINC line *TYPEOUT-WINDOW*))
((LISTP line)
   (DOLIST (element line)
     (COND ((OR (STRINGP element)
(NUMBERP element)
(SYMBOLP element))
    (PRINC element *TYPEOUT-WINDOW*))
   ((NULL (LISTP element)) nil)
   ((NULL (EQUAL (CAR element) :item1))
    (IF (STRINGP (CAR element))
(PRINC (CADR element) *typeout-window*)
(PRIN1 (CADR element) *typeout-window*)))
   (T (SETQ item (CADR element))
      (PRINC
(IF (LISTP item)
    (CADR item)
  item)
*TYPEOUT-WINDOW*)
      )))
   (FORMAT *typeout-window* "~%")
   (FORMAT *typeout-window* "~%")
   (FORMAT *typeout-window*
w:*remove-typeout-standard-message*)   ;mrr 04.07.87
   (SEND dbms-frame1 :any-tyi)
   (SEND *output-window* :flush-typeout))))
(DEFUN HELP-LINE-AREA-DEL (line &AUX items item-number mod-relation
             mod-attributes num)
  (SETQ item-number (SEND *output-window* :number-of-item line))
  (MAPC (FUNCTION (LAMBDA (rel &AUX numbers)
  (IF (AND
(SETQ numbers (GETP (READ-FROM-STRING
     (STRING-APPEND *pkg-name*
    (CAR rel)))
   'items))
(>= item-number (CAR numbers))
(<= item-number (CADR numbers))
)
      (PROGN
(SETQ num numbers)
(SETQ mod-relation (READ-FROM-STRING
     (STRING-APPEND *pkg-name* (CAR rel))) ;mrr 04.06.87
      mod-attributes (CADR rel))
))))
(QTRIEVE 'system-relation
 *system-relation-attributes*
 '(relation-name attributes)
 *system-relation-key*
 t))
  (IF mod-relation
      (PROGN
(IF (W:MOUSE-CONFIRM "Delete the indicated tuple?")
    (PROGN
      (DOLIST (element line)
(IF (LISTP element)
    (SETQ items (APPEND items (CDR element)))))
      (IF (>
    (CADR
      (MULTIPLE-VALUE-LIST
      (DELETE-TUPLES mod-relation
     'where (CONS 'AND
  (MAPCAR (FUNCTION (LAMBDA (attr val)
     (LIST 'EQUAL (READ-FROM-STRING (STRING attr))
   `(QUOTE
      ,(READ-FROM-STRING val)))))
   mod-attributes
   items)))))
    0)
  (PROGN
    (SEND *output-window* :delete-item item-number)
    (PUTP mod-relation
     (LIST (CAR num) (- (CADR num) 1))
     'items)))
      )))))
(DEFUN HELP-LINE-AREA-MOD (line
   &AUX items item-number attribute-vars mod-tuple
   mod-relation mod-attributes blanks tuple-format tuple)
  (BLOCK nil
  (SETQ item-number (SEND *output-window* :number-of-item line))
  (MAPC (FUNCTION (LAMBDA (rel &AUX numbers)
  (IF (AND
(SETQ numbers (GETP (READ-FROM-STRING
     (STRING-APPEND *pkg-name*
    (CAR rel)))
   'items))
(>= item-number (CAR numbers))
(<= item-number (CADR numbers))
)
      (SETQ mod-relation (READ-FROM-STRING     ;mrr 04.06.87
     (STRING-APPEND *pkg-name* (CAR rel)))
    mod-attributes (CADR rel)))))
(QTRIEVE 'system-relation
 *system-relation-attributes*
 '(relation-name attributes)
 *system-relation-key*
 t))
  (IF mod-relation
      (PROGN
(DOLIST (element line)
  (IF (LISTP element)
      (PROGN
(SETQ tuple-format (APPEND tuple-format
   (LIST (LENGTH (CAR element)))))
(SETQ items (APPEND items (CDR element))))))
(SETQ blanks
      (MAKE-ARRAY
(+ 1 (LENGTH mod-attributes)
   (APPLY (FUNCTION +) tuple-format)) :type 'art-string
:initial-value 32))
(SETQ attribute-vars
      (MAPCAR (FUNCTION (LAMBDA (attr)
       (READ-FROM-STRING (STRING-APPEND "MOD" attr))))
      mod-attributes))
(MAPC (FUNCTION (LAMBDA (attr val)
                  (SET attr (READ-FROM-STRING val))))
      attribute-vars
      items)
(SETQ *line-area-values-modifiedp* nil)
(IF (CATCH 'abort
      (W:CHOOSE-VARIABLE-VALUES
(MAPCAR (FUNCTION (LAMBDA (var attr)
    (LIST var (STRING attr))))
attribute-vars
mod-attributes)
:label (FORMAT nil "Modify the relation: ~S" mod-relation)
:function 'line-area-domain-check
:margin-choices '("Do It" ("Abort" (THROW 'abort T)))))       ;mrr 04.06.87
    (setq  *line-area-values-modifiedp* NIL))
(IF *line-area-values-modifiedp*
    (PROGN
      (SETQ tuple (MAPCAR (FUNCTION (LAMBDA (x)
      `(QUOTE ,(SYMBOL-VALUE x))))
  attribute-vars))
      (SETQ mod-tuple
    (CAR (PRINT-TUPLE (LIST
(MAPCAR (FUNCTION (LAMBDA (x)
    (eval `,x)))
tuple))
      tuple-format nil T blanks nil)))
      (IF (>
    (CADR
      (MULTIPLE-VALUE-LIST
      (MODIFY mod-relation 'attributes mod-attributes
'values tuple
'where (CONS 'AND
       (MAPCAR (FUNCTION (LAMBDA (attr val)
   (LIST 'EQUAL (READ-FROM-STRING
  (STRING-APPEND *pkg-name*    ;mrr
 (STRING attr)))
 `(QUOTE
    ,(READ-FROM-STRING
       val)))))
       mod-attributes
       items)))))
    0)
  (PROGN
    (SEND *output-window* :delete-item item-number)
    (SEND *output-window* :insert-item item-number mod-tuple)))))))))
(DEFUN line-area-domain-check (&rest ignore)
  (BLOCK nil
;Later on, we will have to take the arguments window, variable, old-value, and
;new-value (see page 195. bottom) inorder to do the domain check for this attribute
;But we probably should not do the domain checking here because it will be done
;anyway in the modify routine.
(SETQ *line-area-values-modifiedp* T)
(RETURN nil)))


(DEFUN HELP-MODIFY (relation &rest ignore
    &AUX qtrieve)
  (DECLARE (SPECIAL new-rel relation
    old-att  new-add new-del new-ren old-add old-del old-ren
    old-imp  new-imp
    old-sto  new-sto
    old-key  new-key
    old-dir  new-dir
    old-doc  new-doc
    old-tup  new-tup))
  (BLOCK nil
    (SETQ qtrieve (CADR (GET-RELATION
relation
'(attributes save-directory doc tuple-format
  implementation-type storage-structure key)
T)))
    (COND ((NULL (CADR qtrieve))
   (IF *provide-error-messages*
       (FORMAT *STANDARD-OUTPUT*
     "~%ERROR - Relation ~s does not exist in the database ~s"
     relation *active-db*))
   (RETURN NIL)))
  (SETQ old-att (FIRST qtrieve)
old-dir (SECOND qtrieve)
old-doc (THIRD qtrieve)
old-tup (FOURTH qtrieve)
old-imp (FIFTH qtrieve)
old-sto (SIXTH qtrieve)
old-key (SEVENTH qtrieve) old-add NIL old-del NIL old-ren NIL)
  (SETQ new-dir old-dir new-doc old-doc new-rel relation
new-tup old-tup new-imp old-imp new-sto old-sto new-key old-key
new-add old-add new-del old-del new-ren old-ren)
  (IF (NOT (CATCH 'abort
     (W:CHOOSE-VARIABLE-VALUES
       `(
 (new-rel "Relation Name"
  :documentation "To change the relation name." :SEXP)
 ,(FORMAT nil "     Attributes: ~S" old-att)
 (new-add "Add attributes"
  :documentation "To add attributes specify attribute descriptor pair." :SEXP)
 (new-del "Delete attributes"
  :documentation "To delete attributes, specify a list of the attributes." :SEXP)
 (new-ren "Rename attributes"
  :documentation "To rename attributes, specify a list of the type <(old new)>." :SEXP)
 " "
 (new-imp "Implementation-type"
  :documentation "To change the type of implementation."
  :SEXP)
 (new-sto "Storage Structure"
  :documentation
  "To change the type of storage structure." :SEXP)
 (new-key "Key"
  :documentation "To change the key attributes."
  :SEXP)
 (new-doc "Documentation"
  :documentation "To change the relation documentation."
  :SEXP)
 (new-dir "Save Directory"
  :documentation
  "To change the directory in which this relation can be saved."
  :SEXP)
 (new-tup "Tuple format"
  :documentation
  "To change the format in printing the relation."
  :SEXP))
       :label (FORMAT nil "Change the features of ~S" relation)
       :margin-choices '("Do It" ("Abort" (THROW 'abort T))))))       ;mrr 04.06.87
      (PROGN
(SETQ qtrieve NIL)
(MAPC #'(LAMBDA (old new key)
  (IF (NOT (EVAL `(*EQUALP ,old ,new)))
      (SETQ qtrieve (APPEND qtrieve (LIST key (eval `,new))))))
      '(relation old-add old-del old-ren
 old-dir old-doc old-tup old-imp old-sto old-key)
      '(new-rel new-add new-del new-ren
new-dir new-doc new-tup new-imp new-sto new-key)
      '(rel add-attr delete-attr rename-attr dir doc format imp sto key))
(IF qtrieve
    (MODIFY-RELATION relation qtrieve)))))
 )

me of the database to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is stored."
    :sexp))
 :label "Give parameters for LOAD DATABASE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load database from a given directory."
      :keys ((#\SUPER-L #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-DATABASE database (LIST 'dir directory))))
  (LOAD-DATABASE database (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR RESTORE ENVIRONMENT                               **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC load-environment) (environment directory)
`(:description ,(STRING-APPEND (DOCUMENTATION 'load-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'load-environment
     (ARGLIST
       'load-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default *ui-database*
  :type (
    :documentation "Name of the environment to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is stored."
    :sexp))
 :label "Give parameters for LOAD ENVIRONMENT:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load environment from a given directory."
      :keys ((#\SUPER-L #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-ENVIRONMENT environment (LIST 'dir directory))))
  (LOAD-ENVIRONMENT environment (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR RESTORE RELATION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC load-relation) (relation directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'load-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'load-relation
     (ARGLIST
       'load-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (
    :documentation "Name of the relation to be loaded."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory in which it is saved."
           :sexp))
  :label "Give parameters for LOAD RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to load a relation from a given directory."
      :keys ((#\SUPER-L #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'LOAD-RELATION relation (LIST 'dir directory))))
  (LOAD-RELATION relation (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE DATABASE                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-database) (database directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-database)
   (FORMAT NIL "  ~S"
   (CONS
     'save-database
     (ARGLIST
       'save-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default *ui-database*
  :type (:documentation
     "Name of the database to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
    "Name of the directory to write to."
    :sexp))
  :label "Give parameters for SAVE DATABASE:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a database on a given directory."
      :keys ((#\SUPER-S #\HYPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-DATABASE database (LIST 'dir directory))))
  (SAVE-DATABASE database (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE ENVIRONMENT                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-environment) (environment directory)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'save-environment
     (ARGLIST
       'save-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default nil
  :type (:documentation
     "Name of the environment to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
    "Name of the directory to write to."
    :sexp))
  :label "Give parameters for SAVE environment:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save an environment on a given directory."
      :keys ((#\SUPER-S #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-ENVIRONMENT environment (LIST 'dir directory))))
  (SAVE-ENVIRONMENT environment (LIST 'dir directory)))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE RELATION                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-relation) (relation directory type save
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'save-relation
     (ARGLIST
       'save-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (
    :documentation "Name of the relation to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory to write to."
    :sexp))
 (:label "Type of SAVE:"
  :default *ui-type*
  :type (:documentation "Save type. It can be either XLD or COMMAND." ;mrr 03.31.87
:sexp))
 (:label "Must Save:"
  :default nil
  :type (:documentation "Save the relation even if the relation has not been modified." :BOOLEAN))
 :label "Give parameters for SAVE RELATION:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a relation on a given directory."
      :keys ((#\SUPER-S #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-RELATION relation
      (SETQ keywords (LIST 'type type 'dir directory
   'save save)))))
  (SAVE-RELATION relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SAVE TRANSACTION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC save-transaction) (transaction directory pathname
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'save-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'save-transaction
     (ARGLIST
       'save-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (
    :documentation "Name of the transaction to be saved."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (
    :documentation "Name of the directory to write to."
    :sexp))
 (:label "Pathname:"
  :default *ui-file*
  :type (:documentation
  "The name of the file into which the transaction forms will be stored. It defaults to <transaction>.lisp"
  :SEXP))
 :label "Give parameters for SAVE TRANSACTION:")
      :menus ((command-menu :COLUMN "Other Features"))
      :documentation "Used to save a transaction on a given directory."
      :keys ((#\SUPER-S #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'SAVE-TRANSACTION transaction
      (SETQ keywords (LIST 'path pathname 'dir directory)))))
  (SAVE-TRANSACTION transaction keywords))

;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE IMPLEMENTATION                             **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-implementation) (implementation doc
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-implementation)
   (FORMAT NIL "  ~S"
   (CONS
     'define-implementation
     (ARGLIST 'define-implementation))))
      :arguments (:user-supplied (:label "Implementation Name:"
  :default nil
  :type (:documentation
    "Name of the implementation. Implementation-dependent routines are expected to be defined by the user."
    :sexp))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the implementation."
    :string))
  :label "Give parameters for DEFINE IMPLEMENTATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define an implementation."
      :keys ((#\SUPER-D #\SUPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-IMPLEMENTATION implementation
      (SETQ keywords (LIST 'doc doc
   )))))
  (DEFINE-IMPLEMENTATION implementation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE INDEX                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-index) (relation-name index-name key-attributes storage-structure priority
doc &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-index)
   (FORMAT NIL "  ~S"
   (CONS
     'define-index
     (ARGLIST 'define-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
    "Name of the 2relation upon which the index will be defined."*
    :sexp))
 (:label "2Index Name*:"
  :default nil
  :type (:documentation
    "2Name of the index to be defined*."
    :string))
 (:label "2Key Attributes*:"
  :default nil
  :type (:documentation
    "2List of attribute names which form the key for this index*."
    :sexp))
 (:label "2Storage Structure*:"
  :default "2AVL"*
  :type (:documentation
    "2The storage structure used to define the index*."
    :string))
 (:label "2Priority*:"
  :default 10
  :type (:documentation
    "2A numerical value which indicates the priority given to this index. 1 is the highest priority."*
    :number))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the 2index*."
    :string))
  :label "Give parameters for DEFINE 2INDEX*:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a2 secondary index on a relation*."
      :keys ((#\SUPER-D #\HYPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-INDEX relation-name
      (SETQ keywords (LIST 'name index-name 'key key-attributes 'sto storage-structure
   'priority priority 'doc doc
   )))))
  (DEFINE-INDEX relation-name keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY INDEX                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-index) (relation-name index-name new-index-name
key-attributes storage-structure priority
doc &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-index)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-index
     (ARGLIST 'modify-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
    "Name of the 2relation upon which the index to be modified is defined."*
    :sexp))
 (:label "2Index Name*:"
  :default nil
  :type (:documentation
    "2Name of the index to be modified*."
    :string))
 (:label "2New Index Name*:"
  :default nil
  :type (:documentation
    "2New name of the index*."
    :string))
 (:label "2Key Attributes*:"
  :default nil
  :type (:documentation
    "2List of attribute names which form the key for this index*."
    :sexp))
 (:label "2Storage Structure*:"
  :default nil
  :type (:documentation
    "2The storage structure used to define the index*."
    :string))
 (:label "2Priority*:"
  :default 10
  :type (:documentation
    "2A numerical value which indicates the priority given to this index. 1 is the highest priority."*
    :number))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the 2index*."
    :string))
  :label "Give parameters for DEFINE 2INDEX*:")
      :menus ((command-menu :COLUMN "2Manipulation*"))
      :documentation "Used to define a2 secondary index on a relation*."
      :keys ((#\SUPER-M #\HYPER-I)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-INDEX relation-name index-name
      (SETQ keywords (LIST 'new-name new-index-name 'key key-attributes 'sto storage-structure
   'priority priority 'doc doc
   )))))
  (MODIFY-INDEX relation-name index-name keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE STORAGE-STRUCTURE                          **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-storage-structure) (storage-structure doc
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-storage-structure)
   (FORMAT NIL "  ~S"
   (CONS
     'define-storage-structure
     (ARGLIST 'define-storage-structure))))
      :arguments (:user-supplied (:label "Storage structure name:"
  :default nil
  :type (:documentation
    "Name of the storage structure. Storage-structure-dependent routines are expected to be defined by the user."
    :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "Documentation for the storage structure."
    :string))
  :label "Give parameters for DEFINE STORAGE STRUCTURE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a storagestructure."
      :keys ((#\SUPER-D #\SUPER-S)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-STORAGE-STRUCTURE storage-structure
      (SETQ keywords (LIST 'doc doc
   )))))
  (DEFINE-STORAGE-STRUCTURE storage-structure keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE DOMAIN                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-domain) (domain def doc format
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'define-domain
     (ARGLIST 'define-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
    "Name of the domain. Domain predicate is expected to be defined prior to this."
    :sexp))
 (:label "Default value:"
  :default nil
  :type (:documentation
   "Default value for this domain."
   :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "Documentation for the domain."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The default width to be used for this domain."
    :sexp))
  :label "Give parameters for DEFINE DOMAIN:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a domain."
      :keys (#\SUPER-HYPER-D))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-DOMAIN domain
      (SETQ keywords (LIST 'default def
   'doc doc
   'format format)))))
  (DEFINE-DOMAIN domain keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY DOMAIN                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-domain) (domain def doc format
&AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-domain
     (ARGLIST 'modify-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
    "Name of the domain to be modified."
    :sexp))
 (:label "Default value:"
  :default nil
  :type (:documentation
   "New default value for this domain."
   :sexp))
 (:label "Documentation:"
  :default nil
  :type (:documentation
    "New documentation for the domain."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The new default width to be used for this domain."
    :sexp))
  :label "Give parameters for MODIFY DOMAIN:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify a domain."
      :keys ((#\SUPER-M #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-DOMAIN domain
      (SETQ keywords (LIST 'default def
   'doc doc
   'format format)))))
  (MODIFY-DOMAIN domain keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-transaction) (transaction forms dir path
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'define-transaction
     (ARGLIST 'define-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (:documentation
    "Name of the transaction."
    :sexp))
 (:label "Database calls:"
  :default nil
  :type (:documentation
   "A list of database calls."
   :sexp))
 ,*ucl-dir*
 (:label "Pathname :"
  :default *ui-file*
  :type (:documentation
    "The default file in which it will be saved."
    :SEXP))
  :label "Give parameters for DEFINE TRANSACTION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a transaction."
      :keys ((#\SUPER-D #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFINE-TRANSACTION transaction forms
      (SETQ keywords (LIST 'dir dir
   'path path)))))
  (DEFINE-TRANSACTION transaction forms keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-transaction) (transaction dir path
  &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-transaction
     (ARGLIST 'modify-transaction))))
      :arguments (:user-supplied (:label "Transaction Name:"
  :default *ui-transaction*
  :type (:documentation
    "Name of the transaction to be modified."
    :sexp))
 (:label "Directory:"
  :default *ui-directory*
  :type (:documentation
    "Default directory in which it can be found, if not in memory."
    :SEXP))
 (:label "Pathname :"
  :default *ui-file*
  :type (:documentation
    "The default file in which it can be found, if not in memory."
    :SEXP))
  :label "Give parameters for MODIFY TRANSACTION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify a transaction."
      :keys ((#\SUPER-M #\SUPER-T)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-TRANSACTION transaction
      (SETQ keywords (LIST 'dir dir
   'path path)))))
  (MODIFY-TRANSACTION transaction keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE DATABASE                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-database) (database directory doc env
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-database)
   (FORMAT NIL "  ~S"
   (CONS
     'define-database
     (ARGLIST 'define-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
    "Name of the database."
    :sexp))
 (:label "Directory Name:"
  :default *ui-directory*
  :type (:documentation
   "Name of the save directory for this database."
   :sexp))
 (:label "Documentation:"
  :default *ui-doc*
  :type (:documentation
    "Documentation for the database."
    :string))
 (:label "Environment:"
  :default nil
  :type (:documentation
    "Name of the environment to be used to replace the default settings."
    :sexp))
  :label "Give parameters for DEFINE DATABASE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a database in a given directory."
      :keys ((#\SUPER-D #\SUPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFDB database
      (SETQ keywords (LIST 'dir directory
   'doc doc
   'environment env)))))
  (DEFDB database keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY DATABASE                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-database) (database new-database directory doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-database)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-database
     (ARGLIST 'modify-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
    "Name of the database."
    :sexp))
 (:label "New Database Name:"
  :default nil
  :type (:documentation
    "If the database is to be renamed specify the new name."
    :sexp))
 (:label "Directory Name:"
  :default NIL
  :type (:documentation
   "To change the save directory for this database specify a new directory."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the database."
    :string))
  :label "Give parameters for MODIFY DATABASE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a database."
      :keys ((#\SUPER-M #\HYPER-D)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-DATABASE database
      (SETQ keywords (LIST 'database-name new-database
   'dir directory
   'doc doc
   )))))
  (MODIFY-DATABASE database keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY ATTRIBUTE                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-attribute) (relation attr new-attr def doc format
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-attribute
     (ARGLIST 'modify-attribute))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
    "Name of the relation."
    :sexp))
 (:label "Attribute Name:"
  :default nil
  :type (:documentation
    "Name of the attribute."
    :sexp))
 (:label "New Attribute Name:"
  :default nil
  :type (:documentation
    "If the attribute is to be renamed specify the new name."
    :sexp))
 (:label "Default Value:"
  :default NIL
  :type (:documentation
   "To change the default value of this attribute specify a new value."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the attribute."
    :string))
 (:label "Default width :"
  :default nil
  :type (:documentation
    "The new default width to be used for this attribute."
    :sexp))
  :label "Give parameters for MODIFY ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a attribute."
      :keys ((#\SUPER-M #\SUPER-A)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-ATTRIBUTE relation attr
      (SETQ keywords (LIST 'attribute-name new-attr
   'def def
   'doc doc 'format format
   )))))
  (MODIFY-ATTRIBUTE relation attr keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY VIEW                                       **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-view) (view def doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-view)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-view
     (ARGLIST 'modify-view))))
      :arguments (:user-supplied (:label "View Name:"
  :default NIL
  :type (:documentation
    "Name of the view."
    :sexp))
 (:label "View Definition:"
  :default nil
  :type (:documentation
    "New definition of the view."
    :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the view."
    :string))
  :label "Give parameters for MODIFY VIEW:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a view."
      :keys ((#\SUPER-M #\SUPER-V)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-VIEW view
      (SETQ keywords (LIST
   'view-def def
   'view-doc doc
   )))))
  (MODIFY-VIEW view keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY RELATION                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-relation) (rel new-rel add-att del-att ren-att
   imp sto format key dir doc
   &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-relation
     (ARGLIST 'modify-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default *ui-relation*
  :type (:documentation
    "Name of the Relation."
    :sexp))
 (:label "New Relation Name:"
  :default nil
  :type (:documentation
    "If the relation is to be renamed specify the new name."
    :sexp))
 (:label "Add attributes:"
  :default NIL
  :type (:documentation
   "Specify a list of attribute-descriptor pairs for attributes to be added to this relation."
   :sexp))
 (:label "Delete attributes:"
  :default NIL
  :type (:documentation
   "Specify a list of attributes in this relation which are to be deleted."
   :sexp))
 (:label "Rename attributes:"
  :default NIL
  :type (:documentation
   "To rename some of the attributes provide a list of the form (<old-attribute new-attribute>)."
   :sexp))
 (:label "Implementation Type:"
  :default NIL
  :type (:documentation
   "To change the implementation type of this relation specify a new value."
   :sexp))
 (:label "Storage structure:"
  :default NIL
  :type (:documentation
   "To change the storage structure of this relation specify a new value."
   :sexp))
 (:label "Format:"
  :default NIL
  :type (:documentation
   "To change the format for this relation specify a new format as a list of values."
   :sexp))
 (:label "Key:"
  :default NIL
  :type (:documentation
   "To change the key for this relation specify a new key as a list of attributes."
   :sexp))
 (:label "Directory Name:"
  :default NIL
  :type (:documentation
   "To change the save directory for this relation specify a new directory."
   :sexp))
 (:label "Documentation:"
  :default NIL
  :type (:documentation
    "New documentation for the relation."
    :string))
  :label "Give parameters for MODIFY RELATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify the features a relation."
      :keys ((#\SUPER-M #\SUPER-R)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'MODIFY-RELATION rel
      (SETQ keywords (LIST 'relation new-rel
   'add-attributes add-att
   'delete-attributes del-att
   'rename-attributes ren-att
   'imp imp
   'sto sto
   'format format
   'key key
   'doc doc
   'dir dir
   )))))
  (MODIFY-RELATION rel keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE ENVIRONMENT                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-environment) (environment save dir err par-check
      rel-imp rel-sto status sys-imp
      sys-sto val-check warn
      &AUX keywords)
    `(:description ,(STRING-APPEND (DOCUMENTATION 'define-environment)
   (FORMAT NIL "  ~S"
   (CONS
     'define-environment
     (ARGLIST 'define-environment))))
      :arguments (:user-supplied (:label "Environment Name:"
  :default nil
  :type (:documentation
    "Name of the environment."
    :sexp))
 (:label "Auto save:"
  :default nil
  :type (:documentation
   "Automatically saves all the modified relations after each function." :boolean))
 ,*ucl-dir*
 (:label "Errors:"
  :default T
  :type (:documentation
    "Controls the printing of the error messages."
    :boolean))
                                         (:label "Parameter Checking:"
  :default T
  :type (:documentation
    "Controls the checking of the parameters."
    :boolean))
                                         (:label "Relation Implementation:"
  :default *ui-imp*
  :type (:documentation
                                            "Default implementation of the user relations."
    :sexp))
                                         (:label "Relation storage structure:"
  :default *ui-ss*
  :type (:documentation
    "Default storage structure for the user relations."
    :sexp))
                                         (:label "Status:"
  :default T
  :type (:documentation
    "Controls the printing of the status messages."
    :boolean))
                                         (:label "System Implementation:"
  :default nil
  :type (:documentation
    "Default implementation of the system relations. Can not change this when a database is active."
    :sexp))
                                         (:label "System storage structure:"
  :default nil
  :type (:documentation
    "Default storage structure for the system relations. Can not change this when a database is active."
    :sexp))
                                         (:label "Validity Checking:"
  :default T
  :type (:documentation
    "Controls the checking of the values during insertion and modification for validity."
    :boolean))
                                         (:label "Warnings:"
  :default T
  :type (:documentation
    "Controls the printing of the warning messages."
    :boolean))
  :label "Give parameters for DEFINE ENVIRONMENT:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define an environment in a given directory."
      :keys ((#\SUPER-D #\SUPER-E)))
  (SEND *output-window*
:append-item
(FORMAT nil "~S"
(LIST 'DEFENV environment
      (SETQ keywords (IF *active-db*
 (LIST 'auto-save save 'para par-check
   'dir dir 'rel-imp rel-imp 'rel-sto
                                           rel-sto 'errors err 'status status
                                           'validity val-check 'warnings warn)
       (LIST 'auto-save save 'para par-check
   'dir dir 'rel-imp rel-imp 'rel-sto
                                           rel-sto 'errors err 'status status
   'sys-imp sys-imp 'sys-sto sys-sto
                                           'validity val-check 'warnings warn))))))
  (DEFENV environment keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE RELATION                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-relation) (relation attr-des tup
   dir doc key imp ss &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'define-relation
     (ARGLIST 'define-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
   "Name of the relation to be defined."
   :sexp))
 ,*ucl-attr-desc*
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doci*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
     :label "Give parameters for DEFINE RELATION:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "used to define a relation."
      :keys ((#\SUPER-D #\SUPER-R)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFREL
      relation attr-des
      (SETQ keywords
    (LIST 'tuple-format tup 'dir dir 'doc doc
  'key key 'imp imp 'sto ss)))))
  (DEFREL relation attr-des keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE VIEW                                       **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-view) (viewname view-definition doc)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-view)
   (FORMAT NIL "  ~S"
   (CONS
     'define-view
     (ARGLIST 'define-view))))
      :arguments (:user-supplied (:label "View Name:"
  :default nil
  :type (:documentation
     "Specify a name for the view."
  :sexp))
 (:label "View Definition:"
  :default *ui-viewdef*
  :type (:documentation
     "Specify a definition for the view."
  :sexp))
 (:label "View Documentation:"
  :default nil
  :type (:documentation
     "Specify documentation for the view."
  :sexp))
 :label "Give parameters for DEFINE VIEW:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to define a view."
      :keys ((#\SUPER-D #\SUPER-V)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFVIEW viewname view-definition doc)))
  (DEFVIEW viewname view-definition doc))
;**************************************************************************
;1                DEFCOMMAND  FOR DEFINE ATTRIBUTE                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC define-attribute) (relation-name attr-des key
  &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'define-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'define-attribute
     (ARGLIST 'define-attribute))))
      :arguments (:user-supplied (:label "Relation name: "
  :default *ui-relation*
  :type (:documentation
     "The name of the relation to which new attributes are to be added." :SEXP))
 ,*ucl-attr-desc*
 (:label "Key: "
  :default nil
  :type (:documentation
     "New key for the relation if it is to be different from the previous value. Specify a list of attributes."
     :SEXP))
 :label "Give parameters for DEFINE ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Definition"))
      :documentation "Used to add attributes to relations."
      :keys ((#\SUPER-D #\SUPER-A)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DEFINE-ATTRIBUTE relation-name attr-des
      (SETQ keywords (LIST 'key key)))))
  (DEFINE-ATTRIBUTE relation-name attr-des keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MODIFY TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC modify-tuples) (relation where-clause attributes values
  &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'modify-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'modify-tuples
     (ARGLIST 'modify-tuples))))
      :arguments (:user-supplied (:label "Relation: "
  :default *ui-relation*
  :type (:documentation
     "Specify the relation whose tuples are to be modified."
  :sexp))
 ,*ucl-where*
 (:label "Attributes: "
  :default *ui-attributes*
  :type (:documentation
     "Specify a list of attributes in the above relation to be modified." :sexp))
 (:label "Values: "
  :default *ui-values*
  :type (:documentation
     "Specify a corresponding list of values to modify the above attributes." :sexp))
 :label "Give parameters for MODIFY TUPLES ==>")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to modify tuples in a relation."
      :keys ((#\SUPER-M #\HYPER-M)))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'MODIFY relation (SETQ keywords (LIST 'where where-clause
    'attr attributes
    'values values)))))
  (MODIFY relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR DELETE TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC delete-tuples) (relation where-clause)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'delete-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'delete-tuples
     (ARGLIST 'delete-tuples))))
      :arguments (:user-supplied (:label "Relation: "
  :default *ui-relation*
  :type (:documentation
     "Specify a relation whose tuples are to be deleted."
  :sexp))
 (:label "Where clause: "
  :default nil
  :type (:documentation
     "Deletes the tuples which satisfy this condition."
  :sexp))
 :label "Give parameters for DELETE TUPLES ==>")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to delete tuples in a relation."
      :keys (#\HYPER-D))
  (SEND *output-window* :append-item (FORMAT nil "~S"
(LIST 'DELETE-TUPLES relation (LIST 'where where-clause))))
  (DELETE-TUPLES  relation (LIST 'where where-clause)))
;**************************************************************************
;1                DEFCOMMAND  FOR RETRIEVE TUPLES                                   **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC retrieve-tuples) (relation attributes where-clause
   into dir doc key imp sto
   qprint to-file sort
   format wide number print
   tuples qsort stream unique index-name
   &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'retrieve)
   (FORMAT NIL "  ~S"
   (CONS
     'retrieve
     (ARGLIST 'retrieve))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-attributes*
 ,*ucl-where*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 ,*ucl-index-name*
 :label "Give parameters for RETRIEVE TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Retrieve tuples in a relation."
      :keys (#\HYPER-R))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RETRIEVE
      relation
      (SETQ keywords
    (LIST 'project
  (IF (EQUAL attributes T)
      NIL
    attributes)
  'where where-clause 'into into
  'dir dir 'doc doc 'key key 'imp imp 'sto sto
  'qprint (NOT qprint) 'output-to-file to-file
  'sort sort 'format format
  'wide wide 'num number
  'print print 'tuples tuples
  'quick-sort qsort 'stream stream
  'unique unique 'index-name index-name)))))
  (RETRIEVE relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SELECT TUPLES                                     **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC select) (relation where-clause
   into dir doc key imp sto
   qprint to-file sort
   format wide number print
   tuples qsort stream unique index-name
   &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'select-tuples)
   (FORMAT NIL "  ~S"
   (CONS
     'select-tuples
     (ARGLIST 'select-tuples))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-where*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 ,*ucl-index-name*
 :label "Give parameters for SELECT TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Select tuples in a relation."
      :keys ((#\SUPER-R #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SELECT-TUPLES
      relation
      (SETQ keywords
    (LIST
  'where where-clause 'into into
  'dir dir 'doc doc 'key key 'imp imp 'sto sto
  'qprint (NOT qprint) 'output-to-file to-file
  'sort sort 'format format
  'wide wide 'num number
  'print print 'tuples tuples
  'quick-sort qsort 'stream stream
  'unique unique 'index-name index-name)))))
  (RETRIEVE relation (APPEND (LIST 'project nil) keywords)))
;**************************************************************************
;1                DEFCOMMAND  FOR PROJECT TUPLES                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC Project) (relation attributes
    into dir doc key imp sto
    qprint to-file sort
    format wide number print tuples
    qsort stream unique
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'project)
   (FORMAT NIL "  ~S"
   (CONS
     'project
     (ARGLIST
       'project))))
      :arguments (:user-supplied ,*ucl-retrieve-rel*
 ,*ucl-attributes*
 ,*ucl-into*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-qprint*
 ,*ucl-out*
 ,*ucl-sort*
 ,*ucl-format*
 ,*ucl-wide*
 ,*ucl-num*
 ,*ucl-print*
 ,*ucl-tuples*
 ,*ucl-quick-sort*
 ,*ucl-stream*
 ,*ucl-unique*
 :label "Give parameters for PROJECT TUPLES ==>")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to Project tuples in a relation."
      :keys ((#\SUPER-R #\SUPER-P)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'PROJECT
      relation
      (SETQ keywords
    (LIST 'project (IF (EQUAL attributes T)
 nil
       attributes)
    'into into 'dir dir 'doc doc 'key key 'imp imp 'sto sto
    'qprint (NOT qprint) 'output-to-file to-file
    'sort sort 'format format
    'wide wide 'num number 'print print 'tuples tuples
    'quick-sort qsort 'stream stream 'unique unique)))))
  (RETRIEVE relation (APPEND (LIST 'where t) keywords)))
;**************************************************************************
;1                DEFCOMMAND  FOR COMMIT TRANSACTION                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC commit-transaction) (trans dir path &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'commit-transaction)
   (FORMAT NIL "  ~S"
   (CONS
     'commit-transaction
     (ARGLIST
       'commit-transaction))))
      :arguments (:user-supplied (:label "Name of the transaction :"
  :default *ui-transaction*
  :type (:documentation
     "The name of an existing transaction." :SEXP))
 (:label "Name of the directory:"
  :default *ui-directory*
  :type (:documentation
     "Name of the directory which contains the transaction file, if the transaction is not in the memory." :SEXP))
 (:label "Pathname:"
  :default *ui-file*
  :type (:documentation
 "If the transaction is not in memory, provide the pathname for the transaction file. It defaults to <transaction>.lisp." :SEXP))
 :label "Give parameters for COMMIT TRANSACTION")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Commit a transaction - execute all the database calls in it."
      :keys ((#\SUPER-T #\SUPER-C)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'COMMIT-TRANSACTION trans (SETQ keywords
      (LIST 'dir dir
    'path path)))))
  (COMMIT-TRANSACTION trans keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR JOIN                                              **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC join) (into from project where
     tuples format dir doc key imp sto
             print unique &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'join)
   (FORMAT NIL "  ~S"
   (CONS
     'join
     (ARGLIST
       'join))))
      :arguments (:user-supplied (:label "Output relation :"
  :default *ui-join-into*
  :type (:documentation
     "If not provided, the result of JOIN is stored in a temporary relation unless only the resultant tuples are requested." :SEXP))
 (:LABEL "FROM :"
  :DEFAULT *ui-from*
  :TYPE (:DOCUMENTATION
  "Specify a list of two relations to be joined." :SEXP))
 (:label "Project :"
  :default NIL
  :type (:documentation
     "This gives the attributes in the output relation. Example: (rel1.* a3 (rel2.a1 a4)) ==> All the attributes in rel1, attribute A3 of rel2 and atribute A1 of rel2 renamed as A4." :SEXP))
 (:label "Where :"
  :default *ui-over*
  :type (:documentation
  "The join clause using the theta-operators. It is a where clause consisting of attributes from the relations being joined." :SEXP))
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
 :label "Give parameters for JOIN")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to join relations."
      :keys (#\SUPER-J))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'JOIN 'from from
      (SETQ keywords (LIST 'project project
   'into into
   'tuples tuples
   'format format
   'dir dir
   'doc doc
   'key key
   'imp imp
   'sto sto
   'print print
   'where where 'unique unique)))))
  (JOIN-INTERNAL (APPEND (LIST 'from from) keywords))
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY* 1DATABASE                                 **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-database) (database disk &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-database)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-database
     (ARGLIST
       'destroy-database))))
      :arguments (:user-supplied (:label "Database Name:"
  :default nil
  :type (:documentation
     "Name of the database to be destroyed." :SEXP))
 (:label "Delete from the DISK:"
  :default NIL
  :type (:documentation
  "IF YES all the files pertaining to this database are deleted but NOT EXPUNGED." :BOOLEAN))
 :label "Give parameters for DESTROY DATABASE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy databases"
      :keys ((#\SUPER-K #\SUPER-D)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-DATABASE database
      (SETQ keywords (LIST 'disk disk)))))
  (DESTROY-DATABASE database keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY DOMAIN                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-domain) (domain)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-domain)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-domain
     (ARGLIST
       'destroy-domain))))
      :arguments (:user-supplied (:label "Domain Name:"
  :default nil
  :type (:documentation
     "Name of the domain to be destroyed." :SEXP))
 :label "Give parameters for DESTROY DOMAIN:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy domains."
      :keys (#\SUPER-HYPER-K))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-DOMAIN domain)))
  (DESTROY-DOMAIN domain))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY IMPLEMENTATION                            **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-implementation) (implementation)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-implementation)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-implementation
     (ARGLIST
       'destroy-implementation))))
      :arguments (:user-supplied (:label "Implementation Name:"
  :default nil
  :type (:documentation
     "Name of the implementation to be destroyed." :SEXP))
 :label "Give parameters for DESTROY IMPLEMENTATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy implementations."
      :keys ((#\SUPER-K #\SUPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-IMPLEMENTATION implementation)))
  (DESTROY-IMPLEMENTATION implementation))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY INDEX                            **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC DESTROY-INDEX) (relation-name index-name)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-index)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-index
     (ARGLIST
       'destroy-index))))
      :arguments (:user-supplied (:label "2Relation* Name:"
  :default nil
  :type (:documentation
     "Name of the 2relation on which the index to be destroyed is defined*." :SEXP))
 (:label "2Index* Name:"
  :default nil
  :type (:documentation
     "Name of the 2index* to be destroyed." :SEXP))
2     *:label "Give parameters for DESTROY 2INDEX:*")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy 2indices*."
      :keys ((#\SUPER-K #\HYPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-INDEX relation-name index-name)))
  (DESTROY-INDEX relation-name index-name))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY STORAGE STRUCTURE                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-storage-structure) (storage-structure)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-storage-structure)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-storage-structure
     (ARGLIST
       'destroy-storage-structure))))
      :arguments (:user-supplied (:label "Storage structure name:"
  :default nil
  :type (:documentation
     "Name of the storage structure to be destroyed." :SEXP))
 :label "Give parameters for DESTROY STORAGE STRUCTURE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy storage structures."
      :keys ((#\SUPER-K #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-STORAGE-STRUCTURE storage-structure)))
  (DESTROY-STORAGE-STRUCTURE storage-structure))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY VIEW                                      **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-view) (view)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-view)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-view
     (ARGLIST
       'destroy-view))))
      :arguments (:user-supplied (:label "View name:"
  :default nil
  :type (:documentation
     "Name of the view to be destroyed."
     :SEXP))
 :label "Give parameters for DESTROY VIEW:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy views."
      :keys ((#\SUPER-K #\SUPER-V)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-VIEW view)))
  (DESTROY-VIEW view))
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROYREL                                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-relation) (relation disk &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-relation)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-relation
     (ARGLIST
       'destroy-relation))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
     "Name of the relation to be destroyed." :SEXP))
 (:label "Delete from the DISK:"
  :default NIL
  :type (:documentation
  "IF YES the file corresponding to this relation is deleted but NOT EXPUNGED." :BOOLEAN))
 :label "Give parameters for DESTROY RELATION:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy relations"
      :keys ((#\SUPER-K #\SUPER-R)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-RELATION
      relation (SETQ keywords (LIST 'disk disk)))))
  (DESTROY-RELATION relation keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR DESTROY* 1ATTRIBUTE* 1                                **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC destroy-attribute) (relation attr key &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'destroy-attribute)
   (FORMAT NIL "  ~S"
   (CONS
     'destroy-attribute
     (ARGLIST
       'destroy-attribute))))
      :arguments (:user-supplied (:label "Relation Name:"
  :default nil
  :type (:documentation
     "Name of the relation from which attributes are to be destroyed." :SEXP))
 (:label "Attributes:"
  :default nil
  :type (:documentation
     "List of attributes to destroy." :SEXP))
 (:label "Key:"
  :default NIL
  :type (:documentation
  "New key for the relation if it is to be different from the previous value or if any of the key attributes are destroyed." :SEXP))
 :label "Give parameters for DESTROY ATTRIBUTE:")
      :menus ((command-menu :COLUMN "Manipulation"))
      :documentation "Used to destroy attributes from relations"
      :keys ((#\SUPER-K #\SUPER-A)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'DESTROY-ATTRIBUTE relation (SETQ keywords (LIST 'attr attr
 'key key)))))
  (DESTROY-ATTRIBUTE relation keywords)
)
;**************************************************************************
;1                DEFCOMMAND  FOR SET UNION                                         **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC union) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-union)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-union
     (ARGLIST
       'relation-union))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation union operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-union of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form union of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-U)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-UNION
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-UNION keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SET DIFFERENCE                                    **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC difference) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-difference)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-difference
     (ARGLIST
       'relation-difference))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation difference operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-difference of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form difference of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-D)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-DIFFERENCE
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-DIFFERENCE keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SET INTERSECTION                                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC intersection) (from into tuples format
      dir doc key imp sto print unique
      &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'relation-intersection)
   (FORMAT NIL "  ~S"
   (CONS
     'relation-intersection
     (ARGLIST
       'relation-intersection))))
      :arguments (:user-supplied (:label "List of two relations:"
  :default NIL
  :type (:documentation
  "List of the names of two relations which will take part in the relation intersection operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>))." :SEXP))
 ,*ucl-into*
 (:label "Tuples?"
  :default NIL
  :type (:documentation
   "Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true."
   :boolean))
 ,*ucl-format*
 ,*ucl-dir*
 ,*ucl-doco*
 ,*ucl-key*
 ,*ucl-imp*
 ,*ucl-sto*
 ,*ucl-print*
 ,*ucl-unique*
  :LABEL "Parameters for the set-intersection of two relations")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to form intersection of two compatible relations"
      :keys ((#\SUPER-O #\SUPER-I)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'RELATION-INTERSECTION
      (SETQ keywords (LIST 'into into
   'from from 'tuples tuples
   'format format 'dir dir 'doc doc
   'key key 'imp imp 'sto sto
   'print print 'unique unique)))))
  (RELATION-INTERSECTION keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR AVERAGE                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC average) (relation attribute unique where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'average)
   (FORMAT NIL "  ~S"
   (CONS
     'average
     (ARGLIST
       'average))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be averaged." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for average:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the average of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-A)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'AVERAGE relation attribute
      (SETQ keywords (LIST 'unique unique
   'where where 'by by 'tuples tuples)))))
  (AVERAGE relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SUM                                               **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC sum) (relation attribute unique where by tuples
&AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'sum)
   (FORMAT NIL "  ~S"
   (CONS
     'sum
     (ARGLIST
       'sum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be summed." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for sum:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the sum of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-S)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SUM relation attribute
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (SUM relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR SIZE                         *   1                  **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC size) (relation unique where by tuples &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'size)
   (FORMAT NIL "  ~S"
   (CONS
     'size
     (ARGLIST
       'size))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation whose size is required." :SEXP))
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for size:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the size of the relation."
      :keys (#\SUPER-HYPER-S))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'SIZE relation
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (SIZE relation keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR COUNT-RTMS                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC count) (relation attribute unique where by tuples
       &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'count-rtms)
   (FORMAT NIL "  ~S"
   (CONS
     'count-rtms
     (ARGLIST
       'count-rtms))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be used to find the number of tuples." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-count-unique*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for count:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the count of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-C)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'COUNT-RTMS relation attribute
      (SETQ keywords (LIST 'unique unique 'by by 'tuples tuples
   'where where)))))
  (COUNT-RTMS relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MAXIMUM                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC maximum) (relation attribute where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'maximum)
   (FORMAT NIL "  ~S"
   (CONS
     'maximum
     (ARGLIST
       'maximum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be maximumd." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-where*
 ,*ucl-by*
 ,*ucl-tuples*
  :LABEL "Parameters for maximum:")
      :menus ((command-menu :COLUMN "Operators"))
      :documentation "Used to compute the maximum of the attribute values in a relation."
      :keys ((#\SUPER-O #\SUPER-M)))
  (SEND *output-window* :append-item
(FORMAT nil "~S"
(LIST 'MAXIMUM relation attribute
      (SETQ keywords (LIST 'where where 'by by 'tuples tuples)))))
  (MAXIMUM relation attribute keywords))
;**************************************************************************
;1                DEFCOMMAND  FOR MINIMUM                                           **
;**************************************************************************
(UCL:DEFCOMMAND (DBMS-RC minimum) (relation attribute where by tuples
    &AUX keywords)
            `(:description ,(STRING-APPEND (DOCUMENTATION 'minimum)
   (FORMAT NIL "  ~S"
   (CONS
     'minimum
     (ARGLIST
       'minimum))))
      :arguments (:user-supplied (:label "Relation name:"
  :default *ui-relation*
  :type (:documentation
   "Name of the relation which contains the attribute to be minimumd." :SEXP))
 ,*ucl-count-attr*
 ,*ucl-where*
LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540749. :SYSTEM-TYPE :LOGICAL :VERSION 3. :TYPE "XLD" :NAME "INTERFACE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360973. :AUTHOR "REL3" :LENGTH-IN-BYTES 68086. :LENGTH-IN-BLOCKS 133. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lINTERFACE\B8LISP\B8FBASEF
FONTS\WIDER-MEDFNTMEDFNBBJHL7)PACKAGERTMSMODECOMMON-LISP1\*PUTPROP\B8DISPLAYB:\B8pUCLITEMS1\BQ\B8BSB:\B8pBUCOMMANDS-WANTING-ON1\BQ\B8COMMAND-MENUB:\B8BW1\BQ\B8BaB:\B8B]1\BQ\B8SYSTEM-MENUB:\B8BW1\BQ\B8BjB:\B8B]j*PACKAGE*NrÁ*DEFAULT-PKG*1\pTICL,PKG-GOTO*PKG-STRING*1\pBUMAKE-SYNONYM\B8Á*UI-RELATION*B:1\B|\B8*UI-TUPLES*B:1\B|\B8*UI-TRANSACTION*B:1\B|\B8Á*UI-FUNCTION*B:1\B|\B8*UI-ATTRIBUTES*B:1\B|\B8*UI-FORMAT*B:1\B|\B8C*UI-FILE*B:1\B|\B8Á*UI-DATABASE**ACTIVE-DB*1\B|\B8Á*UI-DIRECTORY*\pBuSTRING-APPENDSYS:pBu,USER-IDl;1\B|\B8C*UI-TYPE*\B8XLD1\B|\B8Á*UI-ATTR-DESC*B:1\B|\B8*UI-DOC*.....1\B|\B8*UI-KEY*B:1\B|\B8*UI-IMP*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*1\B|\B8*UI-SS**SYSTEM-RELATION-STORAGE-STRUCTURE*1\B|\B8*UI-VIEWDEF*B:1\B|\B8C*UI-WHERE*jT1\B|\B8*UI-VALUES*B:1\B|\B8Á*UI-JOIN-INTO*B:1\B|\B8C*UI-OVER*B1\B|\B8C*UI-INTO*B:1\B|\B8C*UI-FROM*B:1\B|\B8C*UI-WIDE*B:1\B|\B8*UI-NUM*F1\B|\B8C*UI-SORT*B:1\B|\B8*UI-OBJECT*B:1\B|\B8C*UI-REL2*B:1\pSYSlDEFCONST-1C*LINE-AREA-DOCUMENTATION*\B8\DOCUMENTATION,iMOUSE-L-1,To see the entire line.iMOUSE-M-2To delete the tuple.iMOUSE-R-1To modify the tuple.lThe wholine documentation string when a line is selected.1\B*DBMS-WINDOW-WHOLINE-DOCUMENTATION*\B8\B,Window for database output. Some items are made mouse-sensitive for inspection.BlRTMS Command MenuiMOUSE-R-2System MenulThe wholine documentation string when in the RTMS interface output window.1\B*INTERACTION-WHOLINE-DOCUMENTATION*\B8\BThis window accepts user input. Input can also be provided through the command menu.BlRTMS Command MenuBSystem Menu1\BC*ATTRIBUTE-WHOLINE-DOCUMENTATION*\B8\iMOUSE-ANYTo see this ATTRIBUTE's definition.1\B*DBMS-OBJECT-WHOLINE-DOCUMENTATION*\B8\B,To see this object's definition.1\B*RELATION-WHOLINE-DOCUMENTATION*\B8\B,B,To see the RELATION definition.iMOUSE-M-1,To modify the RELATION features.BlTo retrieve this RELATION.1\B*DATABASE-WHOLINE-DOCUMENTATION*\B8\BList the relations in this DATABASE, if it is active.1\pBlDEFFLAVOR2\B8CMENU-PANEB:\B8\plWMENU\B8\\iDEFAULT-INIT-PLISTCOMMAND-MENUB)DYNAMICB1\B9\B8DBMS-WINDOWB:\B8\plTVLINE-AREA-TEXT-SCROLL-MIXINpBMFUNCTION-TEXT-SCROLL-WINDOWpBMlMOUSE-SENSITIVE-TEXT-SCROLL-WINDOWpBMMARGIN-REGION-MIXINpBM,SCROLL-BAR-MIXINpBMANY-TYI-MIXINpB>WINDOWB:\METHODBJLINE-AREA-MOUSE-DOCUMENTATIONF@F$B:pBuART-Q]FB:B:B:BFpBlDEBUG-INFO-STRUCTB]\pB.OPERATION.B:B:\SELF-FLAVORBJBOpB]1\B9\B8DBMS-WINDOW-WITH-TYPEOUTB:\B8\pBM,TEXT-SCROLL-WINDOW-TYPEOUT-MIXINBJ\B8\\BDTYPEOUT-WINDOW\B8\pBMTYPEOUT-WINDOW)DEEXPOSED-TYPEOUT-ACTION\iEXPOSE-FOR-TYPEOUT\B^BsWHO-LINE-DOCUMENTATION-STRING(@HF $B:Bd]FB:B:B:BFBjB\BmB:\IGNORECM-S-I-TYPE\)MACROS-EXPANDED\pBuSENDCASEBoBsB	B"B2B(BpB,MOUSE-YpB,MOUSE-X*OUTPUT-WINDOW*MOUSE-SENSITIVE-ITEMFFCATTRIBUTERELATIONDATABASEDBMS-OBJECTFF>F:F;F<F=P	PPP
PAA@AQrOB1\B9\B8INTERACTION-PANEB:\B8\pBUCOMMAND-AND-LISP-TYPEIN-WINDOWpBMPREEMPTABLE-READ-ANY-TYI-MIXINB:\B^BBF@F$B:Bd]FB:B:B:BFBjB\BmB:B:\BoBBOB\B^BBEFORESELECT`DF$B:Bd]FB:B:B:BFBjB\Bm&RESTBB:\B\B\BBoBDBMS-FRAME1EXPOSEPOB\B^BAFTERB`DF$B:Bd]FB:B:B:BFBjB\BmBBB:\B\BoBROB1\B9\B8DBMS-RCB:\B8\pBUlCOMMAND-LOOP-MIXINpBMSTREAM-MIXINpBMlINFERIORS-NOT-IN-SELECT-MENU-MIXINpBM,BORDERED-CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER\B8\\BDiMENU-PANES\B8\\S-M-PANEBjACTIVE-COMMAND-TABLES\B8\DBMS-COMTABiALL-COMMAND-TABLES\B8\BTYPEIN-HANDLERHANDLE-TYPEIN-INPUTMINIMUM-WIDTH\BpBMDEFAULT-SCREENWIDTHMINIMUM-HEIGHT\BBHEIGHTiBASIC-HELP\B8\HELPPRINT-FUNCTION\B8CNEW-PRINTPRINT-RESULTS?\*FUNCTION\LAMBDAB:BPANES\pBlXR-BQ-LIST\B\B8ÀO-PANE\B8Bs\B8iBLINKER-PB:\B8B\B8DBMS-PRINTER\B8iPRINT-FUNCTION-ARGB:\B8)SCROLL-BAR-SIDE\B8RIGHT\B8)SCROLL-BAR-MODE\B8)MAXIMUM\B8)BORDERSB:\B8LABEL\BBOTTOMSTRINGOUTPUTFONTpFONTS,CPTFONT\B8)FONT-MAP\BpB0,CPTFONTB\B8SENSITIVE-ITEM-TYPES\B\B8B\B8B\B8B\B8B\B\B8ÀI-PANE\B8B\B8iSAVE-BITSB\B8B\B8OFF\B8B*\BB,B-Rtms InterfaceB/pB0MEDFNT\B8B(F\B8B4\BpB0MEDFNB\pBXR-BQ-LIST*\B8B\B8B;\B8B4\BpB0HL12B\B8\ROWSFB*B:CONSTRAINTS\B8\\MAIN\BBAB\\BFLINES\\BL?\\BAEVEN\INIT-KEYWORDSBB\B^BHANDLE-UNKNOWN-INPUT=.óFk$B:Bd]FB:B:B:BFBjBs\BmB:\ITEMpB.CASE.ITEM.B\B\FOURTHFIRSTBBB*TERMINAL-IO*1]pBlFLAVOR-VAR-SELF-REF-INDEX]B8]BpBU,INPUT-MECHANISMpBuBEEP)SEND-IF-HANDLESiFRESH-LINE ** WRITE-STRING1]B]B8]BpBUERROR-MESSAGElUnrecognized inputPRINC1]B]B8]BpBUlKBD-INPUTÁHELP-LINE-AREACHELP-LINE-AREA-MODCHELP-LINE-AREA-DELSTRING҃HELP-OBJECT*READ-FROM-STRINGRETRIEVE҃HELP-MODIFYFpBUMENUpBUKEY-OR-BUTTONpBUTYPEINFFF|F}F~FiLINE-AREABBBBFFFFFFFF	FFFFFFBFFFFPrPP	P
PPR4IRA rPBB-rVVVRV@5@W@QV@5@W@QV@5@W@QPBB6rV@Á@Q@QV@Á@Q@QV@5@W@QROBs\B^BACTIVE-DATABASE	@	DF$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBlReturns the name of the active database. (ACTIVE-DATABASE)BAPPEND-ITEMl~S\BFORMATBВP@PPP@P@PP@OB1\jOR\pBU,RE-USE-COMMAND-INSTANCE?\B8\B^BB\B8\NAMES,Active DatabaseiDEFINITIONB)DEFNAMEB穀KEYS\\ F AB,Returns the name of the active database.MENUS\\BaCOLUMNOther FeaturesDESCRIPTIONB\B8pBU,COMMAND\pBulINSTANTIATE-FLAVOR\B8B\B8\B:BBBBBBBBBBBBBBB\B^BCABORT-TRANSACTION	@	DF$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBlTerminates the special transaction processing. (ABORT-TRANSACTION)BBl~S\BBBP@PPP@P@PP@OB1\B\B\B8\B^BB\B8\BlAbort TransactionBBBBB\\ TBBTerminates the special transaction processing.B\\BaBOther FeaturesBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBB\B^BCBEGIN-TRANSACTION	@	DF$B:Bd]FB:B:B:BFBjB(\BmB:B:\B\BBoBBBegins the special transaction processing. (BEGIN-TRANSACTION)BBl~S\B)BB)P@PPP@P@PP@O7B(1\B\B\B8\B^BB)\B8\BlBegin TransactionBB;BB;B\\B BBlBegins the special transaction processing.B\\BaBOther FeaturesBB4\B8B\B\B8B\B8\B:BB>BB;BB;BB?BBBBBCBB4B\B^BEND-TRANSACTION	@	DF$B:Bd]FB:B:B:BFBjBL\BmB:B:\B\BBoBBExecutes the database calls postponed due to special transaction processing and terminates the transaction.  (END-TRANSACTION)BBl~S\BMBBMP@PPP@P@PP@O[BL1\B\B\B8\B^BBM\B8\B,End TransactionBB_BB_B\\B EB
Executes the database calls postponed due to special transaction processing and terminates the transaction.B\\BaBOther FeaturesBBX\B8B\B\B8B\B8\B:BBbBB_BB_BBcBBfBBgBBXB\B^BCENVIRONMENT-STATUS	@	DF$B:Bd]FB:B:B:BFBjBp\BmB:B:\B\BBoBBReturns the values of the environment variables. (ENVIRONMENT-STATUS)BBl~S\BqBBqP@PPP@OBp1\B\B\B8\B^BBq\B8\BlEnvironment StatusBBBBB\\BBeB,Returns the values of the environment variables.B\\BaBOther FeaturesBB|\B8B\B\B8B\B8\B:BBBBBBBBBBBBBB|B\B^BATTACH-RELATION5BF$$B:Bd]FB:B:B:BFBjB\BmBATTPATHTUPDIRDOCKEYIMPCSSMEMB:\KEYWORDSB:\B\BBoBBAttach some existing data to relation.

   RELATION-NAME - The name of the relation to which the data is to be attached.
   ATTRIBUTES    - A list that describes the attributes in this relation.
   DIRECTORY     - The directory in which RTMS saves the attached data.
   DOCUMENTATION - A string that describes the specified relation.
   FORMAT        - A list corresponding to the ATTRIBUTES specifying their print width.
   IMPLEMENTATION-TYPE - Name of the implementation type.
   KEY           - A list of attributes that are to form the key.
   MEMORY        - Specifies a variable where the data to be attached is stored.
   PATHNAME      - If the data is stored in a file, specify its name here.
   STORAGE-STRUCTURE - Name of the storage-structure type.  (ATTACH-RELATION RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTES DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE KEY MEMORY PATHNAME STORAGE-STRUCTURE &ALLOW-OTHER-KEYS)BBl~SBBBBBBBSTOBBLISTBBPAPPPQPQPQ	PQ
PQPQPQPQPQPQJ@AQ@QOB1\B\B\B8\B^BB\B8\B,Attach RelationBBBBB\BBlused to attach a relation.B\\BaBlDefinitioniARGUMENTS\USER-SUPPLIED\B*Relation Name:)DEFAULTB:TYPE\BName of the relation to be attached.SEXP\B*lAttribute descriptor pair:BBB\B,List of attributes and their domains default, and documentation. EX. (a1 (dom <something> def <something>) a2) . If any values are not given there is a default for everything. So, the minimum necessary input is a list of attributes.B\B*lPathname:BBB\BSpecify the name of the input file.B\B*Tuple Format :BBB\B,Specify the tuple format as a list of numbers representing the column width for each attribute. If not specified, the default format for this relation is used.B\B*lDirectory:BBB\BSpecify the save directory for the relation.B\B*Documentation:Bl..B\BSpecify the documentation for this relation.B-\B*Key:BBB\B,Specify the key as a list of attributes.B\B*Implementation Type:BBB\B,Specify the implementation type.B\B*lStorage Structure:BBB\BSpecify the storage structure type.B\B*,Memory:BB:B\B,If the data is stored in the memory, then give the name of the variable that contains the data.BB*Give parameters for ATTACH RELATION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BRENAME-ATTRIBUTE@F$B:Bd]FB:B:B:BFBjB\BmBOLD-NEWB:B:\B\BUBBoBB,Use this function to rename attributes in a relation.

   RELATION-NAME  - Name of the relation whose attributes are to be renamed.
   ATTRIBUTES     - Specify old-attribute and new-attribute names.

   Example: (RENAME-ATTRIBUTE 'parts 'number 'id 'name 'description).  (RENAME-ATTRIBUTE RELATION-NAME &REST ATTRIBUTES)BBl~SBLIST*BCRENAME-ATTRIBUTE*EVALP@PPPQQ@	PQQ
OB1\B\B\B8\B^BB\B8\B,Rename AttributeBBBBB\\ RBB,used to rename attributes in a relation.B\\BaBOther FeaturesB\B\B*Relation Name:BB~B\B,Name of the relation whose attributes are to be renamed.B\B*,Attributes and their new names:BB:B\BSpecify a list of the attributes and their new names. For ex. (a1 new-a1 a2 new-a2...)BB*Give parameters for RENAME ATTRIBUTE:BB\B8B\B\B8B\B8\B:BB
BBBBBBBBBBBBBBB\B^BRENAME-RELATION
@
F$B:Bd]FB:B:B:BFBjB"\BmBB:B:\B\pBlXR-BQ-CONSBBoBBlRename relations in the active database.

   RELATIONS - Specify <old-rel-name new-rel-name>

   Example: (RENAME-RELATION rel1 new-rel1 rel2 new-rel2)  (RENAME-RELATION &REST RELATIONS)BBl~SB#BRENAME-RELATION*BP@PPP]@P]	O3B"1\B\B\B8\B^BB#\B8\B,Rename RelationBB7BB7B\\BBBlused to rename relations in the current database.B\\BaBOther FeaturesB\B\B*Relations and their new names:BB:B\BlSpecify a list of the relations and their new names. For ex. (rel-1 new-rel-1 rel-2 new-rel-2...)BB*Give parameters for RENAME RELATION:BB0\B8B\B\B8B\B8\B:BB:BB7BB7BB;BB=BB>BBABB0B\B^BRENAME-DATABASE
@
F$B:Bd]FB:B:B:BFBjBM\BmBB:B:\B\B/BBoBBlUsed to rename a database.

   DATABASES - Specify old-database-name and new-database-name.

   Example: (RENAME-DATABASE parts suppliers micro-parts micro-suppliers).  (RENAME-DATABASE &REST DATABASES)BBl~SBNBRENAME-DATABASE*BP@PPP]@P]	O\BM1\B\B\B8\B^BBN\B8\B,Rename DatabaseBB`BB`B\\B@DBlused to rename databases.B\\BaBOther FeaturesB\B\B*Databases and their new names:BB:B\BSpecify a list of the databases and their new names. For ex. (db-1 new-db-1 db-2 new-db-2...)BB*Give parameters for RENAME DATABASE:BBY\B8B\B\B8B\B8\B:BBcBB`BB`BBdBBgBBhBBkBBYB\B^BDETACH-RELATION#AHF$B:Bd]FB:B:B:BFBjBw\BmBBBDISKB:\BB:\B\BBoBB1Detach data in an existing relation into a variable or onto the disk.

   RELATION-NAME - The name of the relation from which the data is to be detached.
   DISK          - If T, RTMS stores the data in the file specified in the PATHNAME.
   MEMORY        - If set to T, the detached data is stored in the variable rtms:*attach-detach-data*.
                   If any variable name is supplied, the data will be stored in it.
   PATHNAME      - Name of the file in which the detached data is to be saved.  (DETACH-RELATION RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DISK MEMORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBxBBBBBBxPAPPPQPQPQ	PQ
@
AQ@QOBw1\B\B\B8\B^BBx\B8\B,Detach RelationBBBBB\ DBlused to detach a relation.B\\BaBlDefinitionB\B\B*Relation Name:BB:B\BName of the relation to be Detached.B\B*lPathname:BBB\BSpecify the name of the file where the data is to be stored.B\B*,Memory:BB:B\BIf the data is to be in the memory and not save it on the disk, give the name of a variable.B\B*Disk:BB:B\B,Indicate if files corresponding to the relation are to be deleted from the disk.)BOOLEANB*Give parameters for DETACH RELATION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁINSERT-TUPLES#AHF$B:Bd]FB:B:B:BFBjB\BmÁRELATION-NAMEÁLIST-OF-TUPLESCATTRIBUTES*PATHNAMEB:\BB:\B\BBoBB$Insert a list of tuples or data from a file.

   RELATION-NAME   - Name of the relation into which the data is to be inserted.
   TUPLES     - List of tuples to be inserted. Tuples are expected to be in the list-of-values format.
   ATTRIBUTES - If the values in the tuples do not correspond to the attribute-list specified during
                relation-defintion, specify a list of attributes to determine the order.
   PATHNAME   - If the data is in a file, specify the name of the file.  (INSERT RELATION-NAME &REST KEYWORD-LIST &KEY TUPLES ATTRIBUTES PATHNAME &ALLOW-OTHER-KEYS)BBl~SÀINSERTÀTUPLESATTRBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\BInsert TuplesBBBBB\ IBUsed to insert a list of tuples in a given relation.B\\BaBlDefinitionB\B\B*Relation Name:BB~B\BSpecify the relation into which the tuples are to be inserted.B\B*,List of tuples:BBB\BGive a list of tuples to be inserted.B\B*Attributes:BB:B\BIf a list of attributes is provided, then values in the tuples are assumed to be in the same order.B\B*lPathname:BBB\BIf a list of tuples is not provided, then specify the file which contains the data.BB*Give parameters for INSERTING TUPLES:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMAPTUPLE@F$B:Bd]FB:B:B:BFBjB\BmBCDBFUNCTIONB:B:\B\BBoBBMap a function on all the tuples in a relation using MAPCAR.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation.  (MAPTUPLE DBFUNCTION RELATION)BBl~SBBBBBP@PPPQQ@Q	Q
OB1\B\B\B8\B^BB\B8\B,MaptupleBBBBB\\B MBMaps a given function on all the tuples in a relation using MAPCAR.B\\BaBOther FeaturesB\B\B*Relation Name:BB~B\B,Give the relation to be mapped.B\B*Function DefinitionBBB\BSpecify a function definition.BB*lMap a function on all tuples using MAPCAR:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMAPT@F$B:Bd]FB:B:B:BFBjB\BmBBB:B:\B\BBoBB,Map a function on all the tuples in a relation using MAPC.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation.  (MAPT DBFUNCTION RELATION)BBl~SBBBBBP@PPPQQ@Q	Q
O&B1\B\B\B8\B^BB\B8\B꬀MaptBB*BB*B\`FBlMaps a given function on all the tuples in a relation using MAPC.B\\BaBOther FeaturesB\B\B*Relation Name:BB~B\B,Give the relation to be mapped.B\B*Function DefinitionBBB\BSpecify a function definition.BB*,Map a function on all tuples using MAPC:BB$\B8B\B\B8B\B8\B:BB-BB*BB*BB.BB0BB1BB4BB$B\B^BÁPRINT-RELATIONPF6$B:Bd]FB:B:B:BFBjBD\BmBINTOBBBBBÀQPRINTTO-FILESORTB߃WIDENUMBERPRINTBÀQSORTSTREAMÀUNIQUEB:\BB:\B\BBoBBSame as Retrieve without a where clause and all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  (PRINT-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INDEX-NAME INTO KEY NUMBER OUTPUT PRINT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WIDE &ALLOW-OTHER-KEYS)iBBl~SBBBBNBOÁOUTPUT-TO-FILEBQBBRNUMBBTBCQUICK-SORTBVBWBBBBBPAPPPQPQ	PQ
PQP?BPQPQPQPQP
QPQPQPQPQPQPQPQPQ"J@AQ@QOaBD1\B\B\B8\B^BBE\B8\BPrint RelationBBeBBeB\\B PBUsed to print tuples in a relation.B\\BaBOther FeaturesB\B\B*lRelation: BB~B\BSpecify a relation whose tuples are to be retrieved.B\B*INTO :BBB\B,
Specify the relation to insert the resultant tuples into. If none specified, they are just printed out.BB\B*Documentation:BBB\BlSpecify the documentation for the output relation.B-BBB\B*lFormatted Output: BBB\BShould the tuples returned be formatted?. If no, tuples are printed in the interaction pane.B\B*Output File:BBB\BlIf the output is to be sent to a file, specify a pathname.B\B*Sort: BBB\BShould the output be sorted? Legal values are: (<attribute-name order>) - order could be ASC or DES.BB\B*Wide-Format :BBB\BShould the tuples be printed in wide format instead of tabular format? - Wide format will be of the type <attribute: value>.B\B*Number of attributes per line:BBB\B,How many attributes per line if the tuples are printed using wide format?. Default is -1 indicating as many tuples per line as possible.NUMBER\B*,Print?:BBB\BShould the results be printed or not?B\B*,Tuples:BB:B\BShould the results be returned as a list of tuples?B\B*Quick Sort:BB:B\BSimilar to sort except that it does not take user defined domains into consideration.B\B*,Stream:BB:B\BIf the output is to be sent to a stream other than the output window, specify the stream name.B\B*,Unique?:BB:B\BlIf only unique tuples are desired, then this must be true.BB*Give parameters for PRINT RELATION ==>BB[\B8B\B\B8B\B8\B:BBhBBeBBeBBiBBlBBmBBpBB[B\B^BÁLOAD-DATABASE	@F$B:Bd]FB:B:B:BFBjB\BmBjDIRECTORYB:B:\B\BBoBBlA database saved on the disk can be loaded using this function.

   DBNAME    - Name of the database to be restored.
   DIRECTORY - Name of the directory in which it can be found.  (LOAD-DATABASE DBNAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY &ALLOW-OTHER-KEYS)BBl~SBBBBBP@PPPQPQ	@QPQ
OB1\B\B\B8\B^BB\B8\BLoad DatabaseBBBBB\\ LBBUsed to load database from a given directory.B\\BaBlDefinitionB\B\B*Database Name:BBB\BlName of the database to be loaded.B\B*,Directory Name:BBB\BName of the directory in which it is stored.BB*lGive parameters for LOAD DATABASE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BLOAD-ENVIRONMENT	@F$B:Bd]FB:B:B:BFBjB\BmENVIRONMENTBB:B:\B\BBoBBlLoad a saved environment.

   ENVNAME   - Name of the environment to be restored.
   DIRECTORY - Name of the directory in which it can be found.  (LOAD-ENVIRONMENT ENVNAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY &ALLOW-OTHER-KEYS)BBl~SBBBBBP@PPPQPQ	@QPQ
OB1\B\B\B8\B^BB\B8\B,Load EnvironmentBBBBB\\BBeB,Used to load environment from a given directory.B\\BaBlDefinitionB\B\B*lEnvironment Name:BBB\BName of the environment to be loaded.B\B*,Directory Name:BBB\BName of the directory in which it is stored.BB*Give parameters for LOAD ENVIRONMENT:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁLOAD-RELATION	@F$B:Bd]FB:B:B:BFBjB\BmBBB:B:\B\BBoBBLoad a saved relation.

   RELATION-NAME    - Name of the relation to be restored.
   DIRECTORY        - Name of the directory in which it can be found.  (LOAD-RELATION RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB	BBBB	P@PPPQPQ	@QPQ
OB1\B\B\B8\B^BB	\B8\BLoad RelationBBBBB\\BBB,Used to load a relation from a given directory.B\\BaBlDefinitionB\B\B*Relation Name:BB~B\BlName of the relation to be loaded.B\B*,Directory Name:BBB\BName of the directory in which it is saved.BB*lGive parameters for LOAD RELATION:BB\B8B\B\B8B\B8\B:BBBBBBBBBB BB!BB$BBB\B^BÁSAVE-DATABASE	@F$B:Bd]FB:B:B:BFBjB4\BmBBB:B:\B\BBoBBlSave all system relations and the user-defined, modified relations.

   DATABASE-NAME    - Name of the database to be saved.
   DIRECTORY         - Name of the directory in which it is to be saved.  (SAVE-DATABASE DATABASE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB5BBBB5P@PPPQPQ	@QPQ
OBB41\B\B\B8\B^BB5\B8\BSave DatabaseBBFBBFB\\ SBfBUsed to save a database on a given directory.B\\BaBOther FeaturesB\B\B*Database Name:BBB\BlName of the database to be saved.B\B*,Directory Name:BBB\BlName of the directory to write to.BB*lGive parameters for SAVE DATABASE:BB@\B8B\B\B8B\B8\B:BBIBBFBBFBBJBBMBBNBBQBB@B\B^BSAVE-ENVIRONMENT	@F$B:Bd]FB:B:B:BFBjBa\BmBBB:B:\B\BBoBBSave an environment.

   ENVNAME   - Name of the environment to be saved.
   DIRECTORY - Name of the directory in which it is to be saved.  (SAVE-ENVIRONMENT ENVNAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY &ALLOW-OTHER-KEYS)BBl~SBbBBBBbP@PPPQPQ	@QPQ
OoBa1\B\B\B8\B^BBb\B8\B,Save EnvironmentBBsBBsB\\BLBeBlUsed to save an environment on a given directory.B\\BaBOther FeaturesB\B\B*lEnvironment Name:BB:B\BName of the environment to be saved.B\B*,Directory Name:BBB\BlName of the directory to write to.BB*Give parameters for SAVE environment:BBm\B8B\B\B8B\B8\B:BBvBBsBBsBBwBByBBzBB}BBmB\B^BÁSAVE-RELATION#AHF$B:Bd]FB:B:B:BFBjB
\BmBBTYPESAVEB:\BB:\B\BBoBB,Save a relation if it is modified.

    RELATION-NAME - Name of the relation to be saved.
    DIRECTORY     - Name of the directory in which it is to be saved.
    SAVE          - If T, saves the relation even if the relation is not modified.
    TYPE          - Two types of save are allowed: COMMAND and XLD. This keyword can be used to
                    specify the type.  (SAVE-RELATION RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY SAVE TYPE &ALLOW-OTHER-KEYS)BBl~SBBBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB
1\B\B\B8\B^BB\B8\BSave RelationBBBBB\\BLBBUsed to save a relation on a given directory.B\\BaBOther FeaturesB\B\B*Relation Name:BB~B\BlName of the relation to be saved.B\B*,Directory Name:BBB\BlName of the directory to write to.B\B*Type of SAVE:BBB\BSave type. It can be either XLD or COMMAND.B\B*lMust Save:BB:B\BSave the relation even if the relation has not been modified.BB*lGive parameters for SAVE RELATION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BSAVE-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjB\BmTRANSACTIONBBB:\BB:\B\BBoBBSave a transaction on disk.

   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction is to be stored.
   PATHNAME    - Name of the file in which it is to be stored.  (SAVE-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBBBBBBPAPPPQPQPQ	@	
AQ@QOB1\B\B\B8\B^BB\B8\B,Save TransactionBBBBB\\BLBB,Used to save a transaction on a given directory.B\\BaBOther FeaturesB\B\B*lTransaction Name:BBB\BName of the transaction to be saved.B\B*,Directory Name:BBB\BlName of the directory to write to.B\B*lPathname:BBB\B,
The name of the file into which the transaction forms will be stored. It defaults to <transaction>.lispBB*Give parameters for SAVE TRANSACTION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÂDEFINE-IMPLEMENTATION	@F$B:Bd]FB:B:B:BFBjB\BmÁIMPLEMENTATIONBB:\BB:\B\BBoBBDefine a new implementation.

   IMPLEMENTATION-NAME - Name of the implementation to be defined. All the implementation-specific
                         accessor functions are expected to be defined.
   DOCUMENTATION       - Description of this implementation.  (DEFINE-IMPLEMENTATION IMPLEMENTATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
OB1\B\B\B8\B^BB\B8\BDefine ImplementationBB
BB
B\\BBBlUsed to define an implementation.B\\BaBlDefinitionB\B\B*Implementation Name:BB:B\BName of the implementation. Implementation-dependent routines are expected to be defined by the user.B\B*Documentation:BBB\BDocumentation for the implementation.B-B*lGive parameters for DEFINE IMPLEMENTATION:BB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BDEFINE-INDEX)AF$B:Bd]FB:B:B:BFBjB$\BmBCINDEX-NAMEÁKEY-ATTRIBUTESCSTORAGE-STRUCTUREPRIORITYBB:\BB:\B\BBoBB쿖Define an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index will be defined.
    NAME - Name of the index to be defined
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index.  (DEFINE-INDEX RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL NAME DOCUMENTATION STORAGE-STRUCTURE KEY PRIORITY &ALLOW-OTHER-KEYS)BBl~SB%NAMEBBB1BBBB%PAPPPQPQPQ	PQ
PQPQ
J@AQ@QO8B$1\B\B\B8\B^BB%\B8\BꬁDefine IndexBB<BB<B\\B@IB,Used to define a secondary index on a relation.B\\BaBlDefinitionB\	B\B*Relation Name:BB:B\BlName of the relation upon which the index will be defined.B\B*Index Name:BB:B\B,Name of the index to be defined.B-\B*,Key Attributes:BB:B\BlList of attribute names which form the key for this index.B\B*lStorage Structure:BAVLB\B,The storage structure used to define the index.B-\B*lPriority:BF
B\BA numerical value which indicates the priority given to this index. 1 is the highest priority.B\B*Documentation:BBB\BDocumentation for the index.B-B*lGive parameters for DEFINE INDEX:BB5\B8B\B\B8B\B8\B:BB?BB<BB<BB@BBCBBDBBGBB5B\B^BMODIFY-INDEX+BF$B:Bd]FB:B:B:BFBjBi\BmBB.ÁNEW-INDEX-NAMEB/B0B1BB:\BB:\B\BBoBB쿽Modify an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index to be modified is defined
    INDEX-NAME - Name of the index to be modified
    NEW-NAME - New name for the specified index
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index.  (MODIFY-INDEX RELATION-NAME INDEX-NAME &REST KEYWORD-LIST &KEY &OPTIONAL NEW-NAME DOCUMENTATION STORAGE-STRUCTURE KEY PRIORITY &ALLOW-OTHER-KEYS)BBl~SBjNEW-NAMEBBB1BBBBjPAPPPQQPQPQ	PQ
PQPQ
J@AQQ@QOzBi1\B\B\B8\B^BBj\B8\BꬁModify IndexBB~BB~B\\BBBB,Used to define a secondary index on a relation.B\\BaBManipulationB\
B\B*Relation Name:BB:B\BName of the relation upon which the index to be modified is defined.B\B*Index Name:BB:B\BlName of the index to be modified.B-\B*,New Index Name:BB:B\BNew name of the index.B-\B*,Key Attributes:BB:B\BlList of attribute names which form the key for this index.B\B*lStorage Structure:BB:B\B,The storage structure used to define the index.B-\B*lPriority:BF
B\BA numerical value which indicates the priority given to this index. 1 is the highest priority.B\B*Documentation:BBB\BDocumentation for the index.B-B*lGive parameters for DEFINE INDEX:BBw\B8B\B\B8B\B8\B:BBBB~BB~BBBBBBBBBBwB\B^BDEFINE-STORAGE-STRUCTURE	@F$B:Bd]FB:B:B:BFBjB\BmB0BB:\BB:\B\BBoBB,Define a new storage structure.

   STORAGE-STRUCTURE-NAME - Name of the storage-structure to be defined. All the storage-structure-specific
                            accessor functions are expected to be defined.
   DOCUMENTATION          - Description of this storage-structure.  (DEFINE-STORAGE-STRUCTURE STORAGE-STRUCTURE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
OB1\B\B\B8\B^BB\B8\B,Define Storage StructureBBBBB\\BBLBlUsed to define a storagestructure.B\\BaBlDefinitionB\B\B*,Storage structure name:BB:B\B
Name of the storage structure. Storage-structure-dependent routines are expected to be defined by the user.B\B*Documentation:BB:B\B,Documentation for the storage structure.B-B*Give parameters for DEFINE STORAGE STRUCTURE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁDEFINE-DOMAIN#AHF$B:Bd]FB:B:B:BFBjB\BmÀDOMAINpBuDEFBBB:\BB:\B\BBoBBDefine new domain. Corresponding predicate is expected to be defined prior to this operation.

   DOMAIN-NAME     - Name of the domain to be defined.
   DOCUMENTATION   - Describes the new domain.
   FORMAT          - Print width for attributes belonging to this domain.  (DEFINE-DOMAIN DOMAIN-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DEFAULT DOCUMENTATION FORMAT &ALLOW-OTHER-KEYS)BBl~SBDEFAULTBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\BDefine DomainBBBBB\`DB,Used to define a domain.B\\BaBlDefinitionB\B\B*Domain Name:BB:B\BName of the domain. Domain predicate is expected to be defined prior to this.B\B*Default value:BB:B\BDefault value for this domain.B\B*Documentation:BB:B\BDocumentation for the domain.B-\B*,Default width :BB:B\BThe default width to be used for this domain.BB*lGive parameters for DEFINE DOMAIN:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁMODIFY-DOMAIN#AHF$B:Bd]FB:B:B:BFBjB\BmBBBBB:\BB:\B\BBoBBlModify the default format, value, and documentation of a domain.

   DOMAIN-NAME - Name of the domain to be modified.
   FORMAT      - New format, i.e the print width, for this domain.
   DEFAULT     - New default value for this domain.
   DOC         - New description of this domain.  (MODIFY-DOMAIN DOMAIN-NAME &REST KEYWORD-LIST &KEY &OPTIONAL FORMAT DEFAULT DOC &ALLOW-OTHER-KEYS)BBl~SBBBBBBBPAPPPQPQPQ	PQ
@
AQ@QO"B1\B\B\B8\B^BB\B8\BModify DomainBB&BB&B\\BBB,Used to modify a domain.B\\BaBManipulationB\B\B*Domain Name:BB:B\BlName of the domain to be modified.B\B*Default value:BB:B\BlNew default value for this domain.B\B*Documentation:BB:B\BlNew documentation for the domain.B-\B*,Default width :BB:B\BlThe new default width to be used for this domain.BB*lGive parameters for MODIFY DOMAIN:BB \B8B\B\B8B\B8\B:BB)BB&BB&BB*BB,BB-BB0BB B\B^BCDEFINE-TRANSACTION"AHF$B:Bd]FB:B:B:BFBjBH\BmBÀFORMSBBB:\BB:\B\BBoBBDefine a transaction, a list of database calls.

   TRANSACTION - Name of the transaction.
   FORMS       - List of RTMS calls.
   DIRECTORY   - Name of the directory in which this transaction will be stored.
   PATHNAME    - Name of the file in which it will be stored.  (DEFINE-TRANSACTION TRANSACTION FORMS &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBIBBBBBIPAPPPQQPQPQ	@	
AQQ@QOXBH1\B\B\B8\B^BBI\B8\BlDefine TransactionBB\BB\B\\BBBUsed to define a transaction.B\\BaBlDefinitionB\B\B*lTransaction Name:BBB\B,Name of the transaction.B\B*,Database calls:BB:B\BlA list of database calls.BB\B*lPathname :BBB\BThe default file in which it will be saved.BB*,Give parameters for DEFINE TRANSACTION:BBV\B8B\B\B8B\B8\B:BB_BB\BB\BB`BBbBBcBBfBBVB\B^BCMODIFY-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjBz\BmBBBB:\BB:\B\BBoBBEdit the database calls in a transaction.
   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction can be found.
   PATHNAME    - Name of the file in which it is stored.  (MODIFY-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SB{BBBBB{PAPPPQPQPQ	@	
AQ@QOBz1\B\B\B8\B^BB{\B8\BlModify TransactionBB
BB
B\\BBBUsed to modify a transaction.B\\BaBManipulationB\B\B*lTransaction Name:BBB\B,Name of the transaction to be modified.B\B*lDirectory:BBB\BDefault directory in which it can be found, if not in memory.B\B*lPathname :BBB\BThe default file in which it can be found, if not in memory.BB*,Give parameters for MODIFY TRANSACTION:BB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BDEFINE-DATABASE#AHF$B:Bd]FB:B:B:BFBjB\BmBBBENVB:\BB:\B\BBoBBDefine a new database.

   DB-NAME     - Name of the database.
   DIRECTORY   - Name of the directory in which this database is to be saved.
   ENVIRONMENT - Name of the environment to be associated with this database.
   DOCUMENTATION - A string describing this database.  (DEFINE-DATABASE DB-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY ENVIRONMENT DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SÀDEFDBBBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\B,Define DatabaseBBBBB\\BBB,Used to define a database in a given directory.B\\BaBlDefinitionB\B\B*Database Name:BB:B\BName of the database.B\B*,Directory Name:BBB\BName of the save directory for this database.B\B*Documentation:BBB\B,Documentation for the database.B-\B*Environment:BB:B\BName of the environment to be used to replace the default settings.BB*Give parameters for DEFINE DATABASE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMODIFY-DATABASE#AHF$B:Bd]FB:B:B:BFBjB\BmBNEW-DATABASEBBB:\BB:\B\BBoBB,Modify various features of the active database.

  DATABASE      - Name of the database to be modified.
  DATABASE-NAME - New name for this database.
  DIRECTORY     - New directory in which this database is to be saved.
  DOCUMENTATION - New description for this database.  (MODIFY-DATABASE DATABASE &REST KEYWORD-LIST &KEY &OPTIONAL DATABASE-NAME DIRECTORY DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBÁDATABASE-NAMEBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\B,Modify DatabaseBBBBB\\BBfB,Used to modify the features a database.B\\BaBManipulationB\B\B*Database Name:BB:B\BName of the database.B\B*lNew Database Name:BB:B\BIf the database is to be renamed specify the new name.B\B*,Directory Name:BB:B\B,To change the save directory for this database specify a new directory.B\B*Documentation:BB:B\BNew documentation for the database.B-B*Give parameters for MODIFY DATABASE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBB	BBB\B^BMODIFY-ATTRIBUTE(AF$B:Bd]FB:B:B:BFBjB	\BmBBNEW-ATTRBBBB:\BB:\B\BBoBBModify various features of an attribute in a given relation.

  RELATION       - Name of the relation in which the attribute to be modified exists.
  ATTRIBUTE      - Name of the attribute to be modified.
  ATTRIBUTE-NAME - New name for this attribute.
  DEFAULT-VALUE  - New default value for this attribute.
  DOCUMENTATION  - New description.
  FORMAT         - New print width to be used for this attribute.  (MODIFY-ATTRIBUTE RELATION ATTRIBUTE &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE-NAME DEFAULT-VALUE DOCUMENTATION FORMAT &ALLOW-OTHER-KEYS)BBl~SB	ÁATTRIBUTE-NAMEBBBBBB	PAPPPQQPQPQ	PQ
PQJ@AQQ@QO*	B	1\B\B\B8\B^BB	\B8\B,Modify AttributeBB.	BB.	B\\BBB,Used to modify the features a attribute.B\\BaBManipulationB\	B\B*Relation Name:BB~B\BName of the relation.B\B*,Attribute Name:BB:B\BName of the attribute.B\B*New Attribute Name:BB:B\B,If the attribute is to be renamed specify the new name.B\B*Default Value:BB:B\BlTo change the default value of this attribute specify a new value.B\B*Documentation:BB:B\BNew documentation for the attribute.B-\B*,Default width :BB:B\BThe new default width to be used for this attribute.BB*Give parameters for MODIFY ATTRIBUTE:BB'	\B8B\B\B8B\B8\B:BB1	BB.	BB.	BB2	BB4	BB5	BB8	BB'	B\B^BMODIFY-VIEW
 AF$B:Bd]FB:B:B:BFBjBX	\BmVIEWBBB:\BB:\B\BBoBBModify a view definition or its documentation.

   VIEW-NAME       - Name of the view.
   VIEW-DEFINITION - New definition of the view.
   VIEW-DOCUMENTATION - New description of the view.  (MODIFY-VIEW VIEW-NAME &REST KEYWORD-LIST &KEY &OPTIONAL VIEW-DEFINITION VIEW-DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBY	VIEW-DEFVIEW-DOCBBBY	PAPPPQPQPQ	@	
AQ@QOj	BX	1\B\B\B8\B^BBY	\B8\BꬁModify ViewBBn	BBn	B\\B VBUsed to modify the features a view.B\\BaBManipulationB\B\B*lView Name:BB:B\BlName of the view.B\B*,View Definition:BB:B\BNew definition of the view.B\B*Documentation:BB:B\B,New documentation for the view.B-B*,Give parameters for MODIFY VIEW:BBf	\B8B\B\B8B\B8\B:BBq	BBn	BBn	BBr	BBu	BBv	BBy	BBf	B\B^BMODIFY-RELATION8CF&$B:Bd]FB:B:B:BFBjB
	\BmRELNEW-RELADD-ATTDEL-ATTREN-ATTBBBBBBB:\BB:\B\BBoBBModify various features of a relation.

  RELATION             - Name of the relation to be modified.
  RELATION-NAME        - New name for this relation.
  ADD-ATTRIBUTES       - List of new attributes and their description.
  DELETE-ATTRIBUTES    - List of attributes to be destroyed.
  RENAME-ATTRIBUTES    - List of list of OLD-NEW attribute names.
  IMPLEMENTATION-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved.  (MODIFY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL RELATION-NAME ADD-ATTRIBUTES DELETE-ATTRIBUTES RENAME-ATTRIBUTES IMPLEMENTATION-TYPE STORAGE-STRUCTURE FORMAT KEY DOCUMENTATION DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB	BÁADD-ATTRIBUTESCDELETE-ATTRIBUTESCRENAME-ATTRIBUTESBBBBBBBBB	PAPPPQPQPQ	PQ
PQPQPQPQPQPQPQJ@AQ@QO	B
	1\B\B\B8\B^BB	\B8\B,Modify RelationBB	BB	B\\BBB,Used to modify the features a relation.B\\BaBManipulationB\B\B*Relation Name:BB~B\BName of the Relation.B\B*lNew Relation Name:BB:B\BIf the relation is to be renamed specify the new name.B\B*,Add attributes:BB:B\BlSpecify a list of attribute-descriptor pairs for attributes to be added to this relation.B\B*lDelete attributes:BB:B\BSpecify a list of attributes in this relation which are to be deleted.B\B*lRename attributes:BB:B\BTo rename some of the attributes provide a list of the form (<old-attribute new-attribute>).B\B*Implementation Type:BB:B\B,To change the implementation type of this relation specify a new value.B\B*lStorage structure:BB:B\BTo change the storage structure of this relation specify a new value.B\B*,Format:BB:B\B,To change the format for this relation specify a new format as a list of values.B\B*Key:BB:B\BTo change the key for this relation specify a new key as a list of attributes.B\B*,Directory Name:BB:B\B,To change the save directory for this relation specify a new directory.B\B*Documentation:BB:B\BNew documentation for the relation.B-B*Give parameters for MODIFY RELATION:BB	\B8B\B\B8B\B8\B:BB	BB	BB	BB	BB	BB	BB	BB	B\B^BCDEFINE-ENVIRONMENTRCHF4$B:Bd]FB:B:B:BFBjB	\BmBBBERRCPAR-CHECKREL-IMPREL-STOÀSTATUSSYS-IMPSYS-STOCVAL-CHECKWARNB:\BB:\B\BBoBB쿶Global variables defining an environment can be set using this function.

   ENVIRONMENT  - Name of the environment.
   AUTO-SAVE    - If T, RTMS saves the database whenever a relation is modified.
   DIRECTORY    - Name of the default directory in which the database is to be saved.
   ERRORS       - If T, error messages are generated.
   PARAMETER-CHECKING - If T, extensive parameter validity checking is done.
   RELATION-IMPLEMENTATION - The default implementation type for the user relations.
   RELATION-STORAGE-STRUCTURE -The default storage structure type for the user relations.
   STATUS       - If T, status messages are generated.
   SYSTEM-IMPLEMENTATION - If there is no active database, this value will be used as the implementation
                           type for implementing system-relations.
   SYSTEM-STORAGE-STRUCTURE - If there is no active database, this value will be used as the storage structure
                              for implementing system-relations.
   VALIDITY     - If T, extensive validity checking is done for user-supplied data.
   WARNINGS     - If T, warning messages are generated.  (DEFINE-ENVIRONMENT ENVIRONMENT &REST KEYWORD-LIST &KEY &OPTIONAL AUTO-SAVE DIRECTORY ERRORS PARAMETER-CHECKING RELATION-IMPLEMENTATION RELATION-STORAGE-STRUCTURE STATUS SYSTEM-IMPLEMENTATION SYSTEM-STORAGE-STRUCTURE VALIDITY WARNINGS &ALLOW-OTHER-KEYS)BBBl~SÀDEFENVCAUTO-SAVEPARABB	B	ÀERRORSB	VALIDITYWARNINGSB	B	BBB	PAPPPQPQ	PQ
PQPQPQPQPQPQPQJPQ	PQ
PQPQPQPQPQPQPQPQPQJ@AQ@QO
B	1\B\B\B8\B^BB	\B8\BlDefine EnvironmentBB
BB
B\\BBeBUsed to define an environment in a given directory.B\\BaBlDefinitionB\B\B*lEnvironment Name:BB:B\B,Name of the environment.B\B*lAuto save:BB:B\BAutomatically saves all the modified relations after each function.BB\B*,Errors:BBB\BControls the printing of the error messages.B\B*Parameter Checking:BBB\B,Controls the checking of the parameters.B\B*,Relation Implementation:BBB\BDefault implementation of the user relations.B\B*Relation storage structure:BBB\BlDefault storage structure for the user relations.B\B*,Status:BBB\BControls the printing of the status messages.B\B*System Implementation:BB:B\BDefault implementation of the system relations. Can not change this when a database is active.B\B*lSystem storage structure:BB:B\BlDefault storage structure for the system relations. Can not change this when a database is active.B\B*lValidity Checking:BBB\BControls the checking of the values during insertion and modification for validity.B\B*lWarnings:BBB\BControls the printing of the warning messages.BB*,Give parameters for DEFINE ENVIRONMENT:BB	\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB	B\B^BDEFINE-RELATION.BHF$B:Bd]FB:B:B:BFBjBF
\	BmBATTR-DESBBBBBBB:\BB:\B\BBoBB쿊Define relations in the active database.

   RELATION-NAME - Name of the relation to be defined.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   DIRECTORY     - Name of the directory in which this relation is to be saved.
   DOCUMENTATION - Description of this relation.
   FORMAT        - List of print-width values correponding to the attribute-list.
   IMPLEMENTATION-TYPE - Name of the implementation for this relation.
   KEY           - List of attributes comprising the key for this relation.
   STORAGE-STRUCTURE   - Name of the storage structure to be used for this relation.  (DEFINE-RELATION RELATION-NAME ATTRIBUTE-DESCRIPTOR &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE KEY STORAGE-STRUCTURE &ALLOW-OTHER-KEYS)BBl~SÀDEFRELTUPLE-FORMATBBBBBBBBV
PAPPPQQPQPQ	PQ
PQPQPQJ@AQQ@QOX
BF
1\B\B\B8\B^BBG
\B8\B,Define RelationBB\
BB\
B\\BBBlused to define a relation.B\\BaBlDefinitionB\B\B*Relation Name:BB:B\BName of the relation to be defined.BBBBBBBBB*Give parameters for DEFINE RELATION:BBT
\B8B\B\B8B\B8\B:BB_
BB\
BB\
BB`
BBb
BBc
BBf
BBT
B\B^BDEFINE-VIEW
A
F$B:Bd]FB:B:B:BFBjBr
\BmVIEWNAMEVIEW-DEFINITIONBB:B:\B\BBoBBlDefine views on the relations.

   VIEW-NAME - Name of the view.
   VIEW-DEF  - Definition of the view.
   DOCUMENTATION - Describes the view.  (DEFINE-VIEW VIEWNAME VIEW-DEF &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SDEFVIEWBBB
P@PPPQQQ@QQQ	O
Br
1\B\B\B8\B^BBs
\B8\BꬁDefine ViewBB
BB
B\\BBt	BUsed to define a view.B\\BaBlDefinitionB\B\B*lView Name:BB:B\BSpecify a name for the view.B\B*,View Definition:BBB\BlSpecify a definition for the view.B\B*View Documentation:BB:B\BSpecify documentation for the view.BB*,Give parameters for DEFINE VIEW:BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB

BB
BB
BB
B\B^BDEFINE-ATTRIBUTE
AF$B:Bd]FB:B:B:BFBjB
\BmBBP
BB:\BB:\B\BBoBBAdd a new attribute to a relation.
    All its tuples will get the default value of the attribute for the attribute value.

   RELATION-NAME - Name of the relation.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   KEY           - If the key for this relation is to be changed, specify it.  (DEFINE-ATTRIBUTE RELATION-NAME ATTRIBUTE-DESCRIPTOR &REST KEYWORD-LIST &KEY &OPTIONAL KEY &ALLOW-OTHER-KEYS)BBl~SB
BBBB
PAPPPQQPQ@	AQQ@Q
O
B
1\B\B\B8\B^BB
\B8\B,Define AttributeBB
BB
B\\BBBUsed to add attributes to relations.B\\BaBlDefinitionB\B\B*,Relation name: BB~B\BlThe name of the relation to which new attributes are to be added.BB\B*Key: BB:B\B,
New key for the relation if it is to be different from the previous value. Specify a list of attributes.BB*Give parameters for DEFINE ATTRIBUTE:BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB
B\B^BÁMODIFY-TUPLES#AHF$B:Bd]FB:B:B:BFBjB
\BmBWHERE-CLAUSEBVALUESB:\BB:\B\BBoBBlThe values of the tuples in a relation can be modified using this function.

   RELATION  - Name of the relation whose tuples are to be modified.
   ATTRIBUTE - List of attributes which are to be modified.
   VALUE     - Corresponding list of values to be used in modifying the above attributes.
   WHERE     - Selection criterion to be used.  (MODIFY-TUPLES RELATION &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE VALUE WHERE &ALLOW-OTHER-KEYS)BBl~SÀMODIFYÀWHEREBB
BBB
PAPPPQPQPQ	PQ
@
AQ@QO
B
1\B\B\B8\B^BB
\B8\BModify TuplesBB
BB
B\\B@MBUsed to modify tuples in a relation.B\\BaBManipulationB\B\B*lRelation: BB~B\BSpecify the relation whose tuples are to be modified.B\B*Where clause: BBB\BProvide a selection criteria.B\B*Attributes: BBB\BlSpecify a list of attributes in the above relation to be modified.B\B*,Values: BBB\BSpecify a corresponding list of values to modify the above attributes.BB*Give parameters for MODIFY TUPLES ==>BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB
B\B^BÁDELETE-TUPLES	@F$B:Bd]FB:B:B:BFBjB\BmBB
B:B:\B\BBoBBDeletes the tuples which satisfy the WHERE clause from the specified relation.

   RELATION - Name of the relation from which the tuples are to be deleted.
   WHERE    - Selection criterion to be used.  (DELETE-TUPLES RELATION &REST KEYWORD-LIST &KEY &OPTIONAL WHERE &ALLOW-OTHER-KEYS)BBl~SBB
BBBP@PPPQPQ	@QPQ
OB1\B\B\B8\B^BB\B8\BDelete TuplesBBBBB\BfBUsed to delete tuples in a relation.B\\BaBManipulationB\B\B*lRelation: BB~B\BlSpecify a relation whose tuples are to be deleted.B\B*Where clause: BB:B\B,Deletes the tuples which satisfy this condition.BB*Give parameters for DELETE TUPLES ==>BB\B8B\B\B8B\B8\B:BB!BBBBBB"BB#BB$BB'BBB\B^BRETRIEVE-TUPLES]F>$B:Bd]FB:B:B:BFBjB7\BmBBB
BNBBBBBBOBPBQBBRBSBTBBUBVBWB.B:\BB:\B\BBoBBORetrieve some tuples from a relation satisying a where clause.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.   (RETRIEVE RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INDEX-NAME INTO KEY NUMBER OUTPUT PRINT PROJECT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WHERE WIDE &ALLOW-OTHER-KEYS)ˀBBl~SBPROJECTB
BNBBBBBBOB^BQBBRB_BTBB`BVBWB.BBBPAPPPQPQQ	PQ
PQPQPQPQPQPQP?BPQPQP
QPQPQPQPQPQPQPQPQ(J@AQ@QOHB71\B\B\B8\B^BB8\B8\B,Retrieve TuplesBBLBBLB\@RBUsed to Retrieve tuples in a relation.B\\BaBlOperatorsB\BBq\B*Attributes: BB:B\BProvide a list of attributes. If not all attributes all used.BB
BuBByBBBB}BBBBB
BBBBB\B*Index-name:BB:B\BlIf the data is to come from an index instead of the base relation.BB*,Give parameters for RETRIEVE TUPLES ==>BBD\B8B\B\B8B\B8\B:BBOBBLBBLBBPBBRBBSBBVBBDB\B^BpBuSELECT Z F=$B:Bd]FB:B:B:BFBjBf\BmBB
BNBBBBBBOBPBQBBRBSBTBBUBVBWB.B:\BB:\B\BBoBBSame as Retrieve except that all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  (SELECT-TUPLES RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INTO KEY NUMBER OUTPUT PRINT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WHERE WIDE &ALLOW-OTHER-KEYS)BBl~SÁSELECT-TUPLESB
BNBBBBBBOB^BQBBRB_BTBB`BVBWB.BBBGBBPAPPPQPQ	PQ
PQPQPQPQPQP?BPQPQPQP
QPQPQPQPQPQPQPQ&J@AQP@QOxBf1\B\B\B8\B^BBh\B8\BSelectBB|BB|B\\BBLBUsed to Select tuples in a relation.B\\BaBlOperatorsB\BBqB
BuBByBBBB}BBBBB
BBBBBB[B*Give parameters for SELECT TUPLES ==>BBt\B8B\B\B8B\B8\B:BBBB|BB|BBBBBBBBBBtB\B^BBG\F=$B:Bd]FB:B:B:BFBjB\BmBBBNBBBBBBOBPBQBBRBSBTBBUBVBWB:\BB:\B\BBoBB#Same as Retrieve except that all tuples are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  (PROJECT RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INDEX-NAME INTO KEY NUMBER OUTPUT PRINT PROJECT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WIDE &ALLOW-OTHER-KEYS)BBl~SBGBNBBBBBBOB^BQBBRB_BTBB`BVBWBBB
BBPAPPPQPQQPQ	PQ
PQPQPQPQP?BPQPQPQP
QPQPQPQPQPQPQ$J@AQP@QOB1\B\B\B8\B^BBG\B8\B,ProjectBBBBB\\BBkBUsed to Project tuples in a relation.B\\BaBlOperatorsB\BBqBWBuBByBBBB}BBBBB
BBBBBB*Give parameters for PROJECT TUPLES ==>BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BCCOMMIT-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjB\BmÀTRANSBBB:\BB:\B\BBoBBExecute the database calls in a transaction.

   TRANSACTION - Name of the transaction to be commited.
   DIRECTORY   - Name of the directory in which this transaction can be found, if not in memory.
   PATHNAME    - Name of the file in which it can be found.  (COMMIT-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBBBBBBPAPPPQPQPQ	@	
AQ@QOB1\B\B\B8\B^BB\B8\BlCommit TransactionBBBBB\\B CBCommit a transaction - execute all the database calls in it.B\\BaBlOperatorsB\B\B*lName of the transaction :BBB\BThe name of an existing transaction.B\B*Name of the directory:BBB\BName of the directory which contains the transaction file, if the transaction is not in the memory.B\B*lPathname:BBB\BIf the transaction is not in memory, provide the pathname for the transaction file. It defaults to <transaction>.lisp.BB*Give parameters for COMMIT TRANSACTIONBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BJOINDCF.$B:Bd]FB:B:B:BFBjB\BmBNFROMBGB
BBBBBBBBTBWB:\BB:\B\BBoBB3This function provides the capability to combine two relations into a new relation
   in which the tuples which are to participate in the operation are selected
   by a where clause.

   FROM                 - A list consisting of the relations to be joined.
   PROJECT              - This clause specifies the attributes that are to be in the resultant relation
                          and their associated names in that new relation. It should be of the form
                          (<[relation-name.]attribute-name>). The optional part relation-name can be
                          skipped if the attribute is unique in one of the two relations being joined.
                          If the keyword FROM is not specified, this clause should contain the names
                          of the relations to be joined. Also, if * is given instead of the attribute-name
                          it indicates that RTMS should use all the attributes in that relation.
   WHERE                - Can be used to perform theta-joins. It is a condition used in joining the relations.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (JOIN &REST KEYWORD-LIST &KEY FROM &KEY &OPTIONAL PROJECT WHERE INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE KEY STORAGE-STRUCTURE PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SBBBGBNBBBBBBBBTB
BWBBBÁJOIN-INTERNALPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQPQP
QJ@APQ@QOB1\B\B\B8\B^BB\B8\B꬀JoinBBBBB\ JB,Used to join relations.B\\BaBlOperatorsB\B\B*lOutput relation :BBB\BIf not provided, the result of JOIN is stored in a temporary relation unless only the resultant tuples are requested.B\B*FROM :BBB\BSpecify a list of two relations to be joined.B\B*lProject :BB:B\B,This gives the attributes in the output relation. Example: (rel1.* a3 (rel2.a1 a4)) ==> All the attributes in rel1, attribute A3 of rel2 and atribute A1 of rel2 renamed as A4.B\B*,Where :BBB\BlThe join clause using the theta-operators. It is a where clause consisting of attributes from the relations being joined.B\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*,Give parameters for JOINBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BDESTROY-DATABASE	@F$B:Bd]FB:B:B:BFBjB!\BmBBB:\BB:\B\BBoBB,Delete the specified database from memory and all the corresponding files from
   disk if the keyword DISK is T.

   DATABASE - Name of the database to be destroyed.
   DISK     - If T, all the relevant files will be deleted.  (DESTROY-DATABASE DATABASE &REST KEYWORD-LIST &KEY &OPTIONAL DISK &ALLOW-OTHER-KEYS)BBl~SB"BBBB"PAPPPQPQ@	AQ@Q
O0B!1\B\B\B8\B^BB"\B8\B,Destroy DatabaseBB4BB4B\\ KBBlUsed to destroy databasesB\\BaBManipulationB\B\B*Database Name:BB:B\BName of the database to be destroyed.B\B*Delete from the DISK:BB:B\BIF YES all the files pertaining to this database are deleted but NOT EXPUNGED.BB*Give parameters for DESTROY DATABASE:BB.\B8B\B\B8B\B8\B:BB7BB4BB4BB8BB;BB<BB?BB.B\B^BÁDESTROY-DOMAIN
@
F$B:Bd]FB:B:B:BFBjBO\BmBB:B:\B\BBoBBDestroys the domain definition but keeps the domain predicate to handle previously defined data.  (DESTROY-DOMAIN DOMAIN-NAME)BBl~SBPBBBPP@PPPQ@Q	O]BO1\B\B\B8\B^BBP\B8\BDestroy DomainBBaBBaB\`KB,Used to destroy domains.B\\BaBManipulationB\B\B*Domain Name:BB:B\BName of the domain to be destroyed.BB*Give parameters for DESTROY DOMAIN:BB[\B8B\B\B8B\B8\B:BBdBBaBBaBBeBBgBBhBBkBB[B\B^BÂDESTROY-IMPLEMENTATION
@
F$B:Bd]FB:B:B:BFBjBw\BmBB:B:\B\BBoBB,Destroys implementation type definition but keeps the accessor functions to handle previously defined relations using this implementation.  (DESTROY-IMPLEMENTATION IMPLEMENTATION-NAME)BBl~SBxBBBxP@PPPQ@Q	OBw1\B\B\B8\B^BBx\B8\BDestroy ImplementationBBBBB\\B:BB,Used to destroy implementations.B\\BaBManipulationB\B\B*Implementation Name:BB:B\BName of the implementation to be destroyed.BB*Give parameters for DESTROY IMPLEMENTATION:BB\B8B\B\B8B\B8\B:BBBBBBBB
BBBBBBBBB\B^BÁDESTROY-INDEX
@
F$B:Bd]FB:B:B:BFBjB\BmBB.B:B:\B\BBoBB,Destroy the specified index which is defined on the specified relation.

   RELATION-NAME - The name of the relation upon which the relation is defined.
   INDEX-NAME - The name of the index to be deleted.  (DESTROY-INDEX RELATION-NAME INDEX-NAME)BBl~SBBBBP@PPPQQ@QQ	OB1\B\B\B8\B^BB\B8\BDestroy IndexBBBBB\\B:BBB,Used to destroy indices.B\\BaBManipulationB\B\B*Relation Name:BB:B\BName of the relation on which the index to be destroyed is defined.B\B*Index Name:BB:B\BlName of the index to be destroyed.BB*lGive parameters for DESTROY INDEX:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BCDESTROY-STORAGE-STRUCTURE
@
F$B:Bd]FB:B:B:BFBjB\BmB0B:B:\B\BBoBB,Destroys storage structure definition but keeps the accessor functions to handle previously defined relations using this structure.  (DESTROY-STORAGE-STRUCTURE STORAGE-STRUCTURE-NAME)BBl~SBBBBP@PPPQ@Q	OB1\B\B\B8\B^BB\B8\BlDestroy Storage StructureBBBBB\\B:BLBUsed to destroy storage structures.B\\BaBManipulationB\B\B*,Storage structure name:BB:B\BName of the storage structure to be destroyed.BB*Give parameters for DESTROY STORAGE STRUCTURE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BDESTROY-VIEW
@
F$B:Bd]FB:B:B:BFBjB\BmBb	B:B:\B\BBoBB,Destroys the view from memory.  (DESTROY-VIEW VIEW-NAME)BBl~SBBBBP@PPPQ@Q	OB1\B\B\B8\B^BB\B8\BꬁDestroy ViewBBBBB\\B:Bt	BUsed to destroy views.B\\BaBManipulationB\B\B*lView name:BB:B\BlName of the view to be destroyed.BB*lGive parameters for DESTROY VIEW:BB\B8B\B\B8B\B8\B:BBBBBBBB	BBBBBBBBB\B^BDESTROY-RELATION	@F$B:Bd]FB:B:B:BFBjB\BmBBB:\BB:\B\BBoBBlDeletes the specified relation from the active database.
   Deletes all the files on disk if keyword DISK is t.

   RELATION - Name of the relation to be destroyed.
   DISK     - If T, the relevant files will be deleted.  (DESTROY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL DISK &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
O*B1\B\B\B8\B^BB\B8\B,Destroy RelationBB.BB.B\\B:BBlUsed to destroy relationsB\\BaBManipulationB\B\B*Relation Name:BB:B\BName of the relation to be destroyed.B\B*Delete from the DISK:BB:B\BIF YES the file corresponding to this relation is deleted but NOT EXPUNGED.BB*Give parameters for DESTROY RELATION:BB(\B8B\B\B8B\B8\B:BB1BB.BB.BB2BB4BB5BB8BB(B\B^BCDESTROY-ATTRIBUTE
 AF$B:Bd]FB:B:B:BFBjBH\BmBBBB:\BB:\B\BBoBB,Attributes in a relation can be deleted using this function.

   RELATION-NAME - Name of the relation from which the attributes are to be deleted.
   ATTRIBUTE     - List of attributes to be destroyed.
   KEY           - List of attributes to form the new key, if so desired.  (DESTROY-ATTRIBUTE RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE KEY &ALLOW-OTHER-KEYS)BBl~SBIBBBBBIPAPPPQPQPQ	@	
AQ@QOWBH1\B\B\B8\B^BBI\B8\BlDestroy AttributeBB[BB[B\\B:BBlUsed to destroy attributes from relationsB\\BaBManipulationB\B\B*Relation Name:BB:B\B,Name of the relation from which attributes are to be destroyed.B\B*Attributes:BB:B\BList of attributes to destroy.B\B*Key:BB:B\B,New key for the relation if it is to be different from the previous value or if any of the key attributes are destroyed.BB*Give parameters for DESTROY ATTRIBUTE:BBU\B8B\B\B8B\B8\B:BB^BB[BB[BB_BBaBBbBBeBBUB\B^BUNION9CF'$B:Bd]FB:B:B:BFBjBy\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBBsUnion of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the UNION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-UNION &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SÁRELATION-UNIONBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOBy1\B\B\B8\B^BBz\B8\BUnionBB
BB
B\\ O UBUsed to form union of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\BList of the names of two relations which will take part in the relation union operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*Parameters for the set-union of two relationsBB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BCDIFFERENCE9CF'$B:Bd]FB:B:B:BFBjB\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBB|Difference of the tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the DIFFERENCE operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-DIFFERENCE &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SRELATION-DIFFERENCEBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOB1\B\B\B8\B^BB\B8\BlDifferenceBBBBB\\BBBUsed to form difference of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\B,List of the names of two relations which will take part in the relation difference operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*lParameters for the set-difference of two relationsBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BINTERSECTION9CF'$B:Bd]FB:B:B:BFBjB\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBB}Intersection of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the INTERSECTION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-INTERSECTION &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SÂRELATION-INTERSECTIONBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOB1\B\B\B8\B^BB\B8\BꬁIntersectionBBBBB\\BBBUsed to form intersection of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\BlList of the names of two relations which will take part in the relation intersection operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*Parameters for the set-intersection of two relationsBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BAVERAGE(AF$B:Bd]FB:B:B:BFBjB\BmBBBWB
CBYBB:\BB:\B\BBoBBIAverage of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose average is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group average of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (AVERAGE RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SBBWB
BBBBBPAPPPQQPQPQ	PQ
PQJ@AQQ@QOB1\B\B\B8\B^BB\B8\B,AverageBBBBB\\BBBlUsed to compute the average of the attribute values in a relation.B\\BaBlOperatorsB\	B\B*Relation name:BB~B\BlName of the relation which contains the attribute to be averaged.B\B*,Attribute name:BB:B\BName of the attribute in the above relation.B\B*,Unique?BB:B\BlIf true, only the unique values of the attribute will be used in the calculations.BB
\B*lByBB:B\BSpecify the attribute to be used in grouping the data into categories.BBB*,Parameters for average:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBB BB#BBB\B^BSUM(AF$B:Bd]FB:B:B:BFBjB;\BmBBBWB
BBB:\BB:\B\BBoBBASum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose sum is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group sum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (SUM RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SB<BWBBB
BBB<PAPPPQQPQPQ	PQ
PQJ@AQQ@QOJB;1\B\B\B8\B^BB<\B8\B꬀SumBBNBBNB\\BBLBUsed to compute the sum of the attribute values in a relation.B\\BaBlOperatorsB\	B\B*Relation name:BB~B\B,Name of the relation which contains the attribute to be summed.BB(B,B
B0BB*Parameters for sum:BBH\B8B\B\B8B\B8\B:BBQBBNBBNBBRBBTBBUBBXBBHB\B^BSIZE&AF$B:Bd]FB:B:B:BFBjBd\BmBBWB
BBB:\BB:\B\BBoBBNumber of tuples in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation whose size is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying tuples will be used.  (SIZE RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE &ALLOW-OTHER-KEYS)BBl~SBeBWBBB
BBBePAPPPQPQPQ	PQ
PQJ@AQ@QOsBd1\B\B\B8\B^BBe\B8\B꬀SizeBBwBBwB\`SBlUsed to compute the size of the relation.B\\BaBlOperatorsB\B\B*Relation name:BB~B\BName of the relation whose size is required.BB,B
B0BB*Parameters for size:BBq\B8B\B\B8B\B8\B:BBzBBwBBwBB{BB}BB~BBBBqB\B^BCOUNT(AF$B:Bd]FB:B:B:BFBjB
\BmBBBWB
BBB:\BB:\B\BBoBBGNumber of the values of a given attribute in a relation satisfying a where clause.
   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose count is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group count of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (COUNT-RTMS RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SCCOUNT-RTMSBWBBB
BBBPAPPPQQPQPQ	PQ
PQJ@AQQ@QOB
1\B\B\B8\B^BB\B8\BCountBBBBB\\BBB,Used to compute the count of the attribute values in a relation.B\\BaBlOperatorsB\	B\B*Relation name:BB~B\BlName of the relation which contains the attribute to be used to find the number of tuples.BB(B,B
B0BB*Parameters for count:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMAXIMUM%AF$B:Bd]FB:B:B:BFBjB\BmBBB
BBB:\BB:\B\BBoBB(Maximum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose maximum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group maximum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (MAXIMUM RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SBB
BBBBBPAPPPQQPQPQ	PQ
@
AQQ@QOB1\B\B\B8\B^BB\B8\B,MaximumBBBBB\\BBBlUsed to compute the maximum of the attribute values in a relation.B\\BaBlOperatorsB\B\B*Relation name:BB~B\BlName of the relation which contains the attribute to be maximumd.BB(B
B0BB*,Parameters for maximum:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMINIMUM%AF$B:Bd]FB:B:B:BFBjB\BmBBB
BBB:\BB:\B\BBoBB(Minimum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose minimum is to be found.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group minimum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (MINIMUM RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SBB
BBBBBPAPPPQQPQPQ	PQ
@
AQQ@QOB1\B\B\B8\B^BB\B8\B,MinimumBBBBB\`MBlUsed to compute the minimum of the attribute values in a relation.B\\BaBlOperatorsB\B\B*Relation name:BB~B\BlName of the relation which contains the attribute to be minimumd.BB(B
B0BB*,Parameters for minimum:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BINSPECT-DBMS-OBJECT@F$B:Bd]FB:B:B:BFBjB	\BmÀOBJECTB:B:\B\BBoBBlInformation on any database objectBBl(INSPECT-DBMS-OBJECT '~S)BBP@PPQ@QOB	1\B\B\B8\B^BB
\B8\BꬂInspect Dbms ObjectBBBBB\BUsed to inspect any database object.BBB\B\B*,Database Object:BBB\BSpecify a database object (COMMAND / RELATION / ATTRIBUTE).BB*Help on the database object ->BB\B8B\B\B8B\B8\B:BBBBBBBB BB"BBBB#BBB\B^BCLEAR-OUTPUT-WINDOW@DF$B:Bd]FB:B:B:BFBjB/\BmB:B:\B\pBMlSHEET-LINE-HEIGHTpBM,SHEET-BOTTOM-MARGIN-SIZEpBMSHEET-TOP-MARGIN-SIZEpBMSHEET-HEIGHTpBMSHEET-INSIDE-HEIGHTpBMSHEET-NUMBER-OF-INSIDE-LINESBBoBBClear the entire output windowBiSET-ITEMSiSCROLL-TO)RELATIVEPP@PJPNPNcPNcPNhCcP@OKB/1\B\B\B8\B^BB0\B8\BꬂClear Output WindowBBOBBOB\eBBSBBG\B8B\B\B8B\B8\B:BBRBBOBBOBBSBBSBBGB\B^BÁSCROLL-FORWARD	@DF$B:Bd]FB:B:B:BFBjB[\BmB:B:\B\B<B>B@BBBDBFBoBBscrolling forward in the output-windowBBIBJP@PPNPNcPNcPNhCGP@OhB[1\B\B\B8\B^BB\\B8\BScroll ForwardBBlBBlB\VBBSBBg\B8B\B\B8B\B8\B:BBoBBlBBlBBpBBSBBgB\B^BSCROLL-BACKWARD	@DF$B:Bd]FB:B:B:BFBjBx\BmB:B:\B\B<B>B@BBBDBFBoBB,scrolling backward in the output-windowBBIBJP@PJPNPNcPNcPNhCcP@OBx1\B\B\B8\B^BBy\B8\B,Scroll BackwardBBBBB\VBBSBB\B8B\B\B8B\B8\B:BBBBBBBB
BBSBBB\B^BÁSCROLL-TO-TOP@DF
$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBlscrolling to the top in the output-windowBiPUT-ITEM-IN-WINDOWITEM-OF-NUMBERP@PPJ@OB1\B\B\B8\B^BB\B8\BScroll To TopBBBBB\<BBSBB\B8B\B\B8B\B8\B:BBBBBBBBBBSBBB\B^BSCROLL-TO-BOTTOMF@F$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBscrolling to the bottom in the output-windowB)PUT-LAST-ITEM-IN-WINDOWPOB1\B\B\B8\B^BB\B8\B,Scroll To BottomBBBBB\>BBSBB\B8B\B\B8B\B8\B:BBBBBBBBBBSBBB\B^BSCROLL-TO-A-RELATION"@F$B:Bd]FB:B:B:BFBjB\BmBB:\ÀINDEXB:\B\BBoBB,Scroll to a particular relation*TYPEOUT-WINDOW*BINDEXGETPITEMSBB~%The relation ~S is not in the output-windowBߒQP@@QPCxPAP	P@QAP
PQOB1\B\B\B8\B^BB\B8\BꬂScroll To A RelationBBBBB\RBBSB\B\B*Relation Name:BB~B\BlName of the relation to scroll to:BB*lScroll to the relation ==>BB\B8B\B\B8B\B8\B:BBBBBBBBBBSBBBBB\B^BSEND-OUTPUT-TO-FILE:@FT$B:Bd]FB:B:B:BFBjB\BmFILEB:\BB:B:B:B:LINEB~ELEMENT\B\	BPROGpZLC,DO-NAMEDpBuINHIBIT-STYLE-WARNINGSpBulCONDITION-BIND-IFpBuCONDITION-BINDpBuCATCH-CONTINUATION-IFpBulCATCH-CONTINUATIONpBuERRSETBoBBlSend the contents of the output window to a file.plEH*CONDITION-HANDLERS*BBFZp,G2586FWERRORpBERRSET-HANDLERiCHARACTERSiDIRECTIONOUTPUTiIF-DOES-NOT-EXISTCREATEOPENBl~S is a bad file.BBpBulLISTARRAYBITEM1TERPRICLOSEPJUPPT	P
PPJCAPJCBցQ@PPPPPJJ!BJ!B\B@]_ZD@PPQ<BBPDC2CQDSEFE7E1EEQ@QE5EQGG7G1GGQG5GS&GSGWFF5FSFQ@Q@QCCDD@@QRO4B1\B\B\B8\B^BB\B8\BꬂSend Output To FileBB8BB8B\@FBBSB\B\B*lFile name:BBB\B,Name of the file to send the output to:BB*Send the output window contents to:BB\B8B\B\B8B\B8\B:BB;BB8BB8BB<BBSBB>BBB\B^BINTRODUCTIONF@F$B:Bd]FB:B:B:BFBjBJ\BmB:B:\BoBB,Introduction to this interface.BOVBJ1\B\B\B8\B^BBK\B8\BꬁIntroductionBBZBBZB\BBBBU\B8B\B\B8B\B8\B:BB]BBZBBZBB^BBBBUB\B^BB@DF$B:Bd]FB:B:B:BFBjBf\BmB:\COMMAND\B\BBoBBIntroduction to the interface. Help on any database object (COMMAND / RELATION / ATTRIBUTE).pBuSELFÁ*HELP-SUBMENU*SUBMENU-CHOOSE)EXECUTEPPC@PP@ROyBf1\B\B\B8\B^BB\B8\B꬀HelpBB}BB}BBjB,Introduction to the interface. Help on any database object (COMMAND/RELATION/ATTRIBUTE).BBs\B8B\B\B8B\B8\B:BBBB}BB}BBjBBBBsB\B^BBa@DF$B:Bd]FB:B:B:BFBjB\BmB:\Bp\B\BBoBB,Select a database command from a menu. A choose-variable-values window will be presented to get the arguments for that command.BuC*COMMAND-SUBMENU*BwBxPPC@PP@ROB1\B\B\B8\B^BBa\B8\BꬁCommand MenuBBBBB\BBBjB,Select a database command from a menu. A choose-variable-values window will be presented to get the arguments for that command.BB\B8B\B\B8B\B8\B:BBBBBBBBBBjBBBBB\B^BBS@DF$B:Bd]FB:B:B:BFBjB\BmB:\Bp\B\BBoBBlSelect an item from a menu to scroll in the output window.BuC*DISPLAY-SUBMENU*BwBxPPC@PP@ROB1\B\B\B8\B^BBS\B8\B,DisplayBBBBBBjBlSelect an item from a menu to scroll in the output window.BB\B8B\B\B8B\B8\B:BBBBBBBBjBBBBB\B^BKILL	F@F$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBTo exit the interface by killing the process.BKILLPROB1\B\B\B8\B^BB\B8\B꬀KillBBBBB\ BBjBTo exit the interface by killing the process.BB\B8B\B\B8B\B8\B:BBBBBBBBBBjBBBBB\B^BEXITF@F$B:Bd]FB:B:B:BFBjB\BmB:B:\B\BBoBBTo exit the interface by burying it.BBURYPOB1\B\B\B8\B^BB\B8\B꬀ExitBBBBB\eBBjBTo exit the interface by burying it.BB\B8B\B\B8B\B8\B:BBBBBBBBBBjBBBBB1\pBuMAKE-INSTANCE\B8pBUCOMMAND-TABLENAMEDatabase command tableBdatabase helpN
B1\pBuBUILD-COMMAND-TABLE\B8B\B8B\B8\LBBaBSBBBBIB"BBPBxBBBBB{BB	B	BjBY	B
BzBBBB8BhBGBBB<BBeBBBs
BBG
B
B	BBBBIB%BBxBBB	BBBEB5BBbBBBqBB#BNBBB)BMB
BKB\B0BBByBB\B^BBINIT[`DF<$B:Bd]FB:B:B:BFBjB\BmBBB:\B\B\BBoBBÁ*INTERACTION*C*MENUPANE*BBBaBvpBMMOUSE-SHEETB@POP-UPBF)SUPERIORiITEM-LIST-POINTERBBҩMULTICOLUMN)COLUMN-SPEC-LISTBS)GET-PANEBSET-ITEM-LIST-POINTERBj)UPDATE-ITEM-LISTBAB)SET-SELECTION-SUBSTITUTEPPPP
PPP	J	PPPPP
PPPJPPPP
PPP	JPPCPPPPPCPPCPPCO-B1\pBulBUILD-MENU\B8Bj\B8B)ITEM-LIST-ORDER\B8\BBBaBBS1\B0\B8B\B8BB3\B8\BKB
1\B0\B8BS\B8BB3\B8\	BByB0BBpBUDISPLAY-COMMAND-TABLESpBUEDIT-COMMAND-TABLESB\B1\BQ\B8Ba\B8\B\B8BW1\B0\B8Ba\B8BB3\B8\>BBG
Bs
B
B%B	BBIBBBBxBB	BBBB
BB	B	BjBB{BY	B"BBIBPBxBBBB8BBzBBBhBGBBB<BeBBBBEB5BBbBBBBBqBB#BNBB)BMiCOLUMN-LIST-ORDER\B8\\lDefinitionB/pB0HL12BI\ManipulationB/BX\lOperatorsB/BX\Other FeaturesB/BXB:N:B\B^BBw1@F$B:Bd]FB:B:B:BFBjB`\BmSUBMENUB:\SUP\B\BBoBB#B B%F.SET-VISIBILITYBLINKER-LISTSET-SUPERIORCHOOSEF0BLINKP@PUPPB	PP
PPQA]3ZP	P@QPPPBOuB`\B^BBCOMMAND-LOOP
@
DF$B:Bd]FB:B:B:BFBjBv\BmB:B:\B\BBoBB BBB{CLEAR-SCREENSET-IO-BUFFERiIO-BUFFERPPPP@P	P@OBv\B^BBiFETCH-AND-EXECUTE	`DF$B:Bd]FB:B:B:BFBjB\BmBBB:\B\B\BBoBBCCHBpBMl*REMOVE-TYPEOUT-STANDARD-MESSAGE*B)ACTIVE-Pl~%B)ANY-TYIFLUSH-TYPEOUTPP	P
P	P
PP
PPROBB
(@HF$B:Bd]FB:B:B:BFBjB
\CXB:\BB:\B\BBBBBBl~%BBBBl~SPPP	PP	PP	
P@PPAPPQ	AOB
\B^BB)EXECUTE-COMMANDF$B:Bd]FB:B:B:BFBjB\BmBBB:\BB:\B\BBj-BB
BBl~SBߒP&PAP	PP
AROB\B^BBB	`HF$B:Bd]FB:B:B:BFBjB\BmBBB:\BB\B\BBoBBBBBBl~%BBB\MAPC\B\B\VAL\jIFB\PROGN\BBB\BB:l~SB\BBBj//PPP	PP	PP	
PAPOB\B^BDESIGNATE-IO-STREAMS	F	@F$B:Bd]FB:B:B:BFBjB\BmB:B:\BoBpBu,DEBUG-IOуERROR-OUTPUTBj*STANDARD-OUTPUT*BB PPPPOB\B^BpB,FASLOAD-COMBINEDB
	F$B:Bd]FB:B:B:BFBj\B^B)COMBINEDB\BpB.DAEMON-CALLER-ARGS.B:\BpB.DAEMON-MAPPING-TABLE.\B\pBMETHOD-MAPPING-TABLEpBCOMPILE-TIME-REMEMBER-MAPPING-TABLE)FUNCTION-PARENT\BpBuCOMPILE-FLAVOR-METHODSpBlCOMBINED-METHOD-DERIVATION\BB:B:\B\B^BBB\B\B^BBB\B:\B^pBUlBASIC-COMMAND-LOOPBBpBlSELF-MAPPING-TABLE1\pBuFDEFINITION-LOCATION\B8B	1]B]B8]BBBF01\B\B8B1\B\B8BPA@QAQJP@@QPPPA@QAQJ	P@PO B\B^BBBF$B:Bd]FB:B:B:BFBj\B^BBBBB:\BB\B\BBBBB\BB:B:\B\B^BBB\B:\B^BBBB1\B\B8B/B1\B\B8B1PA@QAQJP@@QPJPBO8B!\B^BBBwF$B:Bd]FB:B:B:BFBj\B^BBBwBB:\BB\B\BBBBB\BwB:B:\B\B^BBBw\B:\B^BBwBB1\B\B8BG1]B]B8]BBB1\B\B8BIPA@QAQJP@@QPJPBOTB9\B^BBBF$B:Bd]FB:B:B:BFBj\B^BBBBB:\BB\
B\BBINTERNAL-FEF-OFFSETS\FiINTERNAL-FEF-NAMES\pBCONTINUATIONBBB\BB:B:\B\B^pBMESSENTIAL-SET-EDGESBB\B^pBMBASIC-CONSTRAINT-FRAMEBB\B^pBMPROCESS-MIXINBB\B^BBB\B^BBB\B^BBB\B\B^pBM,ESSENTIAL-WINDOWBB\B^BlBB\B^pBMCONSTRAINT-FRAME-WITH-SHARED-IO-BUFFERBB\B^BBB\INVERSE-AROUND\B^pBMSHEETBB\B:\B^BBBB\)INTERNALBUBg1]B]B8]BBB1\B\B8BPA@SPAQ@Q@UPJPBOBUBTF7$B:Bd]FB:B:B:BFBj\BB]BgBB:\BB\B\BBBB1]B]B8]BBB1\B\B8B~1]B]B8]BBB}1\B\B8B{1]B]B8]BBBl1\B\B8Bz1]B]B8]BBBy1\B\B8BwBF01\B\B8B1\B\B8Bj1]B]B8]BBBo1\B\B8Bm1]B]B8]BBBr1\B\B8BpB1\B\B8BsBP1\B\B8Bt1\B\B8BuPA@QPJP@@QPJP@@Q	PJ
P@@QPJP@@QPPPA@Q	PJP@@QPJP@@QPJP@@QPJP@@QPJP@@QAQJP@POB\B^BBSETvTF$B:Bd]FB:B:B:BFBj\B^BBBBB:\BB\B\BBBBBB\BCASE)BASE-FLAVOR-LAST\ B\B^BBBB\B^BBBiCHAR-ALUF\B^BBBiERASE-ALUF\B^BoBBEXPOSED-PANES\B^BBBOLD-TYPEAHEAD\B^BBBB\B^BBB)TUTORIAL\B^BBBB\B^BBBB\B^BBBSYSTEM-COMMAND-TABLES\B^BBBSPECIAL-COMMAND-TABLES\B^BBBB\B^BBBiKBD-INPUT\B^BBB)INPUT-MECHANISM\B^BBBCOMMAND-ENTRY\B^BBB)COMMAND-HISTORY\B^BBBMAX-COMMAND-HISTORY\B^BBB)COMMAND-EXECUTION-QUEUE\B^BBB)NUMERIC-ARGUMENT\B^BBBiBLIP-ALIST\B^BBBB\B^BBBTYPEIN-MODES\B^BBBREAD-FUNCTION\B^BBBPROMPT\B^BBBiREAD-TYPE\B^BBBERROR-MESSAGE\B^BBBB\B^BBBB\B^BBBINHIBIT-RESULTS-PRINT?\B^BBBOUTPUT-HISTORY\B^BBBiMAX-OUTPUT-HISTORYBBB1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B
1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8B1\B\B8BB1\B\B8BB1\B\B8BB1\B\B8B1\B\B8B1\B\B8BBB\BBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBpBCASE-METHOD-DEFAULT-HANDLER\BBBBBBBBBBBB	BBBBBBBBBBBBBBBBBBBF#BBBBBBBBBBBB	BBBBBBBBBBBBBBBBBBB)GET-HANDLER-FOROPERATION-HANDLED-PiCASE-DOCUMENTATION)WHICH-OPERATIONSF"FFFFFFF	FFFFF"F'F,F1F6F;F@FEFJFOFTFYF^FcFhFmFrFwF|FFFFFFPA@W-r@QPJPB@QPJPB@QPJPB@QPJ	PB@QPJ
PB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@QPJPB@Q PJ!PB@Q"PJ#PB@Q$PJ%PB@Q$PJ&PB@Q$PJ'PB(P)P*P@W@[+,ROB\B^BBiPROCESSES
F$B:Bd]FB:B:B:BFBj\B^BBBBB:\BB\B\BBBBB\BAPPENDB\B:\B^BB\B^BrBBBB1\B\B8BB1\B\B8BpB,*APPENDPA@QPJPA@QPJPA	OB\B^BBB*lFB$B:Bd]FB:B:B:BFBj\B^BBBBB:\BBB:pBM.QUEUE-LEFT.pBMOLD-SCREEN-MANAGER-TOP-LEVELpBMlE\B\
BpBuNEQBBBWHENpBMlDELAYING-SCREEN-MANAGEMENTpBulLEXPR-SENDpBulDESTRUCTURING-BINDpBlMACROCALLBBpB,WRAPPER-SXHASHES\\\B^By)WRAPPERBB\BB:B:\B\B^BBB\B^BrBB\B:\B^ByBB\BBBpBMlINHIBIT-SCREEN-MANAGEMENTpBM,SCREEN-MANAGER-TOP-LEVELBBupBMSCREEN-MANAGER-QUEUE1]B]B8]BpBMSELECTION-SUBSTITUTEBFnFc)INFERIOR-SELECT1]B]B8]BpBM,SUPERIORB1\B\B8BB1\B\B8BBF01\B\B8BpBMlSCREEN-MANAGE-DELAYING-SCREEN-MANAGEMENT-INTERNALpBMSCREEN-MANAGE-QUEUEPA@UB	
PBQBJ	PBCPUPDPUPP@QPJP@@QPJP@@QPPPAJ]hZPCDQ]sZPCQ
CQEEQBEUBJP@OB\B^BBBF	$B:Bd]FB:B:B:BFBj\B^BBBBB:\B\
B\BBa\FBBB\\\B^BBBr}B\BB:B:\B\B^pBM,ESSENTIAL-EXPOSEBB\B\B^pBMlESSENTIAL-ACTIVATEBB\B^BrBB\B:\B^BB\BB#BB\BBpBMSHEET-EXPOSE@QPO6BB2&F$B:Bd]FB:B:B:BFBj\BB\BB:\B:B\B\BBBBB1\B\B8B.1]B]B8]BBB-1\B\B8B+BF01\B\B8B01]B]B8]BBB)1\B\B8B'PA؀QPJP@QPJP@Q	P
PPAQPJP@POYB2\B^BB)DESELECT$[F7$B:Bd]FB:B:B:BFBj\B^BBB[BB:\BBB:BBB\B\	BBBBBBBBBBBB\\\B^ByBB["nB\B[B:B:\B\B^BBB[\B:\B^ByBB[\BBiBBBBBBB[FXFMB1\B\B8BmBF01\B\B8BoBBPA@UB	PBQBJPBC
PUPDPU@QPJP@@QPPPA]RZPCDQ]]ZPCQ
CQEEQBEUBJP@OzBZ1\pB,COMPILE-FLAVOR-METHODS-2\B8BCINTERFACE
`
F$B:Bd]FB:B:B:BFBjB\BBB:\B\B\BB BBpBMFIND-WINDOW-OF-FLAVORpBMMAKE-WINDOWBBPPP	POBCREATE-KEYSFF$B:Bd]FB:B:B:BFBjBB:B:B:B:eDBRtms Interface\BpBMADD-SYSTEM-KEY)PROGRAMSRTMSRtms interfacepBMlADD-TO-SYSTEM-MENU-COLUMNPPPPP	PP
POB1\BB	@	F$B:Bd]FB:B:B:BFBjBB:B:B:\B\B<B>B@BBBDBFBBBl BBIBJPPPP@PPNPNcPNcPNhCGP@OBB7AF$B:Bd]FB:B:B:BFBjB\BARGBVITEM-NOB:\B~B	\Ba\FBB1PRIN1\BB7QQ15#QA A7AQQAA1A5AS&	ASASASQAW@P@QA[PROBBFF$B:Bd]FB:B:B:BFBjB\B~BVB:B:B:B5SQQOBBJ@HF,$B:Bd]FB:B:B:BFBjB\BB:\B~B	\B\BBBBBBB1Bl~%BBB71QP50QA A7A1AAQA5AS&	ASAWAWP	AW@@5@W@QPP
PP
PPPPPROBB7@xFS$B:Bd]FB:B:B:BFBjB\BB:\ÀITEMSITEM-NUMBERMOD-RELATIONÁMOD-ATTRIBUTESB_B:B	NUMBERSB	B:B:B:BB\B\BBDOLISTBBBC*PKG-NAME*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*BNUMBER-OF-ITEMSYSTEM-RELATION\BBQTRIEVEBBBBҬDelete the indicated tuple?pBMMOUSE-CONFIRMBB
ANDEQUALBB8BF BҩDELETE-ITEMPUTPPQAPP	PP
EESFGPFSPGAQGSxAQGWy	GQDPFSBFWCEBAP>QHH5@QHU@BQPPEECQ@QKJIIQJSKSMLPLQPMQCIJKJKEQ
CPPABv
PAQBQDSDWmPROBB-~)-@F$B:Bd]FB:B:B:BFBjB\BB:\BBÁATTRIBUTE-VARSCMOD-TUPLEBBÀBLANKSBW
ÀTUPLEB:B	BB	B:B:BBB:B:\B\BBBBBB *LINE-AREA-VALUES-MODIFIEDP*BBBBBB\BBBBBBBBBj+pBlSIMPLE-MAKE-ARRAYҬMODÀABORTFBB*,Modify the relation: ~SB)FUNCTIONÂLINE-AREA-DOMAIN-CHECKMARGIN-CHOICES\Do It\Abort\THROW\B8BBpBMCHOOSE-VARIABLE-VALUESB8B҃PRINT-TUPLEBB
B
BBF B
BINSERT-ITEM	PQA
PPPPIISJKPJSPKAQKSxAQKWyPJSDJWEIDQLL5GQLSCG@QLU@EQCkGQPEa	J JFIIEQNMMQNSOPOQCMNNIQB@QMI	MSPISPQIMIMPPTNNBQEQIRQ
QQRSISCQRIRINQPPDQPPPPJ \cRRBQNM	MQ!PNSCCMNNRQHRRHQNMMQNS"CMNNRQGQFQ#BCDQ$PEQ%PHQ&P'PRREQ@QNMIIQMSNSPO(PPOQ!PPQCIMNMNRQ
C)P*PABv+PAQ,PAQCQRO"BB`F$B:Bd]FB:B:B:BFBjB\BBB:\BB:B
RO,BB5@`5`Fu$B:Bd]FB:B:B:BFBjB\BBBB:\BBB:B:B:OLDNEWB\B\BBBBU*SEVENTHSIXTHFIFTHBTHIRDSECONDBBNEW-RENNEW-DELNEW-ADDNEW-KEYNEW-STONEW-IMPNEW-TUPB	NEW-DOCNEW-DIROLD-RENOLD-DELOLD-ADDOLD-KEYOLD-STOOLD-IMPOLD-TUPOLD-DOCOLD-DIROLD-ATTB*PROVIDE-ERROR-MESSAGES*\BÁSAVE-DIRECTORYBBW
IMPLEMENTATION-TYPEB0BGET-RELATIONB2lERROR - Relation BB, does not exist in the database BF\B	Relation NameBTo change the relation name.B     Attributes: ~SB\
\BAAdd attributesBTo add attributes specify attribute descriptor pair.B\B@lDelete attributesB,To delete attributes, specify a list of the attributes.B\B?lRename attributesBTo rename attributes, specify a list of the type <(old new)>.Bl \BDImplementation-typeBTo change the type of implementation.B\BClStorage StructureB,To change the type of storage structure.B\BBKeyBTo change the key attributes.B\BFDocumentationBTo change the relation documentation.B\BGSave DirectoryBTo change the directory in which this relation can be saved.B\BETuple formatBTo change the format in printing the relation.BBB*lChange the features of ~SB\Do It\Abort\B\B8BBB\
BBJBIBHBPBOBNBMBLBK\
B	BAB@B?BGBFBEBDBCBB\
B	ADD-ATTRDELETE-ATTRRENAME-ATTRBBBBBB*EQUALPBBBB	QPPBAA	PP PPRASAWA[AQBAUBAYBAQBBPPPP
P	PPPPP!P"PT#P$PP%&P'(P)PP%*P+P,\)A-PB.PC/PDBSCSDSGFE0PEQFQ12AQGQFQ213ABCDBCDAPAQ4ROB1\pB,FASL-RECORD-FILE-MACROS-EXPANDED\B8\)\DEFPARAMETERI	\pBulDEFFLAVOR	\pBulDEFMETHOD6y\DEFUN'\pBulDEFCOMMAND.+\Bx
\B>{\B=:}n\B<Zi\B;{Ĳ\B:2=\B"\B.ً\B.-U\Bq\Bc&p\Ba\B,a\B~ki\BBX\BV\B-i\B~z\B<p\B`sN\B|\B(̢\B*j\B=#\BF3\BD*\BBV>\B@&>\B>:>\B<>\B/\BUN\Bz(\Bx\B%\BaM*Name:BBB\BlName of the directory to write to.B\B*Type of SAVE:BBB\BSave type. It can be either XLD or COMMAND.B\B*lMust Save:BB:B\BSave the relation even if the relation has not been modified.BB*lGive parameters for SAVE RELATION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BSAVE-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjB\BmTRANSACTIONBBB:\BB:\B\BBoBBSave a transaction on disk.

   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction is to be stored.
   PATHNAME    - Name of the file in which it is to be stored.  (SAVE-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBBBBBBPAPPPQPQPQ	@	
AQ@QOB1\B\B\B8\B^BB\B8\B,Save TransactionBBBBB\\BLBB,Used to save a transaction on a given directory.B\\BaBOther FeaturesB\B\B*lTransaction Name:BBB\BName of the transaction to be saved.B\B*,Directory Name:BBB\BlName of the directory to write to.B\B*lPathname:BBB\B,
The name of the file into which the transaction forms will be stored. It defaults to <transaction>.lispBB*Give parameters for SAVE TRANSACTION:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÂDEFINE-IMPLEMENTATION	@F$B:Bd]FB:B:B:BFBjB\BmÁIMPLEMENTATIONBB:\BB:\B\BBoBBDefine a new implementation.

   IMPLEMENTATION-NAME - Name of the implementation to be defined. All the implementation-specific
                         accessor functions are expected to be defined.
   DOCUMENTATION       - Description of this implementation.  (DEFINE-IMPLEMENTATION IMPLEMENTATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
OB1\B\B\B8\B^BB\B8\BDefine ImplementationBB
BB
B\\BBBlUsed to define an implementation.B\\BaBlDefinitionB\B\B*Implementation Name:BB:B\BName of the implementation. Implementation-dependent routines are expected to be defined by the user.B\B*Documentation:BBB\BDocumentation for the implementation.B-B*lGive parameters for DEFINE IMPLEMENTATION:BB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BDEFINE-INDEX)AF$B:Bd]FB:B:B:BFBjB$\BmBCINDEX-NAMEÁKEY-ATTRIBUTESCSTORAGE-STRUCTUREPRIORITYBB:\BB:\B\BBoBB쿖Define an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index will be defined.
    NAME - Name of the index to be defined
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index.  (DEFINE-INDEX RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL NAME DOCUMENTATION STORAGE-STRUCTURE KEY PRIORITY &ALLOW-OTHER-KEYS)BBl~SB%NAMEBBB1BBBB%PAPPPQPQPQ	PQ
PQPQ
J@AQ@QO8B$1\B\B\B8\B^BB%\B8\BꬁDefine IndexBB<BB<B\\B@IB,Used to define a secondary index on a relation.B\\BaBlDefinitionB\	B\B*Relation Name:BB:B\BlName of the relation upon which the index will be defined.B\B*Index Name:BB:B\B,Name of the index to be defined.B-\B*,Key Attributes:BB:B\BlList of attribute names which form the key for this index.B\B*lStorage Structure:BAVLB\B,The storage structure used to define the index.B-\B*lPriority:BF
B\BA numerical value which indicates the priority given to this index. 1 is the highest priority.B\B*Documentation:BBB\BDocumentation for the index.B-B*lGive parameters for DEFINE INDEX:BB5\B8B\B\B8B\B8\B:BB?BB<BB<BB@BBCBBDBBGBB5B\B^BMODIFY-INDEX+BF$B:Bd]FB:B:B:BFBjBi\BmBB.ÁNEW-INDEX-NAMEB/B0B1BB:\BB:\B\BBoBB쿽Modify an index on a relation in the active database.

    RELATION-NAME - Name of the relation on which the index to be modified is defined
    INDEX-NAME - Name of the index to be modified
    NEW-NAME - New name for the specified index
    KEY - List of attributes names which form the key of the index.
    STORAGE-STRUCTURE - The name of a RTMS defined storage structure upon which will be used as the index structure.
    PRIORITY - A numerical value which determines the order in which RTMS will search multiple indices of a relation
               for a possible key. The number one receives the highest consideration, if it fails the next index in
               value is attempted.
    DOCUMENTATION - A string describing this index.  (MODIFY-INDEX RELATION-NAME INDEX-NAME &REST KEYWORD-LIST &KEY &OPTIONAL NEW-NAME DOCUMENTATION STORAGE-STRUCTURE KEY PRIORITY &ALLOW-OTHER-KEYS)BBl~SBjNEW-NAMEBBB1BBBBjPAPPPQQPQPQ	PQ
PQPQ
J@AQQ@QOzBi1\B\B\B8\B^BBj\B8\BꬁModify IndexBB~BB~B\\BBBB,Used to define a secondary index on a relation.B\\BaBManipulationB\
B\B*Relation Name:BB:B\BName of the relation upon which the index to be modified is defined.B\B*Index Name:BB:B\BlName of the index to be modified.B-\B*,New Index Name:BB:B\BNew name of the index.B-\B*,Key Attributes:BB:B\BlList of attribute names which form the key for this index.B\B*lStorage Structure:BB:B\B,The storage structure used to define the index.B-\B*lPriority:BF
B\BA numerical value which indicates the priority given to this index. 1 is the highest priority.B\B*Documentation:BBB\BDocumentation for the index.B-B*lGive parameters for DEFINE INDEX:BBw\B8B\B\B8B\B8\B:BBBB~BB~BBBBBBBBBBwB\B^BDEFINE-STORAGE-STRUCTURE	@F$B:Bd]FB:B:B:BFBjB\BmB0BB:\BB:\B\BBoBB,Define a new storage structure.

   STORAGE-STRUCTURE-NAME - Name of the storage-structure to be defined. All the storage-structure-specific
                            accessor functions are expected to be defined.
   DOCUMENTATION          - Description of this storage-structure.  (DEFINE-STORAGE-STRUCTURE STORAGE-STRUCTURE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
OB1\B\B\B8\B^BB\B8\B,Define Storage StructureBBBBB\\BBLBlUsed to define a storagestructure.B\\BaBlDefinitionB\B\B*,Storage structure name:BB:B\B
Name of the storage structure. Storage-structure-dependent routines are expected to be defined by the user.B\B*Documentation:BB:B\B,Documentation for the storage structure.B-B*Give parameters for DEFINE STORAGE STRUCTURE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁDEFINE-DOMAIN#AHF$B:Bd]FB:B:B:BFBjB\BmÀDOMAINpBuDEFBBB:\BB:\B\BBoBBDefine new domain. Corresponding predicate is expected to be defined prior to this operation.

   DOMAIN-NAME     - Name of the domain to be defined.
   DOCUMENTATION   - Describes the new domain.
   FORMAT          - Print width for attributes belonging to this domain.  (DEFINE-DOMAIN DOMAIN-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DEFAULT DOCUMENTATION FORMAT &ALLOW-OTHER-KEYS)BBl~SBDEFAULTBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\BDefine DomainBBBBB\`DB,Used to define a domain.B\\BaBlDefinitionB\B\B*Domain Name:BB:B\BName of the domain. Domain predicate is expected to be defined prior to this.B\B*Default value:BB:B\BDefault value for this domain.B\B*Documentation:BB:B\BDocumentation for the domain.B-\B*,Default width :BB:B\BThe default width to be used for this domain.BB*lGive parameters for DEFINE DOMAIN:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BÁMODIFY-DOMAIN#AHF$B:Bd]FB:B:B:BFBjB\BmBBBBB:\BB:\B\BBoBBlModify the default format, value, and documentation of a domain.

   DOMAIN-NAME - Name of the domain to be modified.
   FORMAT      - New format, i.e the print width, for this domain.
   DEFAULT     - New default value for this domain.
   DOC         - New description of this domain.  (MODIFY-DOMAIN DOMAIN-NAME &REST KEYWORD-LIST &KEY &OPTIONAL FORMAT DEFAULT DOC &ALLOW-OTHER-KEYS)BBl~SBBBBBBBPAPPPQPQPQ	PQ
@
AQ@QO"B1\B\B\B8\B^BB\B8\BModify DomainBB&BB&B\\BBB,Used to modify a domain.B\\BaBManipulationB\B\B*Domain Name:BB:B\BlName of the domain to be modified.B\B*Default value:BB:B\BlNew default value for this domain.B\B*Documentation:BB:B\BlNew documentation for the domain.B-\B*,Default width :BB:B\BlThe new default width to be used for this domain.BB*lGive parameters for MODIFY DOMAIN:BB \B8B\B\B8B\B8\B:BB)BB&BB&BB*BB,BB-BB0BB B\B^BCDEFINE-TRANSACTION"AHF$B:Bd]FB:B:B:BFBjBH\BmBÀFORMSBBB:\BB:\B\BBoBBDefine a transaction, a list of database calls.

   TRANSACTION - Name of the transaction.
   FORMS       - List of RTMS calls.
   DIRECTORY   - Name of the directory in which this transaction will be stored.
   PATHNAME    - Name of the file in which it will be stored.  (DEFINE-TRANSACTION TRANSACTION FORMS &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBIBBBBBIPAPPPQQPQPQ	@	
AQQ@QOXBH1\B\B\B8\B^BBI\B8\BlDefine TransactionBB\BB\B\\BBBUsed to define a transaction.B\\BaBlDefinitionB\B\B*lTransaction Name:BBB\B,Name of the transaction.B\B*,Database calls:BB:B\BlA list of database calls.BB\B*lPathname :BBB\BThe default file in which it will be saved.BB*,Give parameters for DEFINE TRANSACTION:BBV\B8B\B\B8B\B8\B:BB_BB\BB\BB`BBbBBcBBfBBVB\B^BCMODIFY-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjBz\BmBBBB:\BB:\B\BBoBBEdit the database calls in a transaction.
   TRANSACTION - Name of the transaction.
   DIRECTORY   - Name of the directory in which this transaction can be found.
   PATHNAME    - Name of the file in which it is stored.  (MODIFY-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SB{BBBBB{PAPPPQPQPQ	@	
AQ@QOBz1\B\B\B8\B^BB{\B8\BlModify TransactionBB
BB
B\\BBBUsed to modify a transaction.B\\BaBManipulationB\B\B*lTransaction Name:BBB\B,Name of the transaction to be modified.B\B*lDirectory:BBB\BDefault directory in which it can be found, if not in memory.B\B*lPathname :BBB\BThe default file in which it can be found, if not in memory.BB*,Give parameters for MODIFY TRANSACTION:BB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BDEFINE-DATABASE#AHF$B:Bd]FB:B:B:BFBjB\BmBBBENVB:\BB:\B\BBoBBDefine a new database.

   DB-NAME     - Name of the database.
   DIRECTORY   - Name of the directory in which this database is to be saved.
   ENVIRONMENT - Name of the environment to be associated with this database.
   DOCUMENTATION - A string describing this database.  (DEFINE-DATABASE DB-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY ENVIRONMENT DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SÀDEFDBBBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\B,Define DatabaseBBBBB\\BBB,Used to define a database in a given directory.B\\BaBlDefinitionB\B\B*Database Name:BB:B\BName of the database.B\B*,Directory Name:BBB\BName of the save directory for this database.B\B*Documentation:BBB\B,Documentation for the database.B-\B*Environment:BB:B\BName of the environment to be used to replace the default settings.BB*Give parameters for DEFINE DATABASE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BMODIFY-DATABASE#AHF$B:Bd]FB:B:B:BFBjB\BmBNEW-DATABASEBBB:\BB:\B\BBoBB,Modify various features of the active database.

  DATABASE      - Name of the database to be modified.
  DATABASE-NAME - New name for this database.
  DIRECTORY     - New directory in which this database is to be saved.
  DOCUMENTATION - New description for this database.  (MODIFY-DATABASE DATABASE &REST KEYWORD-LIST &KEY &OPTIONAL DATABASE-NAME DIRECTORY DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBÁDATABASE-NAMEBBBBBPAPPPQPQPQ	PQ
@
AQ@QOB1\B\B\B8\B^BB\B8\B,Modify DatabaseBBBBB\\BBfB,Used to modify the features a database.B\\BaBManipulationB\B\B*Database Name:BB:B\BName of the database.B\B*lNew Database Name:BB:B\BIf the database is to be renamed specify the new name.B\B*,Directory Name:BB:B\B,To change the save directory for this database specify a new directory.B\B*Documentation:BB:B\BNew documentation for the database.B-B*Give parameters for MODIFY DATABASE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBB	BBB\B^BMODIFY-ATTRIBUTE(AF$B:Bd]FB:B:B:BFBjB	\BmBBNEW-ATTRBBBB:\BB:\B\BBoBBModify various features of an attribute in a given relation.

  RELATION       - Name of the relation in which the attribute to be modified exists.
  ATTRIBUTE      - Name of the attribute to be modified.
  ATTRIBUTE-NAME - New name for this attribute.
  DEFAULT-VALUE  - New default value for this attribute.
  DOCUMENTATION  - New description.
  FORMAT         - New print width to be used for this attribute.  (MODIFY-ATTRIBUTE RELATION ATTRIBUTE &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE-NAME DEFAULT-VALUE DOCUMENTATION FORMAT &ALLOW-OTHER-KEYS)BBl~SB	ÁATTRIBUTE-NAMEBBBBBB	PAPPPQQPQPQ	PQ
PQJ@AQQ@QO*	B	1\B\B\B8\B^BB	\B8\B,Modify AttributeBB.	BB.	B\\BBB,Used to modify the features a attribute.B\\BaBManipulationB\	B\B*Relation Name:BB~B\BName of the relation.B\B*,Attribute Name:BB:B\BName of the attribute.B\B*New Attribute Name:BB:B\B,If the attribute is to be renamed specify the new name.B\B*Default Value:BB:B\BlTo change the default value of this attribute specify a new value.B\B*Documentation:BB:B\BNew documentation for the attribute.B-\B*,Default width :BB:B\BThe new default width to be used for this attribute.BB*Give parameters for MODIFY ATTRIBUTE:BB'	\B8B\B\B8B\B8\B:BB1	BB.	BB.	BB2	BB4	BB5	BB8	BB'	B\B^BMODIFY-VIEW
 AF$B:Bd]FB:B:B:BFBjBX	\BmVIEWBBB:\BB:\B\BBoBBModify a view definition or its documentation.

   VIEW-NAME       - Name of the view.
   VIEW-DEFINITION - New definition of the view.
   VIEW-DOCUMENTATION - New description of the view.  (MODIFY-VIEW VIEW-NAME &REST KEYWORD-LIST &KEY &OPTIONAL VIEW-DEFINITION VIEW-DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SBY	VIEW-DEFVIEW-DOCBBBY	PAPPPQPQPQ	@	
AQ@QOj	BX	1\B\B\B8\B^BBY	\B8\BꬁModify ViewBBn	BBn	B\\B VBUsed to modify the features a view.B\\BaBManipulationB\B\B*lView Name:BB:B\BlName of the view.B\B*,View Definition:BB:B\BNew definition of the view.B\B*Documentation:BB:B\B,New documentation for the view.B-B*,Give parameters for MODIFY VIEW:BBf	\B8B\B\B8B\B8\B:BBq	BBn	BBn	BBr	BBu	BBv	BBy	BBf	B\B^BMODIFY-RELATION8CF&$B:Bd]FB:B:B:BFBjB
	\BmRELNEW-RELADD-ATTDEL-ATTREN-ATTBBBBBBB:\BB:\B\BBoBBModify various features of a relation.

  RELATION             - Name of the relation to be modified.
  RELATION-NAME        - New name for this relation.
  ADD-ATTRIBUTES       - List of new attributes and their description.
  DELETE-ATTRIBUTES    - List of attributes to be destroyed.
  RENAME-ATTRIBUTES    - List of list of OLD-NEW attribute names.
  IMPLEMENTATION-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved.  (MODIFY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL RELATION-NAME ADD-ATTRIBUTES DELETE-ATTRIBUTES RENAME-ATTRIBUTES IMPLEMENTATION-TYPE STORAGE-STRUCTURE FORMAT KEY DOCUMENTATION DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB	BÁADD-ATTRIBUTESCDELETE-ATTRIBUTESCRENAME-ATTRIBUTESBBBBBBBBB	PAPPPQPQPQ	PQ
PQPQPQPQPQPQPQJ@AQ@QO	B
	1\B\B\B8\B^BB	\B8\B,Modify RelationBB	BB	B\\BBB,Used to modify the features a relation.B\\BaBManipulationB\B\B*Relation Name:BB~B\BName of the Relation.B\B*lNew Relation Name:BB:B\BIf the relation is to be renamed specify the new name.B\B*,Add attributes:BB:B\BlSpecify a list of attribute-descriptor pairs for attributes to be added to this relation.B\B*lDelete attributes:BB:B\BSpecify a list of attributes in this relation which are to be deleted.B\B*lRename attributes:BB:B\BTo rename some of the attributes provide a list of the form (<old-attribute new-attribute>).B\B*Implementation Type:BB:B\B,To change the implementation type of this relation specify a new value.B\B*lStorage structure:BB:B\BTo change the storage structure of this relation specify a new value.B\B*,Format:BB:B\B,To change the format for this relation specify a new format as a list of values.B\B*Key:BB:B\BTo change the key for this relation specify a new key as a list of attributes.B\B*,Directory Name:BB:B\B,To change the save directory for this relation specify a new directory.B\B*Documentation:BB:B\BNew documentation for the relation.B-B*Give parameters for MODIFY RELATION:BB	\B8B\B\B8B\B8\B:BB	BB	BB	BB	BB	BB	BB	BB	B\B^BCDEFINE-ENVIRONMENTRCHF4$B:Bd]FB:B:B:BFBjB	\BmBBBERRCPAR-CHECKREL-IMPREL-STOÀSTATUSSYS-IMPSYS-STOCVAL-CHECKWARNB:\BB:\B\BBoBB쿶Global variables defining an environment can be set using this function.

   ENVIRONMENT  - Name of the environment.
   AUTO-SAVE    - If T, RTMS saves the database whenever a relation is modified.
   DIRECTORY    - Name of the default directory in which the database is to be saved.
   ERRORS       - If T, error messages are generated.
   PARAMETER-CHECKING - If T, extensive parameter validity checking is done.
   RELATION-IMPLEMENTATION - The default implementation type for the user relations.
   RELATION-STORAGE-STRUCTURE -The default storage structure type for the user relations.
   STATUS       - If T, status messages are generated.
   SYSTEM-IMPLEMENTATION - If there is no active database, this value will be used as the implementation
                           type for implementing system-relations.
   SYSTEM-STORAGE-STRUCTURE - If there is no active database, this value will be used as the storage structure
                              for implementing system-relations.
   VALIDITY     - If T, extensive validity checking is done for user-supplied data.
   WARNINGS     - If T, warning messages are generated.  (DEFINE-ENVIRONMENT ENVIRONMENT &REST KEYWORD-LIST &KEY &OPTIONAL AUTO-SAVE DIRECTORY ERRORS PARAMETER-CHECKING RELATION-IMPLEMENTATION RELATION-STORAGE-STRUCTURE STATUS SYSTEM-IMPLEMENTATION SYSTEM-STORAGE-STRUCTURE VALIDITY WARNINGS &ALLOW-OTHER-KEYS)BBBl~SÀDEFENVCAUTO-SAVEPARABB	B	ÀERRORSB	VALIDITYWARNINGSB	B	BBB	PAPPPQPQ	PQ
PQPQPQPQPQPQPQJPQ	PQ
PQPQPQPQPQPQPQPQPQJ@AQ@QO
B	1\B\B\B8\B^BB	\B8\BlDefine EnvironmentBB
BB
B\\BBeBUsed to define an environment in a given directory.B\\BaBlDefinitionB\B\B*lEnvironment Name:BB:B\B,Name of the environment.B\B*lAuto save:BB:B\BAutomatically saves all the modified relations after each function.BB\B*,Errors:BBB\BControls the printing of the error messages.B\B*Parameter Checking:BBB\B,Controls the checking of the parameters.B\B*,Relation Implementation:BBB\BDefault implementation of the user relations.B\B*Relation storage structure:BBB\BlDefault storage structure for the user relations.B\B*,Status:BBB\BControls the printing of the status messages.B\B*System Implementation:BB:B\BDefault implementation of the system relations. Can not change this when a database is active.B\B*lSystem storage structure:BB:B\BlDefault storage structure for the system relations. Can not change this when a database is active.B\B*lValidity Checking:BBB\BControls the checking of the values during insertion and modification for validity.B\B*lWarnings:BBB\BControls the printing of the warning messages.BB*,Give parameters for DEFINE ENVIRONMENT:BB	\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB	B\B^BDEFINE-RELATION.BHF$B:Bd]FB:B:B:BFBjBF
\	BmBATTR-DESBBBBBBB:\BB:\B\BBoBB쿊Define relations in the active database.

   RELATION-NAME - Name of the relation to be defined.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   DIRECTORY     - Name of the directory in which this relation is to be saved.
   DOCUMENTATION - Description of this relation.
   FORMAT        - List of print-width values correponding to the attribute-list.
   IMPLEMENTATION-TYPE - Name of the implementation for this relation.
   KEY           - List of attributes comprising the key for this relation.
   STORAGE-STRUCTURE   - Name of the storage structure to be used for this relation.  (DEFINE-RELATION RELATION-NAME ATTRIBUTE-DESCRIPTOR &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE KEY STORAGE-STRUCTURE &ALLOW-OTHER-KEYS)BBl~SÀDEFRELTUPLE-FORMATBBBBBBBBV
PAPPPQQPQPQ	PQ
PQPQPQJ@AQQ@QOX
BF
1\B\B\B8\B^BBG
\B8\B,Define RelationBB\
BB\
B\\BBBlused to define a relation.B\\BaBlDefinitionB\B\B*Relation Name:BB:B\BName of the relation to be defined.BBBBBBBBB*Give parameters for DEFINE RELATION:BBT
\B8B\B\B8B\B8\B:BB_
BB\
BB\
BB`
BBb
BBc
BBf
BBT
B\B^BDEFINE-VIEW
A
F$B:Bd]FB:B:B:BFBjBr
\BmVIEWNAMEVIEW-DEFINITIONBB:B:\B\BBoBBlDefine views on the relations.

   VIEW-NAME - Name of the view.
   VIEW-DEF  - Definition of the view.
   DOCUMENTATION - Describes the view.  (DEFINE-VIEW VIEWNAME VIEW-DEF &REST KEYWORD-LIST &KEY &OPTIONAL DOCUMENTATION &ALLOW-OTHER-KEYS)BBl~SDEFVIEWBBB
P@PPPQQQ@QQQ	O
Br
1\B\B\B8\B^BBs
\B8\BꬁDefine ViewBB
BB
B\\BBt	BUsed to define a view.B\\BaBlDefinitionB\B\B*lView Name:BB:B\BSpecify a name for the view.B\B*,View Definition:BBB\BlSpecify a definition for the view.B\B*View Documentation:BB:B\BSpecify documentation for the view.BB*,Give parameters for DEFINE VIEW:BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB

BB
BB
BB
B\B^BDEFINE-ATTRIBUTE
AF$B:Bd]FB:B:B:BFBjB
\BmBBP
BB:\BB:\B\BBoBBAdd a new attribute to a relation.
    All its tuples will get the default value of the attribute for the attribute value.

   RELATION-NAME - Name of the relation.
   ATTRIBUTE-DESCRIPTOR - List of attributes and their descriptions.
   KEY           - If the key for this relation is to be changed, specify it.  (DEFINE-ATTRIBUTE RELATION-NAME ATTRIBUTE-DESCRIPTOR &REST KEYWORD-LIST &KEY &OPTIONAL KEY &ALLOW-OTHER-KEYS)BBl~SB
BBBB
PAPPPQQPQ@	AQQ@Q
O
B
1\B\B\B8\B^BB
\B8\B,Define AttributeBB
BB
B\\BBBUsed to add attributes to relations.B\\BaBlDefinitionB\B\B*,Relation name: BB~B\BlThe name of the relation to which new attributes are to be added.BB\B*Key: BB:B\B,
New key for the relation if it is to be different from the previous value. Specify a list of attributes.BB*Give parameters for DEFINE ATTRIBUTE:BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB
B\B^BÁMODIFY-TUPLES#AHF$B:Bd]FB:B:B:BFBjB
\BmBWHERE-CLAUSEBVALUESB:\BB:\B\BBoBBlThe values of the tuples in a relation can be modified using this function.

   RELATION  - Name of the relation whose tuples are to be modified.
   ATTRIBUTE - List of attributes which are to be modified.
   VALUE     - Corresponding list of values to be used in modifying the above attributes.
   WHERE     - Selection criterion to be used.  (MODIFY-TUPLES RELATION &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE VALUE WHERE &ALLOW-OTHER-KEYS)BBl~SÀMODIFYÀWHEREBB
BBB
PAPPPQPQPQ	PQ
@
AQ@QO
B
1\B\B\B8\B^BB
\B8\BModify TuplesBB
BB
B\\B@MBUsed to modify tuples in a relation.B\\BaBManipulationB\B\B*lRelation: BB~B\BSpecify the relation whose tuples are to be modified.B\B*Where clause: BBB\BProvide a selection criteria.B\B*Attributes: BBB\BlSpecify a list of attributes in the above relation to be modified.B\B*,Values: BBB\BSpecify a corresponding list of values to modify the above attributes.BB*Give parameters for MODIFY TUPLES ==>BB
\B8B\B\B8B\B8\B:BB
BB
BB
BB
BB
BB
BB
BB
B\B^BÁDELETE-TUPLES	@F$B:Bd]FB:B:B:BFBjB\BmBB
B:B:\B\BBoBBDeletes the tuples which satisfy the WHERE clause from the specified relation.

   RELATION - Name of the relation from which the tuples are to be deleted.
   WHERE    - Selection criterion to be used.  (DELETE-TUPLES RELATION &REST KEYWORD-LIST &KEY &OPTIONAL WHERE &ALLOW-OTHER-KEYS)BBl~SBB
BBBP@PPPQPQ	@QPQ
OB1\B\B\B8\B^BB\B8\BDelete TuplesBBBBB\BfBUsed to delete tuples in a relation.B\\BaBManipulationB\B\B*lRelation: BB~B\BlSpecify a relation whose tuples are to be deleted.B\B*Where clause: BB:B\B,Deletes the tuples which satisfy this condition.BB*Give parameters for DELETE TUPLES ==>BB\B8B\B\B8B\B8\B:BB!BBBBBB"BB#BB$BB'BBB\B^BRETRIEVE-TUPLES]F>$B:Bd]FB:B:B:BFBjB7\BmBBB
BNBBBBBBOBPBQBBRBSBTBBUBVBWB.B:\BB:\B\BBoBBORetrieve some tuples from a relation satisying a where clause.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.   (RETRIEVE RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INDEX-NAME INTO KEY NUMBER OUTPUT PRINT PROJECT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WHERE WIDE &ALLOW-OTHER-KEYS)ˀBBl~SBPROJECTB
BNBBBBBBOB^BQBBRB_BTBB`BVBWB.BBBPAPPPQPQQ	PQ
PQPQPQPQPQPQP?BPQPQP
QPQPQPQPQPQPQPQPQ(J@AQ@QOHB71\B\B\B8\B^BB8\B8\B,Retrieve TuplesBBLBBLB\@RBUsed to Retrieve tuples in a relation.B\\BaBlOperatorsB\BBq\B*Attributes: BB:B\BProvide a list of attributes. If not all attributes all used.BB
BuBByBBBB}BBBBB
BBBBB\B*Index-name:BB:B\BlIf the data is to come from an index instead of the base relation.BB*,Give parameters for RETRIEVE TUPLES ==>BBD\B8B\B\B8B\B8\B:BBOBBLBBLBBPBBRBBSBBVBBDB\B^BpBuSELECT Z F=$B:Bd]FB:B:B:BFBjBf\BmBB
BNBBBBBBOBPBQBBRBSBTBBUBVBWB.B:\BB:\B\BBoBBSame as Retrieve except that all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  (SELECT-TUPLES RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INTO KEY NUMBER OUTPUT PRINT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WHERE WIDE &ALLOW-OTHER-KEYS)BBl~SÁSELECT-TUPLESB
BNBBBBBBOB^BQBBRB_BTBB`BVBWB.BBBGBBPAPPPQPQ	PQ
PQPQPQPQPQP?BPQPQPQP
QPQPQPQPQPQPQPQ&J@AQP@QOxBf1\B\B\B8\B^BBh\B8\BSelectBB|BB|B\\BBLBUsed to Select tuples in a relation.B\\BaBlOperatorsB\BBqB
BuBByBBBB}BBBBB
BBBBBB[B*Give parameters for SELECT TUPLES ==>BBt\B8B\B\B8B\B8\B:BBBB|BB|BBBBBBBBBBtB\B^BBG\F=$B:Bd]FB:B:B:BFBjB\BmBBBNBBBBBBOBPBQBBRBSBTBBUBVBWB:\BB:\B\BBoBB#Same as Retrieve except that all tuples are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  (PROJECT RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE INDEX-NAME INTO KEY NUMBER OUTPUT PRINT PROJECT QPRINT QUICK-SORT SORT STREAM STORAGE-STRUCTURE TUPLES UNIQUE WIDE &ALLOW-OTHER-KEYS)BBl~SBGBNBBBBBBOB^BQBBRB_BTBB`BVBWBBB
BBPAPPPQPQQPQ	PQ
PQPQPQPQP?BPQPQPQP
QPQPQPQPQPQPQ$J@AQP@QOB1\B\B\B8\B^BBG\B8\B,ProjectBBBBB\\BBkBUsed to Project tuples in a relation.B\\BaBlOperatorsB\BBqBWBuBByBBBB}BBBBB
BBBBBB*Give parameters for PROJECT TUPLES ==>BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BCCOMMIT-TRANSACTION
 AF$B:Bd]FB:B:B:BFBjB\BmÀTRANSBBB:\BB:\B\BBoBBExecute the database calls in a transaction.

   TRANSACTION - Name of the transaction to be commited.
   DIRECTORY   - Name of the directory in which this transaction can be found, if not in memory.
   PATHNAME    - Name of the file in which it can be found.  (COMMIT-TRANSACTION TRANSACTION &REST KEYWORD-LIST &KEY &OPTIONAL DIRECTORY PATHNAME &ALLOW-OTHER-KEYS)BBl~SBBBBBBPAPPPQPQPQ	@	
AQ@QOB1\B\B\B8\B^BB\B8\BlCommit TransactionBBBBB\\B CBCommit a transaction - execute all the database calls in it.B\\BaBlOperatorsB\B\B*lName of the transaction :BBB\BThe name of an existing transaction.B\B*Name of the directory:BBB\BName of the directory which contains the transaction file, if the transaction is not in the memory.B\B*lPathname:BBB\BIf the transaction is not in memory, provide the pathname for the transaction file. It defaults to <transaction>.lisp.BB*Give parameters for COMMIT TRANSACTIONBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BJOINDCF.$B:Bd]FB:B:B:BFBjB\BmBNFROMBGB
BBBBBBBBTBWB:\BB:\B\BBoBB3This function provides the capability to combine two relations into a new relation
   in which the tuples which are to participate in the operation are selected
   by a where clause.

   FROM                 - A list consisting of the relations to be joined.
   PROJECT              - This clause specifies the attributes that are to be in the resultant relation
                          and their associated names in that new relation. It should be of the form
                          (<[relation-name.]attribute-name>). The optional part relation-name can be
                          skipped if the attribute is unique in one of the two relations being joined.
                          If the keyword FROM is not specified, this clause should contain the names
                          of the relations to be joined. Also, if * is given instead of the attribute-name
                          it indicates that RTMS should use all the attributes in that relation.
   WHERE                - Can be used to perform theta-joins. It is a condition used in joining the relations.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (JOIN &REST KEYWORD-LIST &KEY FROM &KEY &OPTIONAL PROJECT WHERE INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE KEY STORAGE-STRUCTURE PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SBBBGBNBBBBBBBBTB
BWBBBÁJOIN-INTERNALPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQPQP
QJ@APQ@QOB1\B\B\B8\B^BB\B8\B꬀JoinBBBBB\ JB,Used to join relations.B\\BaBlOperatorsB\B\B*lOutput relation :BBB\BIf not provided, the result of JOIN is stored in a temporary relation unless only the resultant tuples are requested.B\B*FROM :BBB\BSpecify a list of two relations to be joined.B\B*lProject :BB:B\B,This gives the attributes in the output relation. Example: (rel1.* a3 (rel2.a1 a4)) ==> All the attributes in rel1, attribute A3 of rel2 and atribute A1 of rel2 renamed as A4.B\B*,Where :BBB\BlThe join clause using the theta-operators. It is a where clause consisting of attributes from the relations being joined.B\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*,Give parameters for JOINBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BDESTROY-DATABASE	@F$B:Bd]FB:B:B:BFBjB!\BmBBB:\BB:\B\BBoBB,Delete the specified database from memory and all the corresponding files from
   disk if the keyword DISK is T.

   DATABASE - Name of the database to be destroyed.
   DISK     - If T, all the relevant files will be deleted.  (DESTROY-DATABASE DATABASE &REST KEYWORD-LIST &KEY &OPTIONAL DISK &ALLOW-OTHER-KEYS)BBl~SB"BBBB"PAPPPQPQ@	AQ@Q
O0B!1\B\B\B8\B^BB"\B8\B,Destroy DatabaseBB4BB4B\\ KBBlUsed to destroy databasesB\\BaBManipulationB\B\B*Database Name:BB:B\BName of the database to be destroyed.B\B*Delete from the DISK:BB:B\BIF YES all the files pertaining to this database are deleted but NOT EXPUNGED.BB*Give parameters for DESTROY DATABASE:BB.\B8B\B\B8B\B8\B:BB7BB4BB4BB8BB;BB<BB?BB.B\B^BÁDESTROY-DOMAIN
@
F$B:Bd]FB:B:B:BFBjBO\BmBB:B:\B\BBoBBDestroys the domain definition but keeps the domain predicate to handle previously defined data.  (DESTROY-DOMAIN DOMAIN-NAME)BBl~SBPBBBPP@PPPQ@Q	O]BO1\B\B\B8\B^BBP\B8\BDestroy DomainBBaBBaB\`KB,Used to destroy domains.B\\BaBManipulationB\B\B*Domain Name:BB:B\BName of the domain to be destroyed.BB*Give parameters for DESTROY DOMAIN:BB[\B8B\B\B8B\B8\B:BBdBBaBBaBBeBBgBBhBBkBB[B\B^BÂDESTROY-IMPLEMENTATION
@
F$B:Bd]FB:B:B:BFBjBw\BmBB:B:\B\BBoBB,Destroys implementation type definition but keeps the accessor functions to handle previously defined relations using this implementation.  (DESTROY-IMPLEMENTATION IMPLEMENTATION-NAME)BBl~SBxBBBxP@PPPQ@Q	OBw1\B\B\B8\B^BBx\B8\BDestroy ImplementationBBBBB\\B:BB,Used to destroy implementations.B\\BaBManipulationB\B\B*Implementation Name:BB:B\BName of the implementation to be destroyed.BB*Give parameters for DESTROY IMPLEMENTATION:BB\B8B\B\B8B\B8\B:BBBBBBBB
BBBBBBBBB\B^BÁDESTROY-INDEX
@
F$B:Bd]FB:B:B:BFBjB\BmBB.B:B:\B\BBoBB,Destroy the specified index which is defined on the specified relation.

   RELATION-NAME - The name of the relation upon which the relation is defined.
   INDEX-NAME - The name of the index to be deleted.  (DESTROY-INDEX RELATION-NAME INDEX-NAME)BBl~SBBBBP@PPPQQ@QQ	OB1\B\B\B8\B^BB\B8\BDestroy IndexBBBBB\\B:BBB,Used to destroy indices.B\\BaBManipulationB\B\B*Relation Name:BB:B\BName of the relation on which the index to be destroyed is defined.B\B*Index Name:BB:B\BlName of the index to be destroyed.BB*lGive parameters for DESTROY INDEX:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BCDESTROY-STORAGE-STRUCTURE
@
F$B:Bd]FB:B:B:BFBjB\BmB0B:B:\B\BBoBB,Destroys storage structure definition but keeps the accessor functions to handle previously defined relations using this structure.  (DESTROY-STORAGE-STRUCTURE STORAGE-STRUCTURE-NAME)BBl~SBBBBP@PPPQ@Q	OB1\B\B\B8\B^BB\B8\BlDestroy Storage StructureBBBBB\\B:BLBUsed to destroy storage structures.B\\BaBManipulationB\B\B*,Storage structure name:BB:B\BName of the storage structure to be destroyed.BB*Give parameters for DESTROY STORAGE STRUCTURE:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BDESTROY-VIEW
@
F$B:Bd]FB:B:B:BFBjB\BmBb	B:B:\B\BBoBB,Destroys the view from memory.  (DESTROY-VIEW VIEW-NAME)BBl~SBBBBP@PPPQ@Q	OB1\B\B\B8\B^BB\B8\BꬁDestroy ViewBBBBB\\B:Bt	BUsed to destroy views.B\\BaBManipulationB\B\B*lView name:BB:B\BlName of the view to be destroyed.BB*lGive parameters for DESTROY VIEW:BB\B8B\B\B8B\B8\B:BBBBBBBB	BBBBBBBBB\B^BDESTROY-RELATION	@F$B:Bd]FB:B:B:BFBjB\BmBBB:\BB:\B\BBoBBlDeletes the specified relation from the active database.
   Deletes all the files on disk if keyword DISK is t.

   RELATION - Name of the relation to be destroyed.
   DISK     - If T, the relevant files will be deleted.  (DESTROY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL DISK &ALLOW-OTHER-KEYS)BBl~SBBBBBPAPPPQPQ@	AQ@Q
O*B1\B\B\B8\B^BB\B8\B,Destroy RelationBB.BB.B\\B:BBlUsed to destroy relationsB\\BaBManipulationB\B\B*Relation Name:BB:B\BName of the relation to be destroyed.B\B*Delete from the DISK:BB:B\BIF YES the file corresponding to this relation is deleted but NOT EXPUNGED.BB*Give parameters for DESTROY RELATION:BB(\B8B\B\B8B\B8\B:BB1BB.BB.BB2BB4BB5BB8BB(B\B^BCDESTROY-ATTRIBUTE
 AF$B:Bd]FB:B:B:BFBjBH\BmBBBB:\BB:\B\BBoBB,Attributes in a relation can be deleted using this function.

   RELATION-NAME - Name of the relation from which the attributes are to be deleted.
   ATTRIBUTE     - List of attributes to be destroyed.
   KEY           - List of attributes to form the new key, if so desired.  (DESTROY-ATTRIBUTE RELATION-NAME &REST KEYWORD-LIST &KEY &OPTIONAL ATTRIBUTE KEY &ALLOW-OTHER-KEYS)BBl~SBIBBBBBIPAPPPQPQPQ	@	
AQ@QOWBH1\B\B\B8\B^BBI\B8\BlDestroy AttributeBB[BB[B\\B:BBlUsed to destroy attributes from relationsB\\BaBManipulationB\B\B*Relation Name:BB:B\B,Name of the relation from which attributes are to be destroyed.B\B*Attributes:BB:B\BList of attributes to destroy.B\B*Key:BB:B\B,New key for the relation if it is to be different from the previous value or if any of the key attributes are destroyed.BB*Give parameters for DESTROY ATTRIBUTE:BBU\B8B\B\B8B\B8\B:BB^BB[BB[BB_BBaBBbBBeBBUB\B^BUNION9CF'$B:Bd]FB:B:B:BFBjBy\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBBsUnion of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the UNION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-UNION &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SÁRELATION-UNIONBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOBy1\B\B\B8\B^BBz\B8\BUnionBB
BB
B\\ O UBUsed to form union of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\BList of the names of two relations which will take part in the relation union operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*Parameters for the set-union of two relationsBB\B8B\B\B8B\B8\B:BBBB
BB
BBBBBBBBBBB\B^BCDIFFERENCE9CF'$B:Bd]FB:B:B:BFBjB\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBB|Difference of the tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the DIFFERENCE operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-DIFFERENCE &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SRELATION-DIFFERENCEBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOB1\B\B\B8\B^BB\B8\BlDifferenceBBBBB\\BBBUsed to form difference of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\B,List of the names of two relations which will take part in the relation difference operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*lParameters for the set-difference of two relationsBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BINTERSECTION9CF'$B:Bd]FB:B:B:BFBjB\BmBBNBBBBBBBBTBWB:\BB:\B\BBoBB}Intersection of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the INTERSECTION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.  (RELATION-INTERSECTION &REST KEYWORD-LIST &KEY &OPTIONAL FROM INTO DIRECTORY DOCUMENTATION FORMAT IMPLEMENTATION-TYPE STORAGE-STRUCTURE KEY PRINT TUPLES UNIQUE &ALLOW-OTHER-KEYS)BBl~SÂRELATION-INTERSECTIONBNBBBBBBBBBTBWBBBPAPPPPQPQ	PQ
PQPQPQPQPQPQPQPQJ@A@QOB1\B\B\B8\B^BB\B8\BꬁIntersectionBBBBB\\BBBUsed to form intersection of two compatible relationsB\\BaBlOperatorsB\B\B*List of two relations:BB:B\BlList of the names of two relations which will take part in the relation intersection operation. The attributes to be projected and a where clause can be specified for each relation using keywords. For instance, (REL1 (PROJECT <attr> WHERE <where-claue>) REL2 (WHERE <where-clause> PROJECT <attr>)).BBu\B*,Tuples?BB:B\B,Specify if the resultant tuples be returned rather than inserted in a relation. The following parameters can be ignored if this is true.BBBByBBBBBB*Parameters for the set-intersection of two relationsBB\B8B\B\B8B\B8\B:BBBBBBBBBBBBBBBBB\B^BAVERAGE(AF$B:Bd]FB:B:B:BFBjB\BmBBBWB
CBYBB:\BB:\B\BBoBBIAverage of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose average is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group average of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (AVERAGE RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SBBWB
BBBBBPAPPPQQPQPQ	PQ
PQJ@AQQ@QOB1\B\B\B8\B^BB\B8\B,AverageBBBBB\\BBBlUsed to compute the average of the attribute values in a relation.B\\BaBlOperatorsB\	B\B*Relation name:BB~B\BlName of the relation which contains the attribute to be averaged.B\B*,Attribute name:BB:B\BName of the attribute in the above relation.B\B*,Unique?BB:B\BlIf true, only the unique values of the attribute will be used in the calculations.BB
\B*lByBB:B\BSpecify the attribute to be used in grouping the data into categories.BBB*,Parameters for average:BB\B8B\B\B8B\B8\B:BBBBBBBBBBBB BB#BBB\B^BSUM(AF$B:Bd]FB:B:B:BFBjB;\BmBBBWB
BBB:\BB:\B\BBoBBASum of the values of a given attribute in a relation satisfying a where clause.

   RELATION-NAME  - Name of the relation.
   ATTRIBUTE-NAME - Name of the attribute whose sum is to be found.
   UNIQUE         - If T, only unique values will be used.
   WHERE          - If a selection criterion is provided, only the satisfying values will be used.
   BY             - Name of the attribute to group sum of the above attribute by.
   TUPLES         - If T, the resultant values will be returned rather than printed out as a table.  (SUM RELATION-NAME ATTRIBUTE-NAME &REST KEYWORD-LIST &KEY &OPTIONAL UNIQUE WHERE BY TUPLES &ALLOW-OTHER-KEYS)BBl~SB<BWBBB
BBB<PAPPPQQPQPQ	PQ
PQJ@AQQ@QOJB;1\B\B\B8\B^BB<\B8\B꬀SumBBNBBNB\\BBLBUsed to compute the sum of the attribute values in a relation.B\\BaBlOperatorsB\	B\B*Relation name:BB~B\B,Name of the relation which contains the attrLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540758. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MACROS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846222. :AUTHOR "REL3" :LENGTH-IN-BYTES 11371. :LENGTH-IN-BLOCKS 12. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; MACROS*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp d as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;*
;1;; This file comtains the following obsolete functions*
;1;;*
;1;; This file contains the following functions which are unknown in CommonLisp*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;*

(defmacro abort-transaction* (&rest ignore)
  `(abort-transaction))

(defmacro active-database* ()
  `(active-database))

(defmacro active-db* ()
  `(active-database))

(defmacro andp (&rest predicates)
  `(and* (quote ,predicates) t))


(defmacro attach-relation* (relation-name &rest keyword-list)
  `(attach-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro average* (relation-name attribute-name &rest keyword-list)
`(average (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro begin-transaction* (&rest ignore)
  `(begin-transaction))

(defmacro commit-transaction* (transaction &rest keyword-list)
  `(commit-transaction (quote ,transaction) (quote ,keyword-list)))

(defmacro count-rtms* (relation-name attribute-name &rest keyword-list)
`(count-rtms (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro define-attribute* (relation attr-des &rest keyword-list)
`(define-attribute (quote ,relation) (quote ,attr-des) (quote ,keyword-list)))

(defmacro defattr* (relation attr-des &rest keyword-list)
`(define-attribute (quote ,relation) (quote ,attr-des) (quote ,keyword-list)))

(defmacro defdb* (db-name &rest keyword-list)
`(define-database (quote ,db-name) (quote ,keyword-list)))

(defmacro define-database* (db-name &rest keyword-list)
`(define-database (quote ,db-name) (quote ,keyword-list)))

(defmacro define-domain* (domain-name &rest keyword-list)
 `(define-domain (quote ,domain-name) (quote ,keyword-list)))

(defmacro defenv* (environment-name &rest keyword-list)
`(define-environment (quote ,environment-name) (quote ,keyword-list)))

(defmacro define-environment* (environment-name &rest keyword-list)
`(define-environment (quote ,environment-name) (quote ,keyword-list)))

(defmacro define-implementation* (implementation-name &rest keyword-list)
  `(define-implementation (quote ,implementation-name) (quote ,keyword-list)))

(defmacro define-index* (relation &rest keyword-list)
`(define-index (quote ,relation) (quote ,keyword-list)))

(defmacro define-storage-structure* (storage-structure-name &rest keyword-list)
  `(define-storage-structure (quote ,storage-structure-name) (quote ,keyword-list)))

(defmacro defrel* (relation-name attribute-descriptor &rest keyword-list)
  `(define-relation (quote ,relation-name) (quote ,attribute-descriptor) (quote ,keyword-list)))

(defmacro define-relation* (relation-name attribute-descriptor &rest keyword-list)
  `(define-relation (quote ,relation-name) (quote ,attribute-descriptor) (quote ,keyword-list)))

(defmacro define-transaction* (transaction forms &rest keyword-list)
  `(define-transaction (quote ,transaction) (quote ,forms) (quote ,keyword-list)))

(defmacro defrel-restore (relation-name attribute-descriptor &rest keyword-list)
  `(defrel-restore* (quote ,relation-name) (quote ,attribute-descriptor) (quote ,keyword-list)))

(defmacro defview* (viewname viewdef)
  `(define-view (quote ,viewname) (quote ,viewdef)))

(defmacro define-view* (viewname viewdef)
  `(define-view (quote ,viewname) (quote ,viewdef)))

(defmacro delete-tuples* (relation &rest keyword-list)
  `(delete-tuples (quote ,relation) (quote ,keyword-list)))

(defmacro destroy-attr* (relation &rest keyword-list)
`(destroy-attribute (quote ,relation) (quote ,keyword-list)))

(defmacro destroy-attribute* (relation &rest keyword-list)
`(destroy-attribute (quote ,relation) (quote ,keyword-list)))

(defmacro destroy-db* (db-name &rest keyword-list)
  `(destroy-database (quote ,db-name) (quote ,keyword-list)))

(defmacro destroy-database* (db-name &rest keyword-list)
  `(destroy-database (quote ,db-name) (quote ,keyword-list)))

(defmacro destroy-domain* (domain-name)
  `(destroy-domain (quote ,domain-name)))

(defmacro destroy-implementation* (implementation-name)
  `(destroy-implementation (quote ,implementation-name)))

(defmacro destroy-index* (relation-name index-name &rest keyword-list)
  `(destroy-index (quote ,relation-name) (quote ,index-name) (quote ,keyword-list)))

(defmacro destroy-relation* (relation-name &rest keyword-list)
  `(destroy-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro destroy-rel* (relation-name &rest keyword-list)
  `(destroy-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro destroy-storage-structure* (storage-structure-name)
  `(destroy-storage-structure (quote ,storage-structure-name)))

(defmacro destroy-view* (view-name)
  `(destroy-view (quote ,view-name)))

(defmacro describe* (&optional object &rest ignore)
  `(help (quote ,object)))

(defmacro detach-relation* (relation-name &rest keyword-list)
  `(detach-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro end-transaction* (&rest ignore)
  `(end-transaction))

(defmacro envstat* ()
  (environment-status))

(defmacro environment-status* ()
  (environment-status))

(defmacro equalp* (&rest items)
  `(*equalp (quote ,items)))

(defmacro gep* (&rest items)
  `(gep (quote ,items)))

(defmacro gtp* (&rest items)
  `(gtp (quote ,items)))

(defmacro help* (&optional object &rest ignore)
  `(help (quote ,object)))

(defmacro insert* (relation &rest keyword-list)
  `(insert (quote ,relation) (quote ,keyword-list)))

(defmacro insert-tuples* (relation &rest keyword-list)
  `(insert (quote ,relation) (quote ,keyword-list)))

(defmacro join* (&rest keyword-list)
  `(join (quote ,keyword-list)))

(defmacro lep* (&rest items)
  `(lep (quote ,items)))

(defmacro ltp* (&rest items)
  `(ltp (quote ,items)))

(defmacro loaddb* (dbname &rest keyword-list)
  `(load-database (quote ,dbname) (quote ,keyword-list)))

(defmacro load-database* (dbname &rest keyword-list)
  `(load-database (quote ,dbname) (quote ,keyword-list)))

(defmacro load-env* (envname &rest keyword-list)
  `(load-environment (quote ,envname) (quote ,keyword-list)))

(defmacro load-environment* (envname &rest keyword-list)
  `(load-environment (quote ,envname) (quote ,keyword-list)))

(defmacro load-rel* (relation-name &rest keyword-list)
  `(load-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro load-relation* (relation-name &rest keyword-list)
  `(load-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro maptuple* (dbfunction relation-name)
  `(maptuple (quote ,dbfunction) (quote ,relation-name)))

(defmacro mapt* (dbfunction relation-name)
  `(mapt (quote ,dbfunction) (quote ,relation-name)))

(defmacro modify* (relation &rest keyword-list)
  `(modify (quote ,relation) (quote ,keyword-list)))

(defmacro modify-attribute* (relation attribute &rest keyword-list)
  `(modify-attribute (quote ,relation) (quote ,attribute) (quote ,keyword-list)))

(defmacro modify-database* (database &rest keyword-list)
  `(modify-database (quote ,database) (quote ,keyword-list)))

(defmacro modify-relation* (relation &rest keyword-list)
  `(modify-relation (quote ,relation) (quote ,keyword-list)))

(defmacro modify-domain* (domain-name &rest keyword-list)
  `(modify-domain (quote ,domain-name) (quote ,keyword-list)))

(defmacro modify-transaction* (transaction &rest keyword-list)
  `(modify-transaction (quote ,transaction) (quote ,keyword-list)))

(defmacro modify-tuples* (relation &rest keyword-list)
  `(modify (quote ,relation) (quote ,keyword-list)))

(defmacro modify-view* (view-name &rest keyword-list)
  `(modify-view (quote ,view-name) (quote ,keyword-list)))

(defmacro maximum* (relation-name attribute-name &rest keyword-list)
  `(maximum (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro minimum* (relation-name attribute-name &rest keyword-list)
  `(minimum (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro notp* (&rest items)
  `(notp (quote ,items)))

(defmacro printrel* (relation &rest keyword-list)
  `(print-relation (quote ,relation) (quote ,keyword-list)))

(defmacro print-relation* (relation &rest keyword-list)
  `(print-relation (quote ,relation) (quote ,keyword-list)))

(defmacro project* (relation-name &rest keyword-list)
  `(project (quote ,relation-name) (quote ,keyword-list)))

(defmacro r (relation-name &rest keyword-list)
  `(retrieve (quote ,relation-name) (quote ,keyword-list)))

(defmacro relation-difference* (&rest keyword-list)
  `(relation-difference (quote ,keyword-list)))

(defmacro relation-intersection* (&rest keyword-list)
  `(relation-intersection (quote ,keyword-list)))

(defmacro relation-union* (&rest keyword-list)
  `(relation-union  (quote ,keyword-list)))

(defmacro rename-attr* (relation-name &rest attributes)
  `(rename-attribute (quote ,relation-name) (quote ,attributes)))


(defmacro rename-attribute* (relation-name &rest attributes)
  `(rename-attribute (quote ,relation-name) (quote ,attributes)))

(defmacro rename-database* (&rest databases)
  `(rename-database (quote ,databases)))

(defmacro rename-db* (&rest databases)
  `(rename-database (quote ,databases)))

(defmacro rename-relation* (&rest relations)
  `(rename-relation (quote ,relations)))

(defmacro rename-rel* (&rest relations)
  `(rename-relation (quote ,relations)))

(defmacro retrieve* (relation-name &rest keyword-list)
  `(retrieve (quote ,relation-name) (quote ,keyword-list)))

(defmacro rtms-count* (relation-name attribute-name &rest keyword-list)
`(count-rtms (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro save-db* (&optional (dbname *active-db*) &rest keyword-list)
  `(save-database (quote ,dbname) (quote ,keyword-list)))

(defmacro save-database* (&optional (dbname *active-db*) &rest keyword-list)
  `(save-database (quote ,dbname) (quote ,keyword-list)))

(defmacro save-env* (&optional (envname *environment-name*) &rest keyword-list)
  `(save-environment (quote ,envname) (quote ,keyword-list)))

(defmacro save-environment* (&optional (envname *environment-name*) &rest keyword-list)
  `(save-environment (quote ,envname) (quote ,keyword-list)))

(defmacro save-rel* (relation-name &rest keyword-list)
  `(save-relation (quote ,relation-name) (quote ,keyword-list)))

(defmacro save-relation* (relation-name &rest keyword-list)
  `(save-relation  (quote ,relation-name) (quote ,keyword-list)))

(defmacro save-transaction* (transaction-name &rest keyword-list)
  `(save-transaction (quote ,transaction-name) (quote ,keyword-list)))

(defmacro select-tuples* (relation-name &rest keyword-list)
  `(select-tuples (quote ,relation-name) (quote ,keyword-list)))

(defmacro sum* (relation-name attribute-name &rest keyword-list)
  `(sum (quote ,relation-name) (quote ,attribute-name) (quote ,keyword-list)))

(defmacro size* (relation-name &rest keyword-list)
  `(size (quote ,relation-name) (quote ,keyword-list)))

BZBBZBB^BBBBUB\B^BB@DF$B:Bd]FB:B:B:BFBjBf\BmB:\COMMAND\B\BBoBBIntroduction to the interface. Help on any database object (COMMAND / RELATION / ATTRIBUTE).pBuSELFÁ*HELP-SUBMENU*SUBMENU-CHOOSE)EXECUTEPPC@PP@ROyBf1\B\B\B8\B^BB\B8\B꬀HelpBB}BB}BBjB,Introduction to the interface. Help on any database object (COMMAND/RELATION/ATTRIBUTE).BBs\B8B\B\B8B\B8\B:BBBB}BB}BBjBBBBsB\B^BBa@DF$B:Bd]FB:B:B:BFBjB\BmB:\Bp\B\BBoBB,Select a database command from a menu. A choose-variable-values window will be presented to get the arguments LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540761. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "MACROS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359691. :AUTHOR "REL3" :LENGTH-IN-BYTES 11689. :LENGTH-IN-BLOCKS 23. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8MACROS\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPCABORT-TRANSACTION*$@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\pB\l*MACROARG*j&OPTIONALpB\l*MACROENVIRONMENT*B:B:\EXPR-SXHASH&,*DESCRIPTIVE-ARGLIST\&RESTIGNORE\CABORT-TRANSACTIONDpBTMACROBnOqBPACTIVE-DATABASE*$@F
$B:BV]FB:B:B:BYFB^BrB_B:B:\Bf
BhB:pB\,MACRO-REPORT-ARGS-ERROR\ACTIVE-DATABASEQJQJJDBpBOBrCACTIVE-DB*$@F
$B:BV]FB:B:B:BYFB^BB_B:B:\Bf:FyBhB:B}\BQJQJJDBpB
OBANDP$@F$B:BV]FB:B:B:BYFB^BB_B:B:\BfV)MACROS-EXPANDED\pB\lXR-BQ-LISTpB\XR-BQ-LIST*Bh\BjCPREDICATESAND*B8LIST\BYLIST*PPUPDBpBOBATTACH-RELATION*	DF$B:BV]FB:B:B:BYFB^BB_B:\ÁRELATION-NAME\Bf"7B\BBh\BBjKEYWORD-LISTB}ATTACH-RELATIONB8BQJQJW@PP@QPYDBpBOBAVERAGE*HF$B:BV]FB:B:B:BYFB^BB_B:\BÁATTRIBUTE-NAME\BfJ{B\BBh\BBBjBB}AVERAGEB8BQJQJW@[APP@QPAQPQBDBpBOBCBEGIN-TRANSACTION*$@F$B:BV]FB:B:B:BYFB^BB_B:B:\Bfb|Bh\BjBk\CBEGIN-TRANSACTIONDBpBOBCOMMIT-TRANSACTION*	DF$B:BV]FB:B:B:BYFB^BB_B:\TRANSACTION\Bf~)B\BBh\BBjBB}CCOMMIT-TRANSACTIONB8BQJQJW@PP@QPYDBpBOBCOUNT-RTMS*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\BfJ[B\BBh\BBBjBB}CCOUNT-RTMSB8BQJQJW@[APP@QPAQPQBDBpBOBCDEFINE-ATTRIBUTE*HF$B:BV]FB:B:B:BYFB^BB_B:\RELATIONATTR-DES\BfǐB\BBh\BBBjBB}DEFINE-ATTRIBUTEB8BQJQJW@[APP@QPAQPQBDBpB
OBDEFATTR*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\Bf&OB\BBh\BBBjBB}B	B8BQJQJW@[APP@QPAQPQBDBpBOBÀDEFDB*	DF$B:BV]FB:B:B:BYFB^BB_B:\DB-NAME\Bf6B\BBh\B$BjBB}DEFINE-DATABASEB8BQJQJW@PP@QPYDBpB*O+BDEFINE-DATABASE*	DF$B:BV]FB:B:B:BYFB^B,B_B:\B$\BfbB\BBh\B$BjBB}B)B8BQJQJW@PP@QPYDBpB9O:B,ÁDEFINE-DOMAIN*	DF$B:BV]FB:B:B:BYFB^B;B_B:\DOMAIN-NAME\Bf
qB\BBh\BDBjBB}ÁDEFINE-DOMAINB8BQJQJW@PP@QPYDBpBJOKB;DEFENV*	DF$B:BV]FB:B:B:BYFB^BLB_B:\ENVIRONMENT-NAME\Bf.B\BBh\BUBjBB}CDEFINE-ENVIRONMENTB8BQJQJW@PP@QPYDBpB[O\BLDEFINE-ENVIRONMENT*	DF$B:BV]FB:B:B:BYFB^B]B_B:\BU\BfR~B\BBh\BUBjBB}BZB8BQJQJW@PP@QPYDBpBjOkB]ÂDEFINE-IMPLEMENTATION*	DF$B:BV]FB:B:B:BYFB^BlB_B:\IMPLEMENTATION-NAME\Bfn"B\BBh\BuBjBB}ÂDEFINE-IMPLEMENTATIONB8BQJQJW@PP@QPYDBpB{O|BlÁDEFINE-INDEX*	DF$B:BV]FB:B:B:BYFB^B}B_B:\B\Bf~?B\BBh\BBjBB}҃DEFINE-INDEXB8BQJQJW@PP@QPYDBpBOB}CDEFINE-STORAGE-STRUCTURE*	DF$B:BV]FB:B:B:BYFB^B
B_B:\ÂSTORAGE-STRUCTURE-NAME\BfB\BBh\BBjBB}DEFINE-STORAGE-STRUCTUREB8BQJQJW@PP@QPYDBpBOB
DEFREL*HF$B:BV]FB:B:B:BYFB^BB_B:\BATTRIBUTE-DESCRIPTOR\Bf2hB\BBh\BBBjBB}DEFINE-RELATIONB8BQJQJW@[APP@QPAQPQBDBpBOBDEFINE-RELATION*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\Bf
!B\BBh\BBBjBB}BB8BQJQJW@[APP@QPAQPQBDBpBOBDEFINE-TRANSACTION*HF$B:BV]FB:B:B:BYFB^BB_B:\BÀFORMS\BfNB\BBh\BBBjBB}CDEFINE-TRANSACTIONB8BQJQJW@[APP@QPAQPQBDBpBOBÁDEFREL-RESTOREHF$B:BV]FB:B:B:BYFB^BB_B:\BB\Bf:.B\BBh\BBBjBB}DEFREL-RESTORE*B8BQJQJW@[APP@QPAQPQBDBpBOBDEFVIEW*DF$B:BV]FB:B:B:BYFB^BB_B:\VIEWNAME\BfB@B\BBh\BVIEWDEFB}҃DEFINE-VIEWB8BQJQJQJJW@PP@QP[DBpBOBDEFINE-VIEW*DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfVs&B\BBh\BBB}BB8BQJQJQJJW@PP@QP[DBpBOBÁDELETE-TUPLES*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf~B\BBh\BBjBB}ÁDELETE-TUPLESB8BQJQJW@PP@QPYDBpBOBÁDESTROY-ATTR*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfzLB\BBh\BBjBB}CDESTROY-ATTRIBUTEB8BQJQJW@PP@QPYDBpBOBCDESTROY-ATTRIBUTE*	DF$B:BV]FB:B:B:BYFB^B B_B:\B\Bf~?QB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpB-O.B DESTROY-DB*	DF$B:BV]FB:B:B:BYFB^B/B_B:\B$\Bf
{VB\BBh\B$BjBB}DESTROY-DATABASEB8BQJQJW@PP@QPYDBpB=O>B/CDESTROY-DATABASE*	DF$B:BV]FB:B:B:BYFB^B?B_B:\B$\Bfbt6B\BBh\B$BjBB}B<B8BQJQJW@PP@QPYDBpBLOMB?DESTROY-DOMAIN*	$@F$B:BV]FB:B:B:BYFB^BNB_B:B:\Bf~B\BBh\BDB}ÁDESTROY-DOMAINB8BQJQJQJJPPWDBpB[O\BNDESTROY-IMPLEMENTATION*	$@F$B:BV]FB:B:B:BYFB^B]B_B:B:\BfB\BBh\BuB}ÂDESTROY-IMPLEMENTATIONB8BQJQJQJJPPWDBpBjOkB]ÁDESTROY-INDEX*HF$B:BV]FB:B:B:BYFB^BlB_B:\BCINDEX-NAME\Bf&B\BBh\BBuBjBB}ÁDESTROY-INDEXB8BQJQJW@[APP@QPAQPQBDBpB{O|BlCDESTROY-RELATION*	DF$B:BV]FB:B:B:BYFB^B}B_B:\B\Bf"B\BBh\BBjBB}DESTROY-RELATIONB8BQJQJW@PP@QPYDBpBOB}DESTROY-REL*	DF$B:BV]FB:B:B:BYFB^B
B_B:\B\BfvkB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOB
CDESTROY-STORAGE-STRUCTURE*	$@F$B:BV]FB:B:B:BYFB^BB_B:B:\BffIB\BBh\BB}CDESTROY-STORAGE-STRUCTUREB8BQJQJQJJPPWDBpBOBÁDESTROY-VIEW*	$@F$B:BV]FB:B:B:BYFB^BB_B:B:\Bf:OB\BBh\CVIEW-NAMEB}҃DESTROY-VIEWB8BQJQJQJJPPWDBpBOBCDESCRIBE*DF
$B:BV]FB:B:B:BYFB^BB_B:\ÀOBJECT\BfZxB\BBh\BbBBjBkHELPB8BW@PP@QDBpBOBDETACH-RELATION*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf"7B\BBh\BBjBB}DETACH-RELATIONB8BQJQJW@PP@QPYDBpBOBEND-TRANSACTION*$@F$B:BV]FB:B:B:BYFB^BB_B:B:\BfFgBh\BjBk\END-TRANSACTIONDBpBOBENVSTAT*$@F
$B:BV]FB:B:B:BYFB^BB_B:B:\BfjBhB:B}CENVIRONMENT-STATUSQJQJJDBpBOBENVIRONMENT-STATUS*$@F
$B:BV]FB:B:B:BYFB^BB_B:B:\Bf&BhB:B}BQJQJJDBpBOBEQUALP*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\Bf::&B\BBh\BjÀITEMS*EQUALPB8BPPUDBpBOBGEP*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\BfVB\BBh\BjBGEPB8BPPUDBpB!O"BGTP*$@F	$B:BV]FB:B:B:BYFB^B#B_B:B:\BfcFB\BBh\BjBGTPB8BPPUDBpB0O1B#ÀHELP*DF
$B:BV]FB:B:B:BYFB^B2B_B:\B\BfvLAB\BBh\BbBBjBkBB8BW@PP@QDBpB?O@B2INSERT*	DF$B:BV]FB:B:B:BYFB^BAB_B:\B\Bf~ߙB\BBh\BBjBB}ÀINSERTB8BQJQJW@PP@QPYDBpBOOPBAÁINSERT-TUPLES*	DF$B:BV]FB:B:B:BYFB^BQB_B:\B\BfHB\BBh\BBjBB}BNB8BQJQJW@PP@QPYDBpB^O_BQÀJOIN*$@F	$B:BV]FB:B:B:BYFB^B`B_B:B:\Bf:KB\BBh\BjBJOINB8BPPUDBpBmOnB`LEP*$@F	$B:BV]FB:B:B:BYFB^BoB_B:B:\BfrB\BBh\BjBLEPB8BPPUDBpB|O}BoLTP*$@F	$B:BV]FB:B:B:BYFB^B~B_B:B:\BfB\BBh\BjBLTPB8BPPUDBpBOB~LOADDB*	DF$B:BV]FB:B:B:BYFB^B
B_B:\ÀDBNAME\BfZ\0B\BBh\BBjBB}ÁLOAD-DATABASEB8BQJQJW@PP@QPYDBpBOB
ÁLOAD-DATABASE*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfZBB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBCLOAD-ENV*	DF$B:BV]FB:B:B:BYFB^BB_B:\ENVNAME\Bf6vB\BBh\BBjBB}LOAD-ENVIRONMENTB8BQJQJW@PP@QPYDBpBOBCLOAD-ENVIRONMENT*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfYXB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBCLOAD-REL*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfrbB\BBh\BBjBB}ÁLOAD-RELATIONB8BQJQJW@PP@QPYDBpBOBÁLOAD-RELATION*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf"xB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBCMAPTUPLE*DF$B:BV]FB:B:B:BYFB^BB_B:\CDBFUNCTION\BfByB\BBh\BBB}MAPTUPLEB8BQJQJQJJW@PP@QP[DBpBOBÀMAPT*DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfBB\BBh\BBB}҃MAPTB8BQJQJQJJW@PP@QP[DBpBOBMODIFY*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf~B\BBh\BBjBB}ÀMODIFYB8BQJQJW@PP@QPYDBpBOBCMODIFY-ATTRIBUTE*HF$B:BV]FB:B:B:BYFB^BB_B:\BCATTRIBUTE\Bf~fB\BBh\BB&BjBB}MODIFY-ATTRIBUTEB8BQJQJW@[APP@QPAQPQBDBpB,O-BMODIFY-DATABASE*	DF$B:BV]FB:B:B:BYFB^B.B_B:\DATABASE\Bf::yB\BBh\B7BjBB}MODIFY-DATABASEB8BQJQJW@PP@QPYDBpB=O>B.MODIFY-RELATION*	DF$B:BV]FB:B:B:BYFB^B?B_B:\B\Bf~B\BBh\BBjBB}MODIFY-RELATIONB8BQJQJW@PP@QPYDBpBMONB?ÁMODIFY-DOMAIN*	DF$B:BV]FB:B:B:BYFB^BOB_B:\BD\Bf
OB\BBh\BDBjBB}ÁMODIFY-DOMAINB8BQJQJW@PP@QPYDBpB]O^BOMODIFY-TRANSACTION*	DF$B:BV]FB:B:B:BYFB^B_B_B:\B\Bf~cB\BBh\BBjBB}CMODIFY-TRANSACTIONB8BQJQJW@PP@QPYDBpBmOnB_ÁMODIFY-TUPLES*	DF$B:BV]FB:B:B:BYFB^BoB_B:\B\BfRB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpB|O}BoMODIFY-VIEW*	DF$B:BV]FB:B:B:BYFB^B~B_B:\B\BfNjjB\BBh\BBjBB}҃MODIFY-VIEWB8BQJQJW@PP@QPYDBpBO
B~MAXIMUM*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\BfJB\BBh\BBBjBB}MAXIMUMB8BQJQJW@[APP@QPAQPQBDBpBOBMINIMUM*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\BfJ[B\BBh\BBBjBB}MINIMUMB8BQJQJW@[APP@QPAQPQBDBpBOBÀNOTP*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\Bf2kNB\BBh\BjBNOTPB8BPPUDBpBOBCPRINTREL*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfB\BBh\BBjBB}ÁPRINT-RELATIONB8BQJQJW@PP@QPYDBpBOBPRINT-RELATION*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf~?B\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBPROJECT*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf""B\BBh\BBjBB}PROJECTB8BQJQJW@PP@QPYDBpBOBCR	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf
B\BBh\BBjBB}RETRIEVEB8BQJQJW@PP@QPYDBpBOBRELATION-DIFFERENCE*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\BfZ@B\BBh\BjBRELATION-DIFFERENCEB8BPPUDBpB	O
BÂRELATION-INTERSECTION*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\BfӔB\BBh\BjBÂRELATION-INTERSECTIONB8BPPUDBpBOBRELATION-UNION*$@F	$B:BV]FB:B:B:BYFB^BB_B:B:\BfFB\BBh\BjBÁRELATION-UNIONB8BPPUDBpB'O(BRENAME-ATTR*	DF$B:BV]FB:B:B:BYFB^B)B_B:\B\Bf
bB\BBh\BBjCATTRIBUTESB}RENAME-ATTRIBUTEB8BQJQJW@PP@QPYDBpB8O9B)CRENAME-ATTRIBUTE*	DF$B:BV]FB:B:B:BYFB^B:B_B:\B\Bf"-B\BBh\BBjB6B}B7B8BQJQJW@PP@QPYDBpBGOHB:RENAME-DATABASE*$@F	$B:BV]FB:B:B:BYFB^BIB_B:B:\BfnaB\BBh\BjCDATABASESRENAME-DATABASEB8BPPUDBpBWOXBICRENAME-DB*$@F	$B:BV]FB:B:B:BYFB^BYB_B:B:\Bfj\B\BBh\BjBUBVB8BPPUDBpBeOfBYRENAME-RELATION*$@F	$B:BV]FB:B:B:BYFB^BgB_B:B:\Bf
*IB\BBh\BjCRELATIONSRENAME-RELATIONB8BPPUDBpBuOvBgRENAME-REL*$@F	$B:BV]FB:B:B:BYFB^BwB_B:B:\Bf."B\BBh\BjBsBtB8BPPUDBpBOBwCRETRIEVE*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf"7`B\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBRTMS-COUNT*HF$B:BV]FB:B:B:BYFB^BB_B:\BB\Bfv_B\BBh\BBBjBB}BB8BQJQJW@[APP@QPAQPQBDBpBOBSAVE-DB*DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf&,B\BBh\Bb\B*ACTIVE-DB*BjBBÁSAVE-DATABASEB8BWP@PP@QPYDBpBOBÁSAVE-DATABASE*DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfB\BBh\Bb\BBBjBBBB8BWP@PP@QPYDBpBOBCSAVE-ENV*DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfTB\BBh\Bb\BC*ENVIRONMENT-NAME*BjBBSAVE-ENVIRONMENTB8BWP@PP@QPYDBpBOBCSAVE-ENVIRONMENT*DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf*lB\BBh\Bb\BBBjBBBB8BWP@PP@QPYDBpBOBCSAVE-REL*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\BfHB\BBh\BBjBB}ÁSAVE-RELATIONB8BQJQJW@PP@QPYDBpBOBÁSAVE-RELATION*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf"7B\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpBOBCSAVE-TRANSACTION*	DF$B:BV]FB:B:B:BYFB^BB_B:\TRANSACTION-NAME\BfFB\BBh\BBjBB}SAVE-TRANSACTIONB8BQJQJW@PP@QPYDBpBOBÁSELECT-TUPLES*	DF$B:BV]FB:B:B:BYFB^BB_B:\B\Bf"B\BBh\BBjBB}ÁSELECT-TUPLESB8BQJQJW@PP@QPYDBpB%O&BSUM*HF$B:BV]FB:B:B:BYFB^B'B_B:\BB\BfJB\BBh\BBBjBB}҃SUMB8BQJQJW@[APP@QPAQPQBDBpB5O6B'ÀSIZE*	DF$B:BV]FB:B:B:BYFB^B7B_B:\B\Bf"7B\BBh\BBjBB}҃SIZEB8BQJQJW@PP@QPYDBpBEOFB71\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\*DEFMACRO;ú\BN\B.ًBBBBBBBBB	BBBBBBBBBBBBBBBBBBBF#BBBBBBBBBLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540764. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MISC-INTERNAL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846239. :AUTHOR "REL3" :LENGTH-IN-BYTES 7201. :LENGTH-IN-BLOCKS 8. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; MISC-INTERNAL*
(defun add-dot (relation attribute)
  (read-from-string (concatenate 'string (string-upcase relation) "." attribute)))

(defun commit-system-relation (&aux insert-name qtrieve-var)
  (cond ((> (length (getp 'system-relation 'commit-tuples)) 0)
 (setf insert-name (string-upcase (concatenate 'string "INSERT-" *system-relation-base-implementation*
 "-" *system-relation-storage-structure*)))

 ;;
 ;;1  Insert the tuples into the SYSTEM-RELATION relation*
 ;;
 (funcall (find-symbol insert-name *pkg-string*) 'system-relation *system-relation-attributes*
  (getp 'system-relation 'commit-tuples) *system-relation-key* 'system-relation)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-RELATION"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-RELATION")
   '("MODIFIEDP" "CARDINALITY")
   (list t (+ qtrieve-var (length (getp 'system-relation 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-ATTRIBUTE relation*
  ;;
  (cond ((> (length (getp 'system-attribute 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-attribute *system-attribute-attributes*
  (getp 'system-attribute 'commit-tuples) *system-attribute-key* 'system-attribute)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-ATTRIBUTE"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-ATTRIBUTE")
   '("MODIFIEDP" "CARDINALITY")
   (list t (+ qtrieve-var (length (getp 'system-attribute 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-OPTFUNC relation*
  ;;
  (cond ((> (length (getp 'system-optfunc 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-optfunc *system-optfunc-attributes*
  (getp 'system-optfunc 'commit-tuples) *system-optfunc-key* 'system-optfunc)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-OPTFUNC"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-OPTFUNC")
   '("MODIFIEDP" "CARDINALITY")
   (list t (+ qtrieve-var (length (getp 'system-optfunc 'commit-tuples)))))))
  ;;
  ;1;  Insert the tuples into the SYSTEM-WHEREOPT relation*
  ;;
  (cond ((> (length (getp 'system-whereopt 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-whereopt *system-whereopt-attributes*
  (getp 'system-whereopt 'commit-tuples) *system-whereopt-key* 'system-whereopt)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-WHEREOPT"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-WHEREOPT")
   '("MODIFIEDP" "CARDINALITY")
   (list t (+ qtrieve-var (length (getp 'system-whereopt 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-IMPLEMENTATION relation*
  ;;
  (cond ((> (length (getp 'system-implementation 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-implementation
  *system-implementation-attributes* (getp 'system-implementation 'commit-tuples)
  *system-implementation-key* 'system-implementation)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-IMPLEMENTATION"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-IMPLEMENTATION")
   '("MODIFIEDP" "CARDINALITY")
   (list t (+ qtrieve-var (length (getp 'system-implementation 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-STORAGE-STRUCTURE relation*
  ;;
  (cond ((> (length (getp 'system-storage-structure 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-storage-structure
  *system-storage-structure-attributes* (getp 'system-storage-structure 'commit-tuples)
  *system-storage-structure-key* 'system-storage-structure)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-STORAGE-STRUCTURE"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-STORAGE-STRUCTURE")
 '("MODIFIEDP" "CARDINALITY")
 (list t (+ qtrieve-var (length (getp 'system-storage-structure 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-DOMAIN relation*
  ;;
  (cond ((> (length (getp 'system-domain 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-domain *system-domain-attributes*
  (getp 'system-domain 'commit-tuples) *system-domain-key* 'system-domain)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-DOMAIN"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-DOMAIN")
 '("MODIFIEDP" "CARDINALITY")
 (list t (+ qtrieve-var (length (getp 'system-domain 'commit-tuples)))))))
  ;;
  ;;1 Clear the property list so that tuples are not reinserted next time*
  ;;
 (mapcar (function (lambda (sys-rel)
     (putp sys-rel nil 'commit-tuples)))
 *system-relations*))

(defun default-tuple-format (domain-list &aux (result nil))
  (do ((dom domain-list (cdr dom)))
      ((null dom) result)
    (setf result (append result (list (caar (qtrieve 'system-domain *system-domain-attributes*
     '(default-print-width)  *system-domain-key*
     `(string-equal domain-name ,(car dom)))))))))

(defun get-default-value (domain)
  (caar (qtrieve 'system-domain *system-domain-attributes* '(default-value) *system-domain-key*
 `(string-equal domain-name ,domain))))

(defun init-where-opt (&aux function-list)
  (setf *where-opt* '())
  (setf *where-opt-macros* '())
  (setf function-list (qtrieve 'system-whereopt *system-whereopt-attributes* '(function-name)
       *system-whereopt-key* t))
  (do ((function function-list (cdr function)))
      ((null function) t)
    (setf *where-opt* (append (car function) *where-opt*))
    (push (concatenate 'string (caar function) "*") *where-opt-macros*)))

(defun remove-dot-attr (rel-attr)
  (setf rel-attr (string rel-attr))
  (read-from-string (subseq rel-attr (+ 1 (search "." rel-attr)) (length rel-attr))))

(defun remove-dot-rel (rel-attr &aux relation-index)
  (setf rel-attr (string rel-attr))
  (setf relation-index (search "." rel-attr))
  (cond ((equal relation-index nil)
 nil)
(t
 (read-from-string (subseq rel-attr 0 relation-index)))))
_B:\B\BfzLB\BBh\BBjBB}CDESTROY-ATTRIBUTEB8BQJQJW@PP@QPYDBpBOBCDESTROY-ATTRIBUTE*	DF$B:BV]FB:B:B:BYFB^B B_B:\B\Bf~?QB\BBh\BBjBB}BB8BQJQJW@PP@QPYDBpB-O.B DESTROY-DB*	DF$B:BV]FB:B:B:BYFB^B/B_B:\B$\Bf
{VB\BBh\B$BjBB}DESTROY-DATABASEB8BQJQJW@PP@QPYDBpB=O>B/CDESTROY-DATABASE*	DF$B:BV]FB:B:B:BYFB^B?B_B:\B$\Bfbt6B\BBh\B$BjBB}B<B8BQJQJW@PP@QPYDBpBLOMB?DESTROY-DOMAIN*	$@F$B:BV]FB:B:B:BYFB^BNB_B:BLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540768. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "MISC-INTERNAL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360316. :AUTHOR "REL3" :LENGTH-IN-BYTES 2066. :LENGTH-IN-BLOCKS 5. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8MISC-INTERNAL\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPADD-DOTFF$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\RELATIONCATTRIBUTEB:B:B:STRINGSTRING-UPCASEl.CONCATENATE*READ-FROM-STRINGPQPQOgBPÂCOMMIT-SYSTEM-RELATION3@3F$B:BV]FB:B:B:BYFB^BhB:B:\INSERT-NAMEQTRIEVE-VARB:B:B:\)MACROS-EXPANDED\PROGpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSSETFC*SYSTEM-RELATIONS*у*SYSTEM-DOMAIN-KEY*C*SYSTEM-DOMAIN-ATTRIBUTES*Ã*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*у*SYSTEM-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*Â*SYSTEM-WHEREOPT-KEY*у*SYSTEM-WHEREOPT-ATTRIBUTES*у*SYSTEM-OPTFUNC-KEY*у*SYSTEM-OPTFUNC-ATTRIBUTES*Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*SYSTEM-RELATIONÁCOMMIT-TUPLESGETPBb,INSERT-l-BeBcҪFIND-SYMBOL\CARDINALITYSTRING-EQUALÁRELATION-NAME,SYSTEM-RELATIONLISTQTRIEVE\lMODIFIEDPCARDINALITYDELETE-OR-MODIFYSYSTEM-ATTRIBUTE,SYSTEM-ATTRIBUTEÁSYSTEM-OPTFUNCSYSTEM-OPTFUNCSYSTEM-WHEREOPT,SYSTEM-WHEREOPTÂSYSTEM-IMPLEMENTATIONSYSTEM-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTURE,SYSTEM-STORAGE-STRUCTUREÁSYSTEM-DOMAINSYSTEM-DOMAINPUTPPPJ.PPPPP@PBPPPPPPBPPPPP P!P"#BAPP P!P"$PAQPPCa"%&PPJ'@QPB&PP&PPP&PBPPPPP P'P"#BAPP P'P"$PAQ&PPCa"%(PPJ'@QPB(PP(PPP(PBPPPPP P)P"#BAPP P)P"$PAQ(PPCa"%*PPJ'@QPB*PP*PP
P*PBPPPPP P+P"#BAPP P+P"$PAQ*PPCa"%,PPJ'@QPB,P	P,PPP,PBPPPPP P-P"#BAPP P-P"$PAQ,PPCa"%.PPJ'@QPB.PP.PPP.PBPPPPP P/P"#BAPP P/P"$PAQ.PPCa"%0PPJ'@QPB0PP0PPP0PBPPPPP P1P"#BAPP P1P"$PAQ0PPCa"%BBPDC	CQDSP2CCDDBOBhDEFAULT-TUPLE-FORMAT
 @HF$B:BV]FB:B:B:BYFB^B\DOMAIN-LISTB:\ÀRESULTDOM\Bt\pB\lXR-BQ-LISTBvB|B~BB\DEFAULT-PRINT-WIDTHBDOMAIN-NAMEBBpB\,*APPENDQA@QPPPPPPAS	
B	@A@OBCGET-DEFAULT-VALUEF@F$B:BV]FB:B:B:BYFB^B\ÀDOMAINB:B:\Bt\BB~BB\ÁDEFAULT-VALUEBBBBPPPPPPQ	
BOBÁINIT-WHERE-OPT(@F$B:BV]FB:B:B:BYFB^BB:B:\ÁFUNCTION-LIST*FUNCTION\Bt\PUSHBvB|BBC*WHERE-OPT-MACROS*у*WHERE-OPT*B\pBTFUNCTION-NAMEBBBbl*BePPPP	@AASP
PAQBP\ASOBREMOVE-DOT-ATTRF@F$B:BV]FB:B:B:BYFB^B\REL-ATTRB:B:\Bt\B|Bbl.pB\,SEARCH*SUBSEQBfQPQkQCOBÁREMOVE-DOT-REL@DF$B:BV]FB:B:B:BYFB^B\BB:\ÁRELATION-INDEX\Bt\B|Bbl.BBBfQPQ@RQJ@QOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\Bᆀ\B.ً\B|[\B{(̢\By*j\Bv=#p 'system-implementation 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-STORAGE-STRUCTURE relation*
  ;;
  (cond ((> (length (getp 'system-storage-structure 'commit-tuples)) 0)
 (funcall (find-symbol insert-name *pkg-string*) 'system-storage-structure
  *system-storage-structure-attributes* (getp 'system-storage-structure 'commit-tuples)
  *system-storage-structure-key* 'system-storage-structure)
 (setf qtrieve-var (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
  *system-relation-key*
  (list 'string-equal 'relation-name "SYSTEM-STORAGE-STRUCTURE"))))
 (delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-STORAGE-STRUCTURE")
 '("MODIFIEDP" "CARDINALITY")
 (list t (+ qtrieve-var (length (getp 'system-storage-structure 'commit-tuples)))))))
  ;;
  ;;1  Insert the tuples into the SYSTEM-DOMAIN relation*
  ;;
  (cond ((> (length (getp 'system-domain 'commit-tuples)) 0)
 (funcLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540771. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MISC-USER" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846253. :AUTHOR "REL3" :LENGTH-IN-BYTES 1062. :LENGTH-IN-BLOCKS 2. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; MISC-USER*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp d as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;*
;1;; This file comtains the following obsolete functions*
;1;;*
;1;; This file contains the following functions which are unknown in CommonLisp*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;*

(defun recover-all ()
  (do ((relations *system-relations* (cdr relations)))
      ((null relations) t)
    (putp (car relations) nil 'entry-point)
    (putp (car relations) nil 'commit-tuples))
  (setf *active-db* nil)
  (if *save-user-id*
      (setf user-id *save-user-id*))
  (setf *restore-operation* nil))

(defun recover-restore ()
  (setf *restore-operation* nil))
M-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*Â*SYSTEM-WHEREOPT-KEY*у*SYSTEM-WHEREOPT-ATTRIBUTES*у*SYSTEM-OPTFUNC-KEY*у*SYSTEM-OPTFUNC-ATTRIBUTES*Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*SYSTEM-RELATIONÁCOMMIT-TUPLESGETPBb,INSERT-l-BeBcҪFIND-SYMBOL\CARDINALITYSTRING-EQUALÁRELATION-NAME,SYSTEM-RELATIONLISTQTRIEVE\lMODIFIEDPCARDINALITYDELETE-OR-MODIFYSYSTEM-ATTRIBUTE,SYSTEM-ATTRIBUTEÁSYSTEM-OPTFUNCSYSTEM-OPTFUNCSYSTEM-WHEREOPT,SYSTEM-WHEREOPTÂSYSTEM-IMPLEMENTATIONSYSTEM-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTURE,SYSTEM-STORAGE-STRUCTUREÁSYSTEM-DOMAINSYSTEM-DOMAINPUTPPPJ.PPPPP@PBPPPPPPBPPPPP P!P"#BAPP P!PLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540774. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "MISC-USER" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760359818. :AUTHOR "REL3" :LENGTH-IN-BYTES 516. :LENGTH-IN-BLOCKS 2. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lMISC-USER\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPRECOVER-ALL
@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBPB:B:\CRELATIONS\)MACROS-EXPANDED\SETFPROG*RESTORE-OPERATION*pBT,USER-IDÁ*SAVE-USER-ID*у*ACTIVE-DB*C*SYSTEM-RELATIONS*ENTRY-POINTPUTPÁCOMMIT-TUPLESP@
@SP	@S
P	@PROoBPRECOVER-RESTOREFF$B:BV]FB:B:B:BYFB^BpB:B:B:\Bb\BdBfROzBp1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\Be=#\Bd[etf *restore-operation* nil))
M-IMPLEMENTATION-KEY*C*SYSTEM-IMPLEMENTATION-ATTRIBUTES*Â*SYSTEM-WHEREOPT-KEY*у*SYSTEM-WHEREOPT-ATTRIBUTES*у*SYSTEM-OPTFUNC-KEY*у*SYSTEM-OPTFUNC-ATTRIBUTES*Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*SYSTEM-RELATIONÁCOMMIT-TUPLESGETPBb,INSERT-l-BeBcҪFIND-SYMBOL\CARDINALITYSTRING-EQUALÁRELATION-NAME,SYSTEM-RELATIONLISTQTRIEVE\lMODIFIEDPCARDINALITYDELETE-OR-MODIFYSYSTEM-ATTRIBUTE,SYSTEM-ATTRIBUTEÁSYSTEM-OPTFUNCSYSTEM-OPTFUNCSYSTEM-WHEREOPT,SYSTEM-WHEREOPTÂSYSTEM-IMPLEMENTATIONSYSTEM-IMPLEMENTATIONSYSTEM-STORAGE-STRUCTURE,SYSTEM-STORAGE-STRUCTUREÁSYSTEM-DOMAINSYSTEM-DOMAINPUTPPPJ.PPPPP@PBPPPPPPBPPPPP P!P"#BAPP P!PLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540777. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MODIFY-AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846273. :AUTHOR "REL3" :LENGTH-IN-BYTES 48083. :LENGTH-IN-BLOCKS 47. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; MODIFY-AVL*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     modify-flavor-avl*
;1;;     modify-flavor-tuples*
;1;;     flavor-avl-key-modify*
;1;;     process-flavor-avl-modify*
;1;;*

(defun modify-list-avl (relation-name attribute-list key-attributes modify-attributes modify-values
where-clause dom-def indices
        &aux (domains nil) key-domain-list key-value insert-tuples mode (modified-tuples nil)
(number-modified 0) package-name rebalancep temp-attribute-list termination-condition
total-insert-tuples (total-number-modified 0) tree tuples)
  ;;
  ;;1  Obtain the key from the where clause from the particular relation.*
  ;;
  indices
  (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
 (setf key-domain-list (eval (read-from-string
       (concatenate 'string *pkg-string* ":*" (string-upcase relation-name)
      "-KEY-DOMAINS*")))))
(t
 (do ((domain-element dom-def (cdr domain-element)))
     ((null domain-element) t)
   (setf domains (append (list (second (car domain-element))) domains)))
 (setf key-domain-list (convert-attributes (car (project-list (list (reverse domains)) attribute-list
      key-attributes))))))
  (cond ((symbolp relation-name)
 (setf package-name (package-name (symbol-package relation-name))))
(t
 (setf package-name *pkg-string*)))
  (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause package-name)
tree (getp relation-name 'entry-point))
  ;;
  ;;  1If there is no usable key specified in the where-clause, set the key value to indicate that the entire* 1tree should be searched.*
  ;;
  (cond ((null key-value)
 (setf key-value (list (list key-attributes) '((t)) '((t))))))
  ;;
  ;;  1Take each key extracted from the WHERE clause and modify the tuples selected by the individual keys.*
  ;;
  (let ((string-attribute-list (convert-attributes attribute-list))
(string-modify-attributes (convert-attributes modify-attributes)))
    (do ((key% (first key-value) (cdr key%))
 (beginning-value% (second key-value) (cdr beginning-value%))
 (termination-clause% (third key-value) (cdr termination-clause%)))
((null key%) number-modified)
      (cond ((equal (caar termination-clause%) t)
     (setf termination-condition t))
    (t
     (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
      ;;
      ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating* 1the eval overhead*
      ;1; from the actual operation. The call to prereq initializes all subsequent calls to SUPER-FAST-EVAL-WHERE.*
      ;;
      (multiple-value-setq (where-clause temp-attribute-list)
   (eval-where-prereq where-clause attribute-list relation-name))
      (progv temp-attribute-list nil
(setf mode "TERMINATE"
      number-modified 1
      insert-tuples '(bogus tuple))
(do ((beginning-value (car beginning-value%) beginning-value))
    ((or (equal number-modified 0) (string-equal mode "FINISHED") (null insert-tuples)) t)
  (setf number-modified 0)
  (multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
       (list-avl-key-modify tree string-attribute-list key-attributes key-domain-list
    beginning-value termination-condition "LOCATE"
    relation-name where-clause rebalancep number-modified nil
    modify-values string-modify-attributes temp-attribute-list
    dom-def))
  (setf total-insert-tuples (append insert-tuples total-insert-tuples))
  (setf total-number-modified (+ total-number-modified number-modified)
rebalancep nil)))))
    (putp relation-name tree 'entry-point)
    (cond (total-insert-tuples
   ;;
   ;;  1Must modify the tuples and then insert them*
   ;;
   (progv temp-attribute-list nil
     (setf tuples nil)
     (do ((tuple total-insert-tuples (cdr tuple)))
 ((null tuple) t)
       (setf modified-tuples (cons (modify-tuple attribute-list modify-attributes (car tuple)
 modify-values dom-def relation-name
 temp-attribute-list)
   modified-tuples))))
     (setf total-insert-tuples (insert-list-avl relation-name attribute-list modified-tuples
key-attributes relation-name))))
    (values total-number-modified total-insert-tuples))

(defun modify-flavor-avl (relation-name attribute-list key-attributes modify-attributesmodify-values
  where-clause dom-def indices
  &aux (domains nil) key-domain-list key-value insert-tuples mode (modified-tuples nil)
  (number-modified 0) package-name rebalancep temp-attribute-list termination-condition
  total-insert-tuples (total-number-modified 0) tree tuples)
  "This function will is the driver for the function which will modify the tuples of the specified list avl
   represented relation. A count of the total number of tuples modified is returned.

   RELATION-NAME     - The name of the relation whose tuples will be modified.
   ATTRIBUTE-LIST    - A list of all of the attributes in the relation in string form.
   KEY-ATTRIBUTES    - A list of the attributes which make form the key of the relation.
   MODIFY-ATTRIBUTES - A list of the attributes to be modified.
   MODIFY-VALUES     - A list of the expressions by which the attributes will be modified.
   WHERE-CLAUSE      - An s-expression which is used as a predicate to select the tuples to be modified.
   DOM-DEF           - A list of elements. Each element is a list containing the name of the attribute, the
                       domain of the element and the default value of the attribute.
   INDICES           - A boolean value which indicates of there are any indices defined on this relation."
  ;;
  ;;  1Obtain the key from the where clause from the particular relation.*
  ;;
  indices
  (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
 (setf key-domain-list (eval (read-from-string
       (concatenate 'string *pkg-string* ":*" (string-upcase relation-name)
      "-KEY-DOMAINS*")))))
(t
 (do ((domain-element dom-def (cdr domain-element)))
     ((null domain-element) t)
   (setf domains (append (list (second (car domain-element))) domains)))
 (setf key-domain-list (car (project-list (list (reverse domains)) attribute-list key-attributes)))))
  (cond ((symbolp relation-name)
 (setf package-name (package-name (symbol-package relation-name))))
(t
 (setf package-name *pkg-string*)))
  (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause package-name)
tree (getp relation-name 'entry-point))
  ;;
  ;;  1If there is no usable key specified in the where-clause, set the key value to indicate that the entir*e 1tree should be searched.*
  ;;
  (cond ((null key-value)
 (setf key-value (list (list key-attributes) '((t)) '((t))))))
  ;;
  ;;  1Take each key extracted from the WHERE clause and modify the tuples selected by the individual keys.*
  ;;
  (do ((key% (first key-value) (cdr key%))
       (beginning-value% (second key-value) (cdr beginning-value%))
       (termination-clause% (third key-value) (cdr termination-clause%)))
      ((null key%) number-modified)
    (cond ((equal (caar termination-clause%) t)
   (setf termination-condition t))
  (t
   (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
    ;;
    ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
    ;; 1the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to SUPER-FAST-EVAL-WHERE.*
    ;;
    (multiple-value-setq (where-clause temp-attribute-list)
      (eval-where-prereq where-clause attribute-list relation-name))
    (progv temp-attribute-list nil
      (setf mode "TERMINATE"
    number-modified 1
    insert-tuples '(bogus tuple))
      (do ((beginning-value (car beginning-value%) beginning-value))
  ((or (equal number-modified 0)(string-equal mode "FINISHED")(null insert-tuples)) t)
(setf number-modified 0)
(multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
  (flavor-avl-key-modify tree (convert-attributes attribute-list) key-attributes key-domain-list
 beginning-value termination-condition "LOCATE"  relation-name where-clause
 rebalancep number-modified nil modify-values modify-attributes
 temp-attribute-list dom-def))
(setf total-insert-tuples (append insert-tuples total-insert-tuples))
(setf total-number-modified (+ total-number-modified number-modified)
      rebalancep nil))))
    (putp relation-name tree 'entry-point)
    (cond (total-insert-tuples
   ;;
   ;;  1Must modify the tuples and then insert them*
   ;;
   (progv temp-attribute-list nil
     (setf tuples nil)
     (do ((tuple total-insert-tuples (cdr tuple)))
 ((null tuple) t)
       (setf modified-tuples (cons (modify-tuple attribute-list modify-attributes (car tuple)
 modify-values dom-def relation-name
 temp-attribute-list)
   modified-tuples)))
     (setf total-insert-tuples (insert-flavor-avl relation-name attribute-list modified-tuples
  key-attributes relation-name)))))
    (values total-number-modified total-insert-tuples))

(defun modify-struct-avl (relation-name attribute-list key-attributes modify-attributesmodify-values
  where-clause dom-def indices
  &aux (domains nil) key-domain-list key-value insert-tuples mode (modified-tuples nil)
  (number-modified 0) package-name rebalancep temp-attribute-list termination-condition
  total-insert-tuples (total-number-modified 0) tree tuples)
  "This function will is the driver for the function which will modify the tuples of the specified list avl
   represented relation. A count of the total number of tuples modified is returned.

   RELATION-NAME     - The name of the relation whose tuples will be modified.
   ATTRIBUTE-LIST    - A list of all of the attributes in the relation in string form.
   KEY-ATTRIBUTES    - A list of the attributes which make form the key of the relation.
   MODIFY-ATTRIBUTES - A list of the attributes to be modified.
   MODIFY-VALUES     - A list of the expressions by which the attributes will be modified.
   WHERE-CLAUSE      - An s-expression which is used as a predicate to select the tuples to be modified.
   DOM-DEF           - A list of elements. Each element is a list containing the name of the attribute, the
                       domain of the element and the default value of the attribute.
   INDICES           - A boolean value which indicates if there are indices defined on the relation."
  ;;
  ;;  1Obtain the key from the where clause from the particular relation.*
  ;;
  indices
  (cond ((member (string-upcase relation-name) *system-relations* :test 'string-equal)
 (setf key-domain-list (eval (read-from-string
       (concatenate 'string *pkg-string* ":*" (string-upcase relation-name)
      "-KEY-DOMAINS*")))))
(t
 (do ((domain-element dom-def (cdr domain-element)))
     ((null domain-element) t)
   (setf domains (append (list (second (car domain-element))) domains)))
 (setf key-domain-list (car (project-list (list (reverse domains)) attribute-list key-attributes)))))
  (cond ((symbolp relation-name)
 (setf package-name (package-name (symbol-package relation-name))))
(t
 (setf package-name *pkg-string*)))
  (setf key-value (extract-key-avl attribute-list key-attributes key-domain-list where-clause package-name)
tree (getp relation-name 'entry-point))
  ;;
  ;;  1If there is no usable key specified in the where-clause, set the key value to indicate that the entire* 1tree should be searched.*
  ;;
  (cond ((null key-value)
 (setf key-value (list (list key-attributes) '((t)) '((t))))))
  ;;
  ;;  1Take each key extracted from the WHERE clause and modify the tuples selected by the individual keys.*
  ;;
  (do ((key% (first key-value) (cdr key%))
       (beginning-value% (second key-value) (cdr beginning-value%))
       (termination-clause% (third key-value) (cdr termination-clause%)))
      ((null key%) number-modified)
    (cond ((equal (caar termination-clause%) t)
   (setf termination-condition t))
  (t
   (setf termination-condition (list 'lep (caar key%) (caar termination-clause%)))))
    ;;
    ;;  1Since EVAL-WHERE has to be called once per node while searching, the process can be sped up by separating*
    ;; 1the eval overhead from the actual operation. The call to prereq initializes all subsequent calls to SUPER-FAST-EVAL-WHERE.*
    ;;
    (multiple-value-setq (where-clause temp-attribute-list)
      (eval-where-prereq where-clause attribute-list relation-name))
    (progv temp-attribute-list nil
      (setf mode "TERMINATE"
    number-modified 1
    insert-tuples '(bogus tuple))
      (do ((beginning-value (car beginning-value%) beginning-value))
  ((or (equal number-modified 0) (string-equal mode "FINISHED") (null insert-tuples)) t)
(setf number-modified 0)
(multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
  (struct-avl-key-modify tree (convert-attributes attribute-list) key-attributes key-domain-list
 beginning-value termination-condition "LOCATE"  relation-name where-clause
 rebalancep number-modified nil modify-values modify-attributes
 temp-attribute-list dom-def))
(setf total-insert-tuples (append insert-tuples total-insert-tuples))
(setf total-number-modified (+ total-number-modified number-modified)
      rebalancep nil))))
    (putp relation-name tree 'entry-point)
    (cond (total-insert-tuples
   ;;
   ;;  1Must modify the tuples and then insert them*
   ;;
   (progv temp-attribute-list nil
     (setf tuples nil)
     (do ((tuple total-insert-tuples (cdr tuple)))
 ((null tuple) t)
       (setf modified-tuples (cons (modify-tuple attribute-list modify-attributes (car tuple)
 modify-values dom-def relation-name
 temp-attribute-list)
   modified-tuples)))
     (setf total-insert-tuples (insert-struct-avl relation-name attribute-list modified-tuples
  key-attributes relation-name)))))
    (values total-number-modified total-insert-tuples))

(defun modify-flavor-tuples (relation attribute-list modify-attributes modify-values where dom-def tuples
     temp-attribute-list
     &aux atom-attribute-list atom-modify-attributes flavor-package data
     conv-attribute-list)
  temp-attribute-list where

  (setf flavor-package (package-name (symbol-package (typep (car tuples)))))
  (setf atom-attribute-list (unconvert-attributes attribute-list flavor-package)
atom-modify-attributes (unconvert-attributes modify-attributes flavor-package))
  (setf conv-attribute-list (project-flavor-prereq attribute-list))
  (setf data (fast-project-flavor tuples conv-attribute-list))
  (mapcar (function (lambda (tuple a-tuple)
      (mapc
(function
  (lambda (attr val &aux tempval)
    (setf tempval  (eval (sublis (form-alist (quote-tuple a-tuple) atom-attribute-list)
  val)))
    (cond ((or (member (string-upcase relation) *system-relations* :test 'string-equal)
       (not *validity-checking*) (dom-check tempval attr dom-def))
   (set-in-instance tuple attr tempval)))))
atom-modify-attributes modify-values)
      tuple))
  tuples data))


(defun modify-struct-tuples (relation attribute-list modify-attributes modify-values where dom-def tuples
     temp-attribute-list
     &aux atom-attribute-list atom-modify-attributes delormod? struct-attribute-list
     (num-modified 0) temp-struct struct-modify-attributes
     (string-relation-name (string relation)))
  temp-attribute-list where

  (setf struct-attribute-list (unconvert-attributes (mapcar #'(lambda (attr)
(concatenate 'string string-relation-name
     attr))
    attribute-list))
struct-modify-attributes (unconvert-attributes (mapcar #'(lambda (attr)
   (concatenate 'string string-relation-name
  attr))
       modify-attributes)))
  (setf atom-attribute-list (unconvert-attributes attribute-list)
atom-modify-attributes (unconvert-attributes modify-attributes))
  (mapc (function (lambda (struct-tuple)
             (setf delormod? nil)
     (setf temp-struct (mapcar (function (lambda (attr)
   (funcall attr struct-tuple)))
       struct-attribute-list))
             (cond ((or (equal where t)
 (super-fast-eval-where (list temp-struct) temp-attribute-list where))
    (mapcar (function (lambda (attr val struct-attr &aux tempval)
  (setf tempval (eval (sublis (form-alist (quote-tuple temp-struct)
  atom-attribute-list)
      val)))
  (if (or (member (string-upcase relation) *system-relations*
  :test 'string-equal)
  (not *validity-checking*) (dom-check tempval attr dom-def))
      (progn
(setf delormod? t)
(eval `(setf (,struct-attr ,struct-tuple) ',tempval))))))
                            atom-modify-attributes modify-values struct-modify-attributes)
    (if delormod?
(setf num-modified (+ 1 num-modified)))))))
  tuples)
  num-modified)

(defun modavl (tree rebalancep temp-tree &aux modtree)
  (cond ((fourth tree)
 (multiple-value-setq (modtree rebalancep temp-tree)
   (modavl (fourth tree) rebalancep temp-tree))
 (rplaca (cdddr tree) modtree)
 (cond (rebalancep
(multiple-value-setq (tree rebalancep)
  (balance2 tree rebalancep)))))
(t
 (rplaca temp-tree (car tree))
 (setf tree (third tree)
       rebalancep t)))
  (values tree rebalancep temp-tree))

1;;; This function is a recursive function which will search the tree for the beginning node and then begin its traversal of the tree modifying
;;; tuples. If modification of the key is involved, the tuples will be deleted and the tree rebalanced as necessary. The deleted tuple will be
;;; modified and added to the insert-tuple list to be added at a later time.
;;;
;;; The values returned are : tree mode rebalancep number-modified beginning-value insert-tuples*
(defun list-avl-key-modify (tree attribute-list key-attributes domains beginning-value termination-clause mode
    relation-name where-clause rebalancep number-modified insert-tuples modify-values
    modify-attributes temp-attribute-list dom-def
    &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil)) (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
 (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-list (list (caar tree)) attribute-list key-attributes)))
 (if (equal (car beginning-value) t)
     (setf comparison-operator 'less-than)
     (setf comparison-operator (node-compare beginning-value current-node-key-value domains)))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (list-avl-key-modify (third tree) attribute-list key-attributes domains beginning-value
       termination-clause mode relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-list-avl-modify tree attribute-list where-clause number-modified rebalancep
  mode beginning-value relation-name termination-clause
  key-attributes domains insert-tuples modify-values
  modify-attributes temp-attribute-list dom-def))
       (setf tree mod-tree))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (list-avl-key-modify (cadddr tree) attribute-list key-attributes domains beginning-value
       termination-clause mode relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*)))))
       ((string-equal comparison-operator 'equal)
;;
;;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;;1 the node is no longer equal.*
;;
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (list-avl-key-modify (caddr tree) attribute-list key-attributes domains beginning-value
       termination-clause mode relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
;;
;;1  The first time control is passed to this location, the beginning node has been found*
;;
;;
;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause for the*
;1; current node and determining if the key of the tuple will be modified. Also must be wary for more than a single *
;;1 tuple per node. If tuples get deleted from within the node but not the node itself, searching can continue. This *
;;1 function must only be rewound out when a rebalancing needs to be done.*
;;
(if (or (string-equal mode "2LOCATE"*) (string-equal mode "2LOCATE-STAGE-2"*))
    (setf mode "2DELETE-SEARCH"*))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-list-avl-modify tree attribute-list where-clause number-modified rebalancep
  mode beginning-value relation-name termination-clause
  key-attributes domains insert-tuples modify-values
  modify-attributes temp-attribute-list dom-def))
       (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
   (list-avl-key-modify tree attribute-list key-attributes domains beginning-value termination-clause
"2LOCATE"* relation-name where-clause rebalancep number-modified insert-tuples
modify-values modify-attributes temp-attribute-list dom-def))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))

;1;; This function is a recursive function which will search the tree for the beginning node and then begin its traversal of the tree modifying*
;1;; tuples. If modification of the key is involved, the tuples will be deleted and the tree rebalanced as necessary. The deleted tuple will be *
;1;; modified and added to the insert-tuple list to be added at a later time. *
;1;;*
;1;; The values returned are : tree mode rebalancep number-modified beginning-value insert-tuples*
(defun flavor-avl-key-modify (tree attribute-list key-attributes domains beginning-value termination-clause mode
      relation-name where-clause rebalancep number-modified insert-tuples modify-values
      modify-attributes temp-attribute-list dom-def
      &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil)) (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
 (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-flavor (list (caar tree)) attribute-list key-attributes)))
 (if (equal (car beginning-value) t)
     (setf comparison-operator 'less-than)
     (setf comparison-operator (node-compare beginning-value current-node-key-value domains)))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (flavor-avl-key-modify (third tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-modified insert-tuples modify-values modify-attributes
 temp-attribute-list dom-def))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-flavor-avl-modify tree attribute-list where-clause number-modified rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains insert-tuples modify-values
    modify-attributes temp-attribute-list dom-def))
       (setf tree mod-tree))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (flavor-avl-key-modify (cadddr tree) attribute-list key-attributes domains beginning-value
       termination-clause mode relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*)))))
       ((string-equal comparison-operator 'equal)
;;
;;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;;1 the node is no longer equal.*
;;
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (flavor-avl-key-modify (caddr tree) attribute-list key-attributes domains beginning-value
       termination-clause mode relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
;;
;;1  The first time control is passed to this location, the beginning node has been found*
;;
;;
;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause for the current*
;1; node and determining if the key of the tuple will be modified. Also must be wary for more than a single tuple per*
;1; node. If tuples get deleted from within the node but not the node itself, searching can continue. This function must*
;1; only be rewound out when a rebalancing needs to be done.*
;;
(if (or (string-equal mode "2LOCATE"*) (string-equal mode "2LOCATE-STAGE-2"*))
    (setf mode "2DELETE-SEARCH"*))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-flavor-avl-modify tree attribute-list where-clause  number-modified
    rebalancep mode beginning-value relation-name
    termination-clause key-attributes domains insert-tuples
    modify-values modify-attributes temp-attribute-list
    dom-def))
       (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
   (flavor-avl-key-modify tree attribute-list key-attributes domains beginning-value termination-clause
"2LOCATE"* relation-name where-clause rebalancep number-modified insert-tuples
modify-values modify-attributes temp-attribute-list dom-def))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))

;1;; This function is a recursive function which will search the tree for the beginning node and then begin its traversal of the tree modifying*
;1;; tuples. If modification of the key is involved, the tuples will be deleted and the tree rebalanced as necessary. The deleted tuple will be *
;1;; modified and added to the insert-tuple list to be added at a later time. *
;1;;*
;1;; The values returned are : tree mode rebalancep number-modified beginning-value insert-tuples*
(defun struct-avl-key-modify (tree attribute-list key-attributes domains beginning-value termination-clause mode
      relation-name where-clause rebalancep number-modified insert-tuples modify-values
      modify-attributes temp-attribute-list dom-def
      &aux comparison-operator current-node-key-value mod-tree)
  ;;
  ;;1  Locate the node where the search will begin*
  ;;
  (cond ((and (not (equal tree nil)) (or (string-equal mode 'locate) (string-equal mode 'locate-stage-2)
 (string-equal mode "2DELETE-SEARCH"*)))
 (setf current-node-key-value (car (project-struct (list (caar tree)) attribute-list key-attributes
   relation-name)))
 (if (equal (car beginning-value) t)
     (setf comparison-operator 'less-than)
     (setf comparison-operator (node-compare beginning-value current-node-key-value domains)))
 (cond
   ;;
   ;;1  The beginning reference key value is less than the current node value, take the left branch*
   ;;
       ((and (equal comparison-operator 'less-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (struct-avl-key-modify (third tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-modified insert-tuples modify-values modify-attributes
 temp-attribute-list dom-def))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-struct-avl-modify tree attribute-list where-clause number-modified rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains insert-tuples modify-values
    modify-attributes temp-attribute-list dom-def))
       (setf tree mod-tree))))
       ((and (equal comparison-operator 'greater-than) (string-equal mode 'locate))
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (struct-avl-key-modify (cadddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-modified insert-tuples modify-values modify-attributes
 temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*)))))
       ((string-equal comparison-operator 'equal)
;;
;;1  Found a node that is equal to the current tuple as far as the key goes. This might not however be the only*
;;1 node in the tree which is equavilent with the current key value. This is because the key used in the retrieval*
;;1 may not be the complete key of the relation. Because of this, must continue to travel along the left path until*
;;1 the node is no longer equal.*
;;
(setf mode  "LOCATE-STAGE-2")
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (struct-avl-key-modify (caddr tree) attribute-list key-attributes domains beginning-value
 termination-clause mode relation-name where-clause rebalancep
 number-modified insert-tuples modify-values modify-attributes
 temp-attribute-list dom-def))
;;
;;1  The first time control is passed to this location, the beginning node has been found*
;;
;;
;;1  Need to determine if the current node is to be deleted. This is done by EVALuating the where clause for the current*
;1; node and determining if the key of the tuple will be modified. Also must be wary for more than a single tuple per*
;1; node. If tuples get deleted from within the node but not the node itself, searching can continue. This function must*
;1; only be rewound out when a rebalancing needs to be done.*
;;
(if (or (string-equal mode "2LOCATE"*) (string-equal mode "2LOCATE-STAGE-2"*))
    (setf mode "2DELETE-SEARCH"*))
(rplaca (cddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance1 tree rebalancep))
       (if rebalancep
   (setf mode "2TERMINATE"*)
   (setf mode "2RESTART"*))))
(cond ((and (not (string-equal mode "2RESTART"*))(not (string-equal mode "TERMINATE2"*))
    (not (string-equal mode "2FINISHED"*)))
       (multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value
      insert-tuples)
 (process-struct-avl-modify tree attribute-list where-clause number-modified rebalancep
    mode beginning-value relation-name termination-clause
    key-attributes domains insert-tuples modify-values
    modify-attributes temp-attribute-list dom-def))
       (setf tree mod-tree))))))
 ((null tree)
  (setf mode "2DELETE-SEARCH"*)))
  (cond ((string-equal mode "2RESTART"*)
 (multiple-value-setq (tree mode rebalancep number-modified beginning-value insert-tuples)
   (struct-avl-key-modify tree attribute-list key-attributes domains beginning-value termination-clause
"2LOCATE"* relation-name where-clause rebalancep number-modified insert-tuples
modify-values modify-attributes temp-attribute-list dom-def))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))

(defun process-list-avl-modify (tree attribute-list where-clause number-modified rebalancep mode
beginning-value relation-name termination-clause key-attributes domains
insert-tuples modify-values modify-attributes temp-attribute-list dom-def
&aux delete-tuples (key-modified nil) mod-tree new-node temp-tree tuples)
  ;;
  ;;1  Now that the tuples which satisfy the where-clause from the current node have been gathered, they need to be deleted, if the key*
  ;1; attributes are modified or modified if th4e modification does not involve the key.*
  ;;
  (do ((key% key-attributes (cdr key%)))
      ((or (null key%) key-modified) key-modified)
    (setf key-modified (member (car key%) modify-attributes :test 'string-equal)))
  (cond (key-modified
 (setf delete-tuples (super-fast-eval-where (first tree) temp-attribute-list where-clause))
 (cond ((> (length delete-tuples) 0)
(setf insert-tuples (append delete-tuples insert-tuples))
(mapc (function (lambda (node-tuple)
  (cond ((not (member node-tuple insert-tuples))
 (setf tuples (append (list node-tuple) tuples))))))
      (first tree))
(setf number-modified (+ number-modified (length delete-tuples)))
;;
;;1  No tuples are left in the node, delete the node*
;;
(cond ((null tuples)
       (setf beginning-value (car (project-list (list (caar tree)) attribute-list
key-attributes)))
       (rplaca tree (list (caar tree)))
       (setf mode "2TERMINATE"*
     temp-tree tree)
       (cond ((equal (car (fourth temp-tree)) nil)
      (setf tree (third temp-tree)
    rebalancep t))
     ((equal (car (third temp-tree)) nil)
      (setf tree (fourth temp-tree)
    rebalancep t))
     (t
      (multiple-value-setq (mod-tree rebalancep temp-tree)
(modavl (third tree) rebalancep temp-tree))
      (rplaca (cddr temp-tree) mod-tree)
      (cond (rebalancep
     (multiple-value-setq (tree rebalancep)
       (balance1 tree rebalancep)))))))
      (t
       (rplaca tree tuples))))))
((null key-modified)
 ;;
 ;;1  The tuples can simply be modified within the node they reside*
 ;;
 (setf new-node nil)
 (do ((tuple% (first tree) (cdr tuple%)))
     ((null tuple%) t)
   (cond ((super-fast-eval-where (list (car tuple%)) temp-attribute-list where-clause)
  (setf number-modified (+ number-modified 1))
  (setf new-node (cons (modify-tuple attribute-list modify-attributes (car tuple%)
     modify-values dom-def relation-name temp-attribute-list)
       new-node)))
 (t
  (setf new-node (cons (car tuple%) new-node)))))
 (rplaca tree new-node)))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (first tree) temp-attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (list-avl-key-modify (cadddr tree) attribute-list key-attributes domains beginning-value
       termination-clause "2LOCATE"* relation-name where-clause rebalancep
       number-modified insert-tuples modify-values modify-attributes
       temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))

(defun process-flavor-avl-modify (tree attribute-list where-clause number-modified rebalancep mode
  beginning-value relation-name termination-clause key-attributes domains
  insert-tuples modify-values modify-attributes temp-attribute-list dom-def
  &aux delete-tuples delete-flavor-tuple (key-modified nil) mod-tree temp-tree
  tuples)
  ;;
  ;;1  Now that the tuples which satisfy the where-clause from the current node have been gathered, they need to be*
  ;;1 deleted, if the key  attributes are modified or modified if th4e modification does not involve the key.*
  ;;
  domains
  (do ((key% key-attributes (cdr key%)))
      ((or (null key%) key-modified) key-modified)
    (setf key-modified (member (car key%) modify-attributes :test 'string-equal)))
  (mapc (function (lambda (flavor-tuple list-tuple)
    (cond ((super-fast-eval-where (list list-tuple) temp-attribute-list where-clause)
   (setf delete-tuples (cons list-tuple delete-tuples)
 delete-flavor-tuple (cons flavor-tuple delete-flavor-tuple))))))
(car tree) (project-flavor (car tree) temp-attribute-list temp-attribute-list))
  (cond (key-modified
 ;;
 ;;1  Any tuples to delete from the current node ??*
 ;;
 (cond ((> (length delete-tuples) 0)
(setf insert-tuples (append delete-tuples insert-tuples))
(mapc (function (lambda (node-tuple)
  (if (not (member node-tuple delete-flavor-tuple))
      (setf tuples (append (list node-tuple) tuples)))))
      (first tree))
(setf number-modified (+ number-modified (length delete-tuples)))
;;
;;1  No tuples are left in the node, delete the node*
;;
(cond ((null tuples)
       (setf beginning-value (car (project-flavor (list (caar tree)) attribute-list
  key-attributes)))
       (rplaca tree (list (caar tree)))
       (setf mode "2TERMINATE"*
     temp-tree tree)
       (cond ((equal (car (fourth temp-tree)) nil)
      (setf tree (third temp-tree)
    rebalancep t))
     ((equal (car (third temp-tree)) nil)
      (setf tree (fourth temp-tree)
    rebalancep t))
     (t
      (multiple-value-setq (mod-tree rebalancep temp-tree)
(modavl (third tree) rebalancep temp-tree))
      (rplaca (cddr temp-tree) mod-tree)
      (if rebalancep
  (multiple-value-setq (tree rebalancep)
       (balance1 tree rebalancep))))))
      (t
       (rplaca tree tuples))))))
((null key-modified)
 ;;
 ;;1  The tuples can simply be modified within the node they reside*
 ;;
 (setf number-modified (+ number-modified (length delete-flavor-tuple)))
 (modify-flavor-tuples relation-name attribute-list modify-attributes modify-values termination-clause
       dom-def delete-flavor-tuple temp-attribute-list)))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (project-flavor (first tree) temp-attribute-list temp-attribute-list)
       temp-attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (flavor-avl-key-modify (cadddr tree) attribute-list key-attributes domains
       beginning-value termination-clause "2LOCATE"* relation-name where-clause
       rebalancep number-modified insert-tuples modify-values
       modify-attributes temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))

(defun process-struct-avl-modify (tree attribute-list where-clause number-modified rebalancep mode
  beginning-value relation-name termination-clause key-attributes domains
  insert-tuples modify-values modify-attributes temp-attribute-list dom-def
  &aux delete-tuples delete-struct-tuple (key-modified nil) mod-tree
  temp-tree tuples
  (string-temp-attributes (convert-attributes temp-attribute-list)))
  ;;
  ;;1  Now that the tuples which satisfy the where-clause from the current node have been gathered, they need to be*
  ;;1 deleted, if the key  attributes are modified or modified if th4e modification does not involve the key.*
  ;;
  domains
  (do ((key% key-attributes (cdr key%)))
      ((or (null key%) key-modified) key-modified)
    (setf key-modified (member (car key%) modify-attributes :test 'string-equal)))
  (mapc (function (lambda (struct-tuple list-tuple)
    (cond ((super-fast-eval-where (list list-tuple) temp-attribute-list where-clause)
   (setf delete-tuples (cons list-tuple delete-tuples)
 delete-struct-tuple (cons struct-tuple delete-struct-tuple))))))
(car tree) (project-struct (car tree) string-temp-attributes string-temp-attributes relation-name))
  (cond (key-modified
 ;;
 ;;1  Any tuples to delete from the current node ??*
 ;;
 (cond ((> (length delete-tuples) 0)
(setf insert-tuples (append delete-tuples insert-tuples))
(mapc (function (lambda (node-tuple)
  (if (not (member node-tuple delete-struct-tuple))
      (setf tuples (append (list node-tuple) tuples)))))
      (first tree))
(setf number-modified (+ number-modified (length delete-tuples)))
;;
;;1  No tuples are left in the node, delete the node*
;;
(cond ((null tuples)
       (setf beginning-value (car (project-struct (list (caar tree)) attribute-list
  key-attributes relation-name)))
       (rplaca tree (list (caar tree)))
       (setf mode "2TERMINATE"*
     temp-tree tree)
       (cond ((equal (car (fourth temp-tree)) nil)
      (setf tree (third temp-tree)
    rebalancep t))
     ((equal (car (third temp-tree)) nil)
      (setf tree (fourth temp-tree)
    rebalancep t))
     (t
      (multiple-value-setq (mod-tree rebalancep temp-tree)
(modavl (third tree) rebalancep temp-tree))
      (rplaca (cddr temp-tree) mod-tree)
      (if rebalancep
  (multiple-value-setq (tree rebalancep)
       (balance1 tree rebalancep))))))
      (t
       (rplaca tree tuples))))))
((null key-modified)
 ;;
 ;;1  The tuples can simply be modified within the node they reside*
 ;;
 (setf number-modified (+ number-modified
  (modify-struct-tuples relation-name attribute-list modify-attributes
     modify-values termination-clause dom-def
     delete-struct-tuple temp-attribute-list)))))
  ;;
  ;;1  If the current node is not to be deleted and it does not invalidate the termination clause, process the right subtree for deletion.*
  ;;
  (cond ((not (string-equal mode "TERMINATE2"*))
 (cond ((super-fast-eval-where (project-struct (first tree) string-temp-attributes
       string-temp-attributes relation-name)
       temp-attribute-list termination-clause)
(multiple-value-setq (mod-tree mode rebalancep number-modified beginning-value insert-tuples)
  (struct-avl-key-modify (cadddr tree) attribute-list key-attributes domains
       beginning-value termination-clause "2LOCATE"* relation-name where-clause
       rebalancep number-modified insert-tuples modify-values
       modify-attributes temp-attribute-list dom-def))
(rplaca (cdddr tree) mod-tree)
(cond (rebalancep
       (multiple-value-setq (tree rebalancep)
 (balance2 tree rebalancep))
       (setf mode "2TERMINATE"*))))
       ((first tree)
(setf mode "2FINISHED*"
      beginning-value nil)))))
  (values tree mode rebalancep number-modified beginning-value insert-tuples))
oBBDefine a new database.

   DB-NALMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540781. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "MODIFY-AVL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360011. :AUTHOR "REL3" :LENGTH-IN-BYTES 6865. :LENGTH-IN-BLOCKS 14. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pp2\COMPILE-DATA\SW-MFG,GODZILLA[FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lMODIFY-AVL\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPMODIFY-LIST-AVL(p(F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEÁATTRIBUTE-LISTÁKEY-ATTRIBUTESCMODIFY-ATTRIBUTESÁMODIFY-VALUESWHERE-CLAUSEDOM-DEFINDICESB:\DOMAINSKEY-DOMAIN-LISTCKEY-VALUEÁINSERT-TUPLESMODEMODIFIED-TUPLESNUMBER-MODIFIEDPACKAGE-NAMECREBALANCEPTEMP-ATTRIBUTE-LISTÂTERMINATION-CONDITIONTOTAL-INSERT-TUPLESÂTOTAL-NUMBER-MODIFIEDTREEÀTUPLESÁDOMAIN-ELEMENTÂSTRING-ATTRIBUTE-LISTSTRING-MODIFY-ATTRIBUTESKEY%BEGINNING-VALUE%TERMINATION-CLAUSE%B:B:BEGINNING-VALUEÀTUPLE\)MACROS-EXPANDED\UNLESSTHIRDFIRSTSECONDPROGSETF*PKG-STRING*C*SYSTEM-RELATIONS*STRING-UPCASEҪSTRING-EQUALpB\MEMBER-TESTSTRINGl:*-KEY-DOMAINS*CONCATENATE*READ-FROM-STRINGҪEVAL*REVERSEҪLIST҃PROJECT-LISTCCONVERT-ATTRIBUTESBpEXTRACT-KEY-AVL҃ENTRY-POINTGETP\\BYBYLEPFCEVAL-WHERE-PREREQjMAKUNBOUNDlTERMINATE\ÀBOGUSBLOCATELIST-AVL-KEY-MODIFYpB\,*APPEND,FINISHEDpB\STRING-EQUAL*҃PUTP҃MODIFY-TUPLEINSERT-LIST-AVLFL߀QPP
	PP
PQPQOOQ
B@]@O@QQQBAQCPGQQAQQGQBQPMBQPPBQQQPBSBWB[TSR`TQB&JPRQBTQBJQQQPPAIIQVUCUUSCVSVUSUVPDJFPCSSW"FMQPQQAQWQJQPQQHQFQۄQQQIQQ P!PACWFHDMCQKQ"KLQFaLHJF'DQ#P$CRSTRQMQP%K*IQVUCUUSCVSVUSUVNKQXQQXSQQQIQJ&E]EXQQEQQQ'KLQKQOBPCMODIFY-FLAVOR-AVL(m(F$B:BV]FB:B:B:BYFB^B\B`BaBbBcBdBeBfBgB:\BiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxB{B|B}B:B:B~B\B\BBBBBBDOCUMENTATIONThis function will is the driver for the function which will modify the tuples of the specified list avl
   represented relation. A count of the total number of tuples modified is returned.

   RELATION-NAME     - The name of the relation whose tuples will be modified.
   ATTRIBUTE-LIST    - A list of all of the attributes in the relation in string form.
   KEY-ATTRIBUTES    - A list of the attributes which make form the key of the relation.
   MODIFY-ATTRIBUTES - A list of the attributes to be modified.
   MODIFY-VALUES     - A list of the expressions by which the attributes will be modified.
   WHERE-CLAUSE      - An s-expression which is used as a predicate to select the tuples to be modified.
   DOM-DEF           - A list of elements. Each element is a list containing the name of the attribute, the
                       domain of the element and the default value of the attribute.
   INDICES           - A boolean value which indicates of there are any indices defined on this relation.BBBB
BBl:*-KEY-DOMAINS*BBBBBBBpBBB\\BYBYBFBBlTERMINATE\BBBLOCATEÂFLAVOR-AVL-KEY-MODIFYB,FINISHEDBBBCINSERT-FLAVOR-AVLFL߀QPP
	PP
PQPQOOQ
B@]@O@QQQBAQCPGQQAQQGQBQPMBQPPBBSBWB[RQPaRQB&JPPQBRQBJQQQPPAIIQTSCSSSCTSTSSSTPDJFPCQSU#FMQQQAQUQJQPQQHQFQۄQQIQQ P!PACUFHDMCQKQ"KLQFaLHJF'DQ#P$CPQRPQMQP%K*IQTSCSSSCTSTSSSTNKQVQQVSQQQIQJ&E]EVQQEQQQ'KLQKQOBCMODIFY-STRUCT-AVL(m(F$B:BV]FB:B:B:BYFB^B\B`BaBbBcBdBeBfBgB:\BiBjBkBlBmBnBoBpBqBrBsBtBuBvBwBxB{B|B}B:B:B~B\B\BBBBBBBThis function will is the driver for the function which will modify the tuples of the specified list avl
   represented relation. A count of the total number of tuples modified is returned.

   RELATION-NAME     - The name of the relation whose tuples will be modified.
   ATTRIBUTE-LIST    - A list of all of the attributes in the relation in string form.
   KEY-ATTRIBUTES    - A list of the attributes which make form the key of the relation.
   MODIFY-ATTRIBUTES - A list of the attributes to be modified.
   MODIFY-VALUES     - A list of the expressions by which the attributes will be modified.
   WHERE-CLAUSE      - An s-expression which is used as a predicate to select the tuples to be modified.
   DOM-DEF           - A list of elements. Each element is a list containing the name of the attribute, the
                       domain of the element and the default value of the attribute.
   INDICES           - A boolean value which indicates if there are indices defined on the relation.BBBB
BBl:*-KEY-DOMAINS*BBBBBBBpBBB\\BYBYBFBBlTERMINATE\BBBLOCATEÂSTRUCT-AVL-KEY-MODIFYB,FINISHEDBBBCINSERT-STRUCT-AVLFL߀QPP
	PP
PQPQOOQ
B@]@O@QQQBAQCPGQQAQQGQBQPMBQPPBBSBWB[RQPaRQB&JPPQBRQBJQQQPPAIIQTSCSSSCTSTSSSTPDJFPCQSU#FMQQQAQUQJQPQQHQFQۄQQIQQ P!PACUFHDMCQKQ"KLQFaLHJF'DQ#P$CPQRPQMQP%K*IQTSCSSSCTSTSSSTNKQVQQVSQQQIQJ&E]EVQQEQQQ'KLQKQOBMODIFY-FLAVOR-TUPLES*hF>$B:BV]FB:B:B:BYFB^B\RELATIONBaBcBdÀWHEREBfBwBrB:\ATOM-ATTRIBUTE-LISTÂATOM-MODIFY-ATTRIBUTESÁFLAVOR-PACKAGEDATACONV-ATTRIBUTE-LISTB:B:B:B:BA-TUPLEB:B:ATTRVALTEMPVAL\B\BpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSB*VALIDITY-CHECKING*BTYPEPBp҃UNCONVERT-ATTRIBUTESÂPROJECT-FLAVOR-PREREQ҃FAST-PROJECT-FLAVOR҃QUOTE-TUPLECFORM-ALISTpB\,SUBLIS*BBB
BCDOM-CHECKpBT,SET-IN-INSTANCESCBQBQ@QBQAQ	DQDQ
CEцQCQHGF4FQGSHSJIAQQLK!KSLSNMOJQ@QNQOQPPOQMQQIQMQOQKLKLIQCFGHGHEOBMODIFY-STRUCT-TUPLESLFb$B:BV]FB:B:B:BYFB^B\BBaBcBdBBfBwBrB:\BBCDELORMOD?ÂSTRUCT-ATTRIBUTE-LISTNUM-MODIFIEDTEMP-STRUCTSTRUCT-MODIFY-ATTRIBUTESSTRING-RELATION-NAMEB:B:B:B:STRUCT-TUPLEB:B:B:B:BBSTRUCT-ATTRB\B\pB\lXR-BQ-LISTBBBBBBBBBBBÂSUPER-FAST-EVAL-WHEREBBBBBB
BBBB8D߀QGHсQJI	IQPGQJSCIJJHQ	CJJтQHK	KQPGQHSCKHHJQ	FQ	@Q	AQJbJSLBIICQNMMQLQNSCMNNIQEQEQ
QQBNNAQQFQIHPO/OQPSHSISSRQTEQ@QRQTQPPTQQQQBPSQLQ
PTQ

COPHIPHIBDJŞDO+BÀMODAVL-@F$B:BV]FB:B:B:BYFB^B,\BvBqCTEMP-TREEB:\MODTREE\B\BBFOURTHFB,FBALANCE2QQBQQPPA@QB@QQQPPAQS[݀QQQO>B,BF$B:BV]FB:B:B:BYFB^B\BvBaBbBiB~CTERMINATION-CLAUSEBmB`BeBqBoBlBdBcBrBfB:\COMPARISON-OPERATORÂCURRENT-NODE-KEY-VALUEMOD-TREE\B\BBÀLOCATEBÁLOCATE-STAGE-2DELETE-SEARCHBBBYCLESS-THANNODE-COMPARE҆B҃GREATER-THANFB=lTERMINATE,RESTARTEQUALLOCATE-STAGE-2LOCATEBALANCE1,FINISHEDPROCESS-LIST-AVL-MODIFYQPQPQPQBQQ	BAS
&PQAQQ@&QP[QQQQQQQQQQQQ
QQQPPAB]@Q&1QP-QBQQQQQQQQQQQQ
QQQPPABQBBQsQQPPAPgPe@QPbP[QQQQQQQQQQQQ
QQQPPABQPQPPYBQQQPPAPPQP'QP#QPQQQQQQQQQQQQQ
QQQPPABÀPQPQQQQQQPQQQQQQ
QQQPPAQQQQQQO_BBF$B:BV]FB:B:B:BYFB^B\BvBaBbBiB~BGBmB`BeBqBoBlBdBcBrBfB:\BIBJBK\B\BBBOBBPDELETE-SEARCHBÁPROJECT-FLAVORBYBRBS҆BBUFB=lTERMINATE,RESTARTBYLOCATE-STAGE-2LOCATEB\,FINISHEDCPROCESS-FLAVOR-AVL-MODIFYQPQPQPQBQQ	BAS
&PQAQQ@&QP[QQQQQQQQQQQQ
QQQPPAB]@Q&1QP-QBQQQQQQQQQQQQ
QQQPPABQBBQsQQPPAPgPe@QPbP[QQQQQQQQQQQQ
QQQPPABQPQPPYBQQQPPAPPQP'QP#QPQQQQQQQQQQQQQ
QQQPPABÀPQPQQQQQQPQQQQQQ
QQQPPAQQQQQQOvBBF$B:BV]FB:B:B:BYFB^B\BvBaBbBiB~BGBmB`BeBqBoBlBdBcBrBfB:\BIBJBK\B\BBBOBBPDELETE-SEARCHBÁPROJECT-STRUCTBYBRBS҆BBUFB=lTERMINATE,RESTARTBYLOCATE-STAGE-2LOCATEB\,FINISHEDCPROCESS-STRUCT-AVL-MODIFYQPQPQPQBQQQ	BAS
&PQAQQ@&QP[QQQQQQQQQQQQ
QQQPPAB]@Q&1QP-QBQQQQQQQQQQQQ
QQQPPABQBBQsQQPPAPgPe@QPbP[QQQQQQQQQQQQ
QQQPPABQPQPPYBQQQPPAPPQP'QP#QPQQQQQQQQQQQQQ
QQQPPABÀPQPQQQQQQPQQQQQQ
QQQPPAQQQQQQO
BB^`׆(Fw$B:BV]FB:B:B:BYFB^B^\BvBaBeBoBqBmB~B`BGBbBiBlBdBcBrBfB:\
ÁDELETE-TUPLESKEY-MODIFIEDBKNEW-NODEB5BwB{B:CNODE-TUPLEÀTUPLE%\B\BB:BBBB
B
BB*BpB\lMEMBER-EQLBBlTERMINATEFB,FB\BBLOCATEBB=,FINISHEDQFFS
QPAFAAVSQQ@Jk@QQSG
GSHËQHQE]EG@QCaE4QB	QQ
BQQB	PQDDUD[<DQDQB[QDQPPADBDYBQ(QQPPA QEQCۀSIIS	QQɁQ
QISQQQQJISC]CIQCQQP4SQQ*QBQQQQQPQQQQQQ
QQQPPABQBBQQQPPAPPۀQQQQQQOB^Buh熀0F$B:BV]FB:B:B:BYFB^Bu\BvBaBeBoBqBmB~B`BGBbBiBlBdBcBrBfB:\BDELETE-FLAVOR-TUPLEBBKB5BwB{B:B:FLAVOR-TUPLECLIST-TUPLEB\B\BB:BBBBB
BBmBB*BBlTERMINATEFB,FB\BBLOCATEBB=,FINISHEDQFFS
QPBFBSSQQHGGSHSJIJQQQJQ@]@IQA]AGHGHBS@QJ]@QQ	SG
GSKAQ
KQE]EG@QCaE4QBQQBQQBPQDDUD[.DQDQB[QDQPPADCDYCQQQPPAQEQAQCaQQ
QQQQAQQJQP7SQQQQ*QBQQQQQPQQQQQQ
QQQPPACQBCQQQPPAPPۀQQQQQQOBuBj솀4F$B:BV]FB:B:B:BYFB^B\BvBaBeBoBqBmB~B`BGBbBiBlBdBcBrBfB:\BDELETE-STRUCT-TUPLEBBKB5BwÂSTRING-TEMP-ATTRIBUTESB{B:B:B#BB\B\BB:BBBBBB
BBBB*BBlTERMINATEFB,FB\BBLOCATEBB=,FINISHEDQFQGGS
QPBGBSSFQFQQIHHSISKJKQQQ	KQ@]@JQA]AHIHIBT@QJ]@QQ
SH
HSLAQLQE]EH@QCaE5QBQQQBQQBPQDDUD[-DQDQB[QDQPPADCDYCQQQPPAQEQQQQ
QQQQAQQJaQP8SFQFQQQQ	*QBQQQQQPQQQQQQ
QQQPPACQBCQQQPPAPPۀQQQQQQOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B:x\B(.ً\B(̢\B*j\B[\B=#\B{\Bz(\B:}n\B6tribute-list dom-def))
(setf total-insert-tuples (append insert-tuples total-insert-tuples))
(setf total-number-modified (+ total-number-modified number-modified)
      rebalancep nil))))
    (putp relation-name tree 'entry-point)
    (cond (total-insert-tuples
   ;;
   ;;  1Must modify the tuples and then insert them*
   ;;
   (progv temp-attribute-list nil
     (setf tuples nil)
     (do ((tuple total-insert-tuples (cdr tuple)))
 ((null tuple) t)
       (setf modified-tuples (cons (modify-tuple attribute-list modify-attributes (car tuple)
 modify-values dom-def relation-name
LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540784. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MODIFY-REL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846288. :AUTHOR "REL3" :LENGTH-IN-BYTES 15494. :LENGTH-IN-BLOCKS 16. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; MODIFY-REL*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp d as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     errset*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;*

(defun create-attr-descriptor (attribute-list system-attribute-list
       &aux attr-des-pair attr-def attr-doc dom found-attr attr-tuple)
  (setf attr-des-pair nil)
  (mapcar (function (lambda (attr-name)
      (setf found-attr nil)
      (do ((tuples system-attribute-list (cdr tuples)))
  ((or found-attr (null tuples)))
(setf attr-tuple (car tuples))
(if (car (errset (string-equal (second attr-tuple) attr-name) nil))
    (progn
      (setf found-attr t)
      (setf attr-def (fourth attr-tuple)
    attr-doc (fifth attr-tuple)
    dom (third attr-tuple))
      (setf attr-des-pair (append attr-des-pair (list (second attr-tuple)
      (list 'dom dom 'def attr-def
    'doc attr-doc)))))))
      (if (null found-attr)
  (setf attr-des-pair (append attr-des-pair (if (listp attr-name)
attr-name
(list attr-name)))))))
  attribute-list)
  attr-des-pair)

(defun get-system-attribute-list (relation-name)
  (funcall (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation*
     "-" *system-relation-storage-structure*) *pkg-string*)
   'system-attribute *system-attribute-attributes* *system-attribute-attributes*
   *system-attribute-key* (list 'string-equal 'relation-name (string-upcase relation-name))
   nil 'system-attribute))

(defun redefine-rel (relation-name attr-des-pair imp ss key tuple-format-list doc dir tuple-list
     &aux temp-rel (status? *provide-status-messages*))
  (block redefine-rel
  (setf temp-rel (read-from-string (string (gensym))))
  (setf *provide-status-messages* nil)
  (if (not (define-relation temp-rel attr-des-pair
     'imp imp 'sto ss 'key key 'format tuple-format-list 'doc doc 'dir dir))
      (progn
(setf *provide-status-messages* status?)
(return-from redefine-rel nil)))
  (delete-or-modify 'system-index t (list 'string-equal 'relation-name (string relation-name))
2     *'("RELATION-NAME") (list (eval `(string-upcase (quote ,temp-rel)))))
  ;;
  ;;1 To take care of cases like in modify-rel when this routine is called without the relation "relation-name" having been defined. But some*
  ;1; times it might be the case that it is defined.*
  ;1;*
  (if (relationp relation-name)
      (destroy-relation relation-name))
  ;;1 rename temp-rel to relation-name*
  (delete-index-tuples temp-rel imp)
  (if (not (rename1-*relation temp-rel (read-from-string (string relation-name))))
      (progn
(setf *provide-status-messages* status?)
(return-from redefine-rel nil)))
  (cond (tuple-list
 (insert (read-from-string (string relation-name)) 'tuples tuple-list)))
  (setf *provide-status-messages* status?)
  (return-from redefine-rel relation-name)))

(defun modify-relation (relation &rest keyword-list
&key &optional relation-name add-attributes delete-attributes rename-attributes
implementation-type storage-structure format key documentation directory
&allow-other-keys
&aux rel attr imp sto format1 key1 doc dir mod-attr mod-vals rename-attrs new-attrs
current-attributes tuples delete-attrs old-vals)
 "Modify various features of a relation.

  RELATION             - Name of the relation to be modified.
  RELATION-NAME        - New name for this relation.
  ADD-ATTRIBUTES       - List of new attributes and their description.
  DELETE-ATTRIBUTES    - List of attributes to be destroyed.
  RENAME-ATTRIBUTES    - List of list of OLD-NEW attribute names.
  IMPLEMENTATION-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved."
 relation-name add-attributes delete-attributes rename-attributes implementation-type storage-structure format
 key documentation directory
 (block modify-relation
       (cond (*parameter-checking*
      (if (not (active-database))
  (return-from modify-relation nil))))
       (if (null (setf relation (validate-sym relation)))
   (return-from modify-relation nil))
      (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
     ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
       (setf keyword-list (get-keyword-value-prereq '(rel add-attr delete-attr rename-attr imp sto format key
  doc dir)
    keyword-list))
       (setf current-attributes (caadr (get-relation relation '("ATTRIBUTES") t)))
       (cond ((null current-attributes)
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - Relation ~s does not exist in the database ~s"
  relation *active-db*))
      (return-from modify-relation nil)))
       (cond-every ((setf format1 (car (get-keyword-value '(format) keyword-list)))
    (setf mod-attr (append mod-attr '("TUPLE-FORMAT")))
    (setf mod-vals (append mod-vals (list `(quote ,format1)))))
   ((setf dir (car (get-keyword-value '(dir) keyword-list)))
    (setf mod-attr (append mod-attr '("SAVE-DIRECTORY")))
    (setf mod-vals (append mod-vals (list `(quote ,dir)))))
   ((setf doc (car (get-keyword-value '(doc) keyword-list)))
    (setf mod-attr (append mod-attr '("DOCUMENTATION")))
    (setf mod-vals (append mod-vals (list `(quote ,doc)))))
   ((setf key1 (car (get-keyword-value '(key) keyword-list)))
    (setf mod-attr (append mod-attr '("KEY")))
    (setf mod-vals (append mod-vals (list `(quote ,key1))))))
       (setf imp (car (get-keyword-value '(imp) keyword-list))
     sto (car (get-keyword-value '(sto) keyword-list)))
       (if (or imp sto)
   (progn
     (setf tuples (retrieve relation 'tuples t))
     (setf current-attributes
   (cadr (get-relation relation '("ATTRIBUTES" "SAVE-DIRECTORY" "DOC" "TUPLE-FORMAT"
  "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY") t)))
     (setf attr (copy-list (car current-attributes)))
     (if (car (get-keyword-value '(delete-attr) keyword-list))
 (progn
   (mapc #'(lambda (att)
     (if (member att attr :test 'string-equal)
 (setf attr (delete att attr))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - ~S is not an attribute in the relation ~S. It can not be deleted."
     att relation))))
 (convert-attributes (car (get-keyword-value '(delete-attr) keyword-list))))
   (setf tuples (project-list tuples (car current-attributes) attr))))
     (setf attr (create-attr-descriptor attr (get-system-attribute-list relation)))
     (if (car (get-keyword-value '(rename-attr) keyword-list))
 (mapc #'(lambda (att)
   (if (and (listp att) (member (car att) attr :test 'string-equal))
       (setf attr (subst (cadr att) (car att) attr))
       (if *provide-error-messages*
   (format *standard-output*
   "~%ERROR - ~S is not an attribute in the relation ~S. It can not be renamed."
   (if (listp att)
       (car att)
       att)
   relation))))
       (convert-attributes (car (get-keyword-value '(rename-attr) keyword-list)))))
     (if (car (get-keyword-value '(add-attr) keyword-list))
 (setf attr (append attr (car (get-keyword-value '(add-attr) keyword-list)))))
     (setf old-vals (list *validity-checking* *provide-status-messages*))
     (setf *validity-checking* nil *provide-status-messages* nil)
     (if (not (redefine-rel (setf rel (or (car (get-keyword-value '(rel) keyword-list)) relation))
    attr (or imp (fifth current-attributes)) (or sto (sixth current-attributes))
    (or key1 (seventh current-attributes))
    (or format1 (fourth current-attributes)) (or doc (third current-attributes))
    (or dir (second current-attributes)) tuples))
 (return-from modify-relation nil))
     (setf *validity-checking* (car old-vals)
   *provide-status-messages* (cadr old-vals))
     (return-from modify-relation rel)))
       (if mod-attr
   (funcall (find-symbol (concatenate 'string "MODIFY-" *system-relation-base-implementation*
"-" *system-relation-storage-structure*) *pkg-string*)
    'system-relation *system-relation-attributes* *system-relation-key* mod-attr mod-vals
    `(string-equal relation-name ,(string relation))
    (mapcar #'(lambda (dom-def)
(list (first dom-def) (read-from-string (concatenate 'string *pkg-name*
       (second dom-def)))))
    (retrieve 'system-attribute 'project '(attribute-name domain-function) 'tuples t
      'where `(string-equal relation-name ,(string-upcase relation))))
    nil))
       (setf current-attributes (cadr (get-relation relation '("ATTRIBUTES" "IMPLEMENTATION-TYPE"
       "STORAGE-STRUCTURE" "KEY") t)))
       (setf rename-attrs (car (get-keyword-value '(rename-attr) keyword-list)))
       (setf new-attrs (car (get-keyword-value '(add-attr) keyword-list)))
       (setf delete-attrs (car (get-keyword-value '(delete-attr) keyword-list)))
       (if rename-attrs
   (rename-attribute relation rename-attrs))
       (if new-attrs
   (define-attribute relation new-attrs))
       (if delete-attrs
   (destroy-attribute relation 'attribute delete-attrs))
       (if key1
   (progn
     (setf tuples (retrieve relation 'tuples t))
     (delete-tuples relation 'where t)
     (insert-tuples relation 'tuples tuples)))
       (if (setf rel (car (get-keyword-value '(rel) keyword-list)))
   (rename-relation relation rel))
       (return-from modify-relation t)))

(defun modify-database (database &rest keyword-list
&key &optional database-name directory documentation
&allow-other-keys
&aux temp)
 "Modify various features of the active database.

  DATABASE      - Name of the database to be modified.
  DATABASE-NAME - New name for this database.
  DIRECTORY     - New directory in which this database is to be saved.
  DOCUMENTATION - New description for this database."
 database-name directory documentation
 (block modify-database
       (cond (*parameter-checking*
      (if (not (active-database))
  (return-from modify-database nil))))
       (if (null (setf database (validate-sym database t)))
   (return-from modify-database nil))
       (cond ((not (string-equal database *active-db*))
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - The database to modify has to be the active database ~S"
  *active-db*))
      (return-from modify-database nil)))
       (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
      ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
       (setf keyword-list (get-keyword-value-prereq '(database dir doc) keyword-list))
       (cond-every ((setf temp (car (get-keyword-value '(dir) keyword-list)))
    (set (read-from-string (concatenate 'string *pkg-name* "*SAVE-DIRECTORY*")) temp))
   ((setf temp (car (get-keyword-value '(doc) keyword-list)))
    (set (read-from-string (concatenate 'string *pkg-name* "*DATABASE-DOCUMENTATION*")) temp))
   ((setf temp (car (get-keyword-value '(database) keyword-list)))
    (rename-database database temp)))
       (return-from modify-database (or temp database))))

(defun modify-attribute (relation attribute &rest keyword-list
 &key &optional attribute-name default-value documentation format
 &allow-other-keys &aux temp attributes tuple-format num)
 "Modify various features of an attribute in a given relation.

  RELATION       - Name of the relation in which the attribute to be modified exists.
  ATTRIBUTE      - Name of the attribute to be modified.
  ATTRIBUTE-NAME - New name for this attribute.
  DEFAULT-VALUE  - New default value for this attribute.
  DOCUMENTATION  - New description.
  FORMAT         - New print width to be used for this attribute."
 attribute-name default-value documentation format
 (block modify-attribute
       (cond (*parameter-checking*
      (if (not (active-database))
  (return-from modify-attribute nil))))
       (if (not (setf relation (validate-sym relation)))
   (return-from modify-attribute nil))
       (setf tuple-format (cadr (get-relation relation '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
       (cond ((null (car tuple-format))
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - Relation ~s does not exist in the database ~s"
  relation *active-db*))
      (return-from modify-attribute nil)))
       (setf attribute (car (convert-attributes attribute)))
       (if (not (member attribute (car tuple-format) :test 'string-equal))
   (progn
     (if *provide-error-messages*
 (format *standard-output* "~%ERROR - ~S is not an attribute in the relation ~S"
 attribute relation))
     (return-from modify-attribute nil)))
       (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
      ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
       (setf keyword-list (get-keyword-value-prereq '(attr def doc format) keyword-list))
       (cond-every ((setf temp (car (get-keyword-value '(def) keyword-list)))
    (if (dom-check temp attribute
   (mapcar #'(lambda (dom-def)
       (list (first dom-def) (read-from-string
       (concatenate 'string *pkg-name*
      (second dom-def)))))
   (retrieve 'system-attribute
     'project '(attribute-name domain-function) 'tuples t
     'where
     `(string-equal relation-name ,(string-upcase relation)))))
(delete-or-modify 'system-attribute t
  `(and (string-equal relation-name ,(string-upcase relation))
(string-equal attribute-name ,(string-upcase attribute)))
  '("DEFAULT-VALUE") (list temp))))
   ((setf temp (car (get-keyword-value '(format) keyword-list)))
    (if (not (numberp temp))
(if *provide-warning-messages*
    (format *standard-output* "~%WARNING - ~S is not a valid format value." temp))
(progn
  (setf attributes (car tuple-format)
tuple-format (cadr tuple-format))
  (setf num (position attribute attributes :test 'equal))
  (setf tuple-format (append (firstn num tuple-format) (list temp)
     (nthcdr (+ num 1) tuple-format)))
  (delete-or-modify 'system-relation t
    `(string-equal relation-name ,(string-upcase relation))
    '("TUPLE-FORMAT") (list `(quote ,tuple-format))))))
   ((setf temp (car (get-keyword-value '(doc) keyword-list)))
    (delete-or-modify 'system-attribute t
      `(and (string-equal relation-name ,(string-upcase relation))
    (string-equal attribute-name ,(string-upcase attribute)))
      '("DOC") (list temp)))
   ((setf temp (car (get-keyword-value '(attr) keyword-list)))
    (rename-attribute relation attribute temp)))
       (return-from modify-attribute (or temp attribute))))
stem-relations* :test 'string-equal)
       (not *validity-checking*) (dom-check tempval attr dom-def))
   (set-in-instance tuple attr tempval)))))
atom-modify-attributes modify-values)
      tuple))
  tuples data))


(defun modify-struct-tuples (relation attribute-list modify-attributes modify-values where dom-def tuples
     temp-attribute-list
     &aux atom-attribute-list atom-modify-attributes delormod? struct-attribute-list
     (num-modified 0) temp-struct struct-modify-attributes
     (string-relation-name (string relation)))
  temp-attribute-list where

  (setf struct-attribute-list (unconvert-attributes (mapcar #'(lambda (attr)
(concatenate 'string string-relation-name
     attr))
    attribute-list))
struct-modify-attributes (unconvert-attributes (mapcar #'(lambda (attr)
   (concatenate 'string string-relatLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540787. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "MODIFY-REL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360646. :AUTHOR "REL3" :LENGTH-IN-BYTES 4758. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8lMODIFY-REL\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPÂCREATE-ATTR-DESCRIPTOR,f@F:$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁATTRIBUTE-LISTÂSYSTEM-ATTRIBUTE-LISTB:\ÁATTR-DES-PAIRATTR-DEFATTR-DOCDOMCFOUND-ATTRCATTR-TUPLEB:B:B:CATTR-NAMEÀTUPLESB:B:\)MACROS-EXPANDED\THIRDFIFTHFOURTHSECONDpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETPROGpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSSETFplEH*CONDITION-HANDLERS*p,G0360FBERRORpB\ERRSET-HANDLERpB\STRING-EQUAL*ҪLISTBfpBTDEFDOCpB\,*APPENDFрQHGOGQHSIDہQJ3JSEPPTPPPJCKPJCLEWIQ	J!BJ!B\DEQBAEUBBE[C@QEW
PCQPAQPBQ		@JDJD
@QI5IQIQ	@CGHH@OBPCGET-SYSTEM-ATTRIBUTE-LIST(@DF$B:BV]FB:B:B:BYFB^B\ÁRELATION-NAMEB:B:B:Â*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*STRINGlRETRIEVE-l-CONCATENATEҪFIND-SYMBOLSYSTEM-ATTRIBUTESTRING-EQUALBSTRING-UPCASEBP	PP
PPP@PPPPPPQPJ@OBREDEFINE-REL"aBHF?$B:BV]FB:B:B:BYFB^B\	BBcIMPCSSKEYCTUPLE-FORMAT-LISTBDIRCTUPLE-LISTB:\TEMP-RELSTATUS?\Bl\pB\lXR-BQ-LISTBC*PROVIDE-STATUS-MESSAGES*GENSYMB*READ-FROM-STRINGBSTOBFORMATBBDEFINE-RELATION҃SYSTEM-INDEXBBB\RELATION-NAMEBB8EVALDELETE-OR-MODIFYCRELATIONPDESTROY-RELATION҃DELETE-INDEX-TUPLESRENAME-RELATIONBjÀINSERTPA@@QQPQPQ	PQ
PQPQPQJAQRPPPQPPP@QQQ@QQ@QQQPQAQOBMODIFY-RELATIONUU@F+$B:BV]FB:B:B:BYFB^B\RELATION&RESTKEYWORD-LIST&KEYj&OPTIONALBÁADD-ATTRIBUTESCDELETE-ATTRIBUTESCRENAME-ATTRIBUTESIMPLEMENTATION-TYPECSTORAGE-STRUCTUREBBDOCUMENTATIONjDIRECTORYj&ALLOW-OTHER-KEYSB:\#BBBBBBBBBBB郀RELATTRBBFORMAT1KEY1BBMOD-ATTRMOD-VALSRENAME-ATTRSCNEW-ATTRSCCURRENT-ATTRIBUTESBjDELETE-ATTRSOLD-VALSBB:B:ATTB:B:DOM-DEFB:\Bl\FIRSTBBqBnBp*SEVENTHSIXTHBoBBpBTlCOND-EVERYB|BDOCUMENTATION쿇Modify various features of a relation.

  RELATION             - Name of the relation to be modified.
  RELATION-NAME        - New name for this relation.
  ADD-ATTRIBUTES       - List of new attributes and their description.
  DELETE-ATTRIBUTES    - List of attributes to be destroyed.
  RENAME-ATTRIBUTES    - List of list of OLD-NEW attribute names.
  IMPLEMENTATION-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved. C*PKG-NAME*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*BBBBу*VALIDITY-CHECKING*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*у*PARAMETER-CHECKING*\
RELATION-NAMEADD-ATTRIBUTESiDELETE-ATTRIBUTESiRENAME-ATTRIBUTESIMPLEMENTATION-TYPEiSTORAGE-STRUCTUREFORMATKEYBiDIRECTORYpB\STORE-KEYARGSACTIVE-DATABASE҃VALIDATE-SYM\
BADD-ATTRDELETE-ATTRRENAME-ATTRBBBBBBGET-KEYWORD-VALUE-PREREQ\lATTRIBUTESGET-RELATIONTERPRIlERROR - Relation WRITE-STRINGPRIN1, does not exist in the database \BCGET-KEYWORD-VALUE\TUPLE-FORMATBB8B\B\SAVE-DIRECTORY\B\DOCUMENTATION\B\KEY\B\BBjRETRIEVE\lATTRIBUTESSAVE-DIRECTORYDOCTUPLE-FORMATIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYjCOPY-LIST\BCCONVERT-ATTRIBUTESBpB\MEMBER-TESTpB\,DELETE*,ERROR -  is not an attribute in the relation ,. It can not be deleted.PROJECT-LISTBBP\BpB\lSUBST-EQL,. It can not be renamed.\B\BBB,MODIFY-l-BBSYSTEM-RELATIONBBBPROJECT\ÁATTRIBUTE-NAMEDOMAIN-FUNCTIONÀWHEREBB\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYRENAME-ATTRIBUTEDEFINE-ATTRIBUTECATTRIBUTECDESTROY-ATTRIBUTEÁDELETE-TUPLESÁINSERT-TUPLESBҒ@@QPARQR@Q[S[[S5[Q@P@Q@QP	BW	PQPPRP@QBOPS POQ!!T]\"P@QBRSQ#PSTQ PRQ!!T]\$P@QBQSQ%PSTQ PQQ!!T]\&P@QBPSQ'PSTQ PPQ!!T]\(P@QBM)P@QBNMNQ*P+XQ,PBWWS-L.P@Q&.P@QB/\\S^LQ0P1^QLQ2L3P^Q4PQ5P\XQWSLQ6XLQQ78L9P@Q)9P@QB/\"\S^^5^SLQ0P1^W^SLQ:L3P^5^S^Q4PQ;P\<P@QLQ<P@QBLP
P!Z
=P@QBQKLQMQWUBNQWYBPQWQBBOQWQBQQW[RQWWXQ	J>RZSZW
KS9?P@P	PAPPBPCbDPPPSQTQ0PEPQF!]]GPHPIP*PJP0PEPQK!J+`__Q`SaaS?PPaWBL!C_``]QJbQMPBW9P@QBU<P@QBV.P@QBYUQUQNVQVQOYQPPYQQPQ*P+XQJPRQ*PXQS=P@QBKQKQTSOaBMODIFY-DATABASE-v``FI$B:BV]FB:B:B:BYFB^Bb\	DATABASEBBBBÁDATABASE-NAMEBBBB:\BBlBB胀TEMPBB:B:\Bl\BB|BBlModify various features of the active database.

  DATABASE      - Name of the database to be modified.
  DATABASE-NAME - New name for this database.
  DIRECTORY     - New directory in which this database is to be saved.
  DOCUMENTATION - New description for this database.BBBB	\DATABASE-NAMEBBBBBBB ERROR - The database to modify has to be the active database B"B#\BkBBB\BB&B,*SAVE-DIRECTORY*BB\B,*DATABASE-DOCUMENTATION*\BkRENAME-DATABASE@@QPA	RQ
RQPPPR@QESEES5EQ@P@Q@P@QBD	PPPDQBGFP@QBD	PPPDQBGFP@QBDQDQGFDQO|BbMODIFY-ATTRIBUTE<t$<F$B:BV]FB:B:B:BYFB^B}\BB]BBBBBSÁDEFAULT-VALUEBBBB:\BBSBBBBnCATTRIBUTESTUPLE-FORMATNUMBB:B:B:B:B:B\Bl\BqBBBBBB|BBModify various features of an attribute in a given relation.

  RELATION       - Name of the relation in which the attribute to be modified exists.
  ATTRIBUTE      - Name of the attribute to be modified.
  ATTRIBUTE-NAME - New name for this attribute.
  DEFAULT-VALUE  - New default value for this attribute.
  DOCUMENTATION  - New description.
  FORMAT         - New print width to be used for this attribute.AC*PROVIDE-WARNING-MESSAGES*BBBB	\ATTRIBUTE-NAMEDEFAULT-VALUEBBBBB\lATTRIBUTESTUPLE-FORMATBB lERROR - Relation B"B#, does not exist in the database B?BBA,ERROR -  is not an attribute in the relation \BBBBB\BB&BBQ\BSBTBjBUBBBB4BBBCDOM-CHECKҪANDBS\DEFAULT-VALUEB\BlWARNING -  is not a valid format value.EQUALpB\lPOSITION*pBTFIRSTNAPPENDBP\TUPLE-FORMATB8\B\DOC\BB[@@Q	PA
RQRQPBGG	PQPPRQBGSP	PQPQR@QISIIS5IQ@P@Q@P@QBE<EQQLPPP P!PP"PQ#$J%NMMQNSOOS&PPOW'($CMNNLQ)P*PP"PQ#$P+PQ#$$,PEQ$-KJ.P@QBE.E1/PEQ0PK GSFGWGQFQ1P2HGQ3EQ$HkGQ
C4G5PP"PQ#$6P7PGQ$$-KJ8P@QBEP*PP"PQ#$P+PQ#$$9PEQ$-KJ:P@QBEQQEQ;KJEQOB}1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B9\B{Ĳ\B2=\Bz(\BÆ.ً\B[\B(̢\B*j\B|=#\B{-i\By~z\Bw<p\Bu`sN\Bs|\Bq{\Bpx\BoZi\Bn:}n     (setf new-attrs (car (get-keyword-value '(add-attr) keyword-list)))
       (setf delete-attrs (car (get-keyword-value '(delete-attr) keyword-list)))
       (if rename-attrs
   (rename-attribute relation rename-attrs))
       (if new-attrs
   (define-attribute relation new-attrs))
       (if delete-attrs
   (destroy-attribute relation 'attribute delete-attrs))
       (if key1
   (progn
     (setf tuples (retrieve relation 'tuples t))
     (delete-tuples relation 'where t)
     (insert-tuples relation 'tuples tuples)))
       (if (setf rel (car (get-keyword-value '(rel) keyword-list)))
   (rename-relation relation rel))
       (return-from modify-relation t)))

(defun modify-database (database &rest keywLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540790. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "MOVE-DATABASE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846300. :AUTHOR "REL3" :LENGTH-IN-BYTES 1746. :LENGTH-IN-BLOCKS 2. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(CODE-FONT COMMENT-FONT STRING-FONT); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; Moves the current database into a temporary location in virtual memory which can be retrieved at a later time. This prevents*
;1;; the destruction and reloading of a database when another is needed for a short time. This is great for testing RTMS. It is done in*
;1;; quick and dirty way. At some time in the future it will have to be redone.*
(defun move-database (database-name &optional (direction 'output))
  (cond ((equal direction 'output)
 (putp database-name *save-directory* 'save-directory)
 (mapc (function (lambda (%relation-name)
   (putp (intern-local (string-upcase
 (string-append database-name "-" (car %relation-name)))
       *pkg-string*)
 (getp (intern-local (string-upcase (car %relation-name)) *pkg-string*)
       'entry-point)
 'entry-point)))
       (retrieve 'system-relation 'project '(relation-name) 'tuples t)))
((equal direction 'input)
 (putp 'system-relation
       (getp (intern-local (string-upcase (string-append database-name "-" "SYSTEM-RELATION"))
   *pkg-string*)
     'entry-point)
       'entry-point)
 (setf *active-db* database-name)
 (setf *save-directory* (getp database-name 'save-directory))
 (mapc (function (lambda (%relation-name)
   (putp (intern-local (string-upcase (car %relation-name)) *pkg-string*)
 (getp (intern-local (string-upcase
       (string-append database-name "-" (car %relation-name)))
     *pkg-string*)
       'entry-point)
 'entry-point)))
       (retrieve 'system-relation 'project '(relation-name) 'tuples t))))
  t)
PPPPPPQPJ@OBREDEFINE-REL"aBHF?$B:BV]FB:B:B:BYFB^B\	BBcIMPCSSKEYCTUPLE-FORMAT-LISTBDIRCTUPLE-LISTB:\TEMP-RELSTATUS?\Bl\pB\lXR-BQ-LISTBC*PROVIDE-STATUS-MESSAGES*GENSYMBLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540793. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "PRINT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2755785296. :AUTHOR "REL3" :LENGTH-IN-BYTES 13236. :LENGTH-IN-BLOCKS 13. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; PRINT*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     listarray*
;1;;     errset*

;;; Change history
;;; 04.30.87  MRR   Fixed typo in printrel-internal* that caused a bug (SPR#4531).

(defun print-tuple (tuple tuple-format pathname output-to-window blanks stream
    &aux attr-list len)
  (cond ((null output-to-window)
 (print-tuple* tuple tuple-format pathname blanks stream))
(t
 (mapcar (function (lambda (%tuple)
     (setf attr-list  (list "|"))
     (mapc (function (lambda (tup tupfmt)
       (setf tup (with-output-to-string (x) (prin1 tup x)))
       (setf len (length tup))
       (setf attr-list
     (append
       attr-list
       (cond ((> len tupfmt)
      (list (list (concatenate 'string
    (subseq tup 0
       (- tupfmt 1)) "@") tup)))
     (t
      (list (list (concatenate 'string
    tup
    (subseq blanks 0
       (- tupfmt len))) tup))))
       (list "|")))))
   %tuple tuple-format)
     (mapc (function (lambda (x)
       (cond ((listp x)
      (cond-every (pathname
   (princ (car x) pathname))
  (stream
   (princ (car x) stream))))
     (t
      (cond-every (pathname
   (princ x pathname))
  (stream
   (princ x stream)))))))
   attr-list)
     (cond-every (pathname
  (terpri pathname))
 (stream
  (terpri stream)))
     attr-list))
 tuple))))

(defun print-tuple* (tuple tuple-format pathname blanks stream
     &aux len)
  (mapc (function (lambda (%tuple)
    (cond-every (pathname
 (princ "|" pathname))
(stream
 (princ "|" stream)))
    (mapc (function (lambda (tup tupfmt)
      (setf tup (format nil "~S" tup))
      (setf len (length tup))
      (cond ((> len tupfmt)
     (setf tup (concatenate 'string (subseq tup 0 (- tupfmt 1)) "@"))
     (cond-every (pathname
  (princ tup pathname))
 (stream
  (princ tup stream))))
    (t
     (setf tup (concatenate 'string tup (subseq blanks 0
   (- tupfmt len))))
     (cond-every (pathname
  (princ tup pathname))
 (stream
  (princ tup stream)))))
      (cond-every (pathname
   (princ "|" pathname))
  (stream
   (princ "|" stream)))))
  %tuple tuple-format)
    (cond-every (pathname
 (terpri pathname))
(stream
 (terpri stream)))))
tuple))

(defun print-tuple-wide (tuples project-attributes number-per-line output-to-window pathname stream
 &aux (items nil) att-sts
 (screen (if (> (send tv:default-screen ':height) (send tv:default-screen ':width))
     85.
     110.)))
  (setf att-sts (mapcar #'(lambda (attr)
    (length (format nil "~S" attr)))
project-attributes))
  (cond ((null output-to-window)
 (print-tuple-wide* tuples project-attributes number-per-line pathname stream att-sts screen))
(t
 (mapc (function (lambda (tuple &aux (line-item nil) (line-length 0.) (number-in-line 0.))
   (mapc (function (lambda (attr val at-st &aux val-st dum-val)
     (setf val-st (length (format nil "~S" val)))
     (cond ((or (equal number-per-line number-in-line)
(> (+ 5 line-length at-st val-st) screen))
    (cond-every (pathname
 (terpri pathname))
(stream
 (terpri stream)))
    (setf number-in-line 0. line-length 0.)
    (setf items (cons line-item items))
    (setf line-item nil)))
     (setf line-item
   (append line-item
   (list (list ':item1 attr 'attribute) ": "
 (list (setf dum-val
     (if (stringp val)
 (with-output-to-string (x)
   (prin1 val x))
 val))
       dum-val) "  ")))
     (cond-every (pathname
  (prin1 attr pathname)
  (princ ": " pathname)
  (prin1 val pathname)
  (princ "  " pathname))
 (stream
  (prin1 attr stream)
  (princ ": " stream)
  (prin1 val stream)
  (princ "  " stream)))
     (setf number-in-line (+ 1 number-in-line))
     (setf line-length (+ 5 line-length at-st val-st))))
 project-attributes tuple att-sts)
   (if line-item
       (setf items (cons line-item items)))
   (setf items (cons " " items))
   (cond-every (pathname
(terpri pathname))
       (stream
(terpri stream)
(terpri stream)))))
       tuples)
 (reverse items))))

(defun print-tuple-wide* (tuples project-attributes number-per-line pathname stream att-sts screen)
  (mapc (function (lambda (tuple &aux (line-item nil) (line-length 0.) (number-in-line 0.))
    (mapc (function (lambda (attr val at-st &aux val-st)
      (setf val-st (length (format nil "~S" val)))
      (cond ((or (equal number-per-line number-in-line)
 (> (+ 5 line-length at-st val-st) screen))
     (cond-every (pathname
  (terpri pathname))
 (stream
  (terpri stream)))
     (setf number-in-line 0. line-length 0.)
     (setf line-item nil)))
      (cond-every (pathname
   (prin1 attr pathname)
   (princ ": " pathname)
   (prin1 val pathname)
   (princ "  " pathname))
  (stream
   (prin1 attr stream)
   (princ ": " stream)
   (prin1 val stream)
   (princ "  " stream)))
      (setf number-in-line (+ 1 number-in-line))
      (setf line-length (+ 5 line-length at-st val-st))))
  project-attributes tuple att-sts)
    (cond-every (pathname
 (terpri pathname))
(stream
 (terpri stream)
 (terpri stream)))))
tuples))

(defun print-wide-format (relation project-attributes number-per-line output-to-window pathname item-list
  list-of-tuples attributes card stream
  &aux (new-items nil) temp)
  attributes
  (if output-to-window
      (progn
(setf new-items (cons (list "Relation:  " (list ':item1 relation 'relation)
    "  Database:  " (list ':item1 *active-db* 'database)
    "  Cardinality:  " card)
      new-items))
(putp relation (if (setf temp (length (send *output-window* ':items)))
   temp
   1)
      ':index)
(setf new-items (cons (list " ") new-items)))
      (progn
(terpri stream)
(format stream "Relation: ~S  Database:  ~S  Cardinality: ~S" relation *active-db* card)
(terpri stream)
(terpri stream)))
  (if pathname
      (progn
(terpri pathname)
(format pathname "~%Relation: ~S  Database:  ~S  Cardinality: ~S" relation *active-db* card)
(terpri pathname)
(terpri pathname)))
  (if list-of-tuples
      (setf item-list (append item-list(reverse new-items)
      (print-tuple-wide list-of-tuples project-attributes number-per-line
output-to-window pathname stream))))
  (if pathname
      (close pathname))
  (if output-to-window
      (send *output-window* ':set-items item-list))
  relation)

(defun printrel-internal* (relation list-of-tuples project-attributes number-per-line wide-format stream
   output-to-file tuple-format header tail card
   &optional (print? t) (return-tuples nil)
   &aux attributes pathname output-to-window rowline attr-list item-list qtrieve-var
   (new-item-list nil) blanks first last)
  (block printrel-internal*
(cond ((not (stringp relation))
       (setf project-attributes (mapcar (function (lambda (attribute)
    (read-from-string (string-upcase attribute))))
project-attributes))))
  (setf output-to-window (car (errset (send  *output-window* ':exposed-p) nil)))
  (if (null print?)
      (setf output-to-window nil))
  (cond (output-to-file
 (setf pathname (cond ((listp output-to-file)
       (car (errset (eval (append '(open) output-to-file '(:direction :output))))))
      (t
       (car (errset (open (setf pathname output-to-file) ':direction :output) nil)))));mrr 04.30.87
 (if (and (null pathname) *provide-error-messages*)
     (format *standard-output* "~%ERROR - ~S is a bad file." output-to-file)))
(t
 (setf pathname output-to-file)))
  (if output-to-window
      (setf item-list (listarray (send *output-window* ':items))))
  (if output-to-window (scroll-to-bottom))
  ;;1If the relation is to be printed wide, return-from printrel-internal* with the following call.*
  (if (and (not stream) (not output-to-window) print?)
      (setf stream *standard-output*))
  (if return-tuples
(progn
  (if stream
      (format stream "~%~s" list-of-tuples))
  (if pathname
      (progn
(format pathname "~%~s" list-of-tuples)
(close pathname)))
  (return-from printrel-internal* t)))
  (if wide-format
      (progn
(if number-per-line
    number-per-line
  (setf number-per-line -1))
(return-from printrel-internal* (print-wide-format (string-upcase relation) project-attributes
   number-per-line output-to-window
   pathname item-list list-of-tuples attributes card
   stream))))
  ;1;*
  ;;1Form the row-line*
  (setf tuple-format (mapcar (function (lambda (attr form)
 (if form
     form
     (length (format nil "~S" attr)))))
     project-attributes tuple-format))
  (setf rowline  (make-array (+ 1 (length project-attributes)
(apply (function +) tuple-format)) ':type 'art-string ':initial-value 45))
  (setf blanks (make-array (+ 1 (length project-attributes)
      (apply (function +) tuple-format)) ':type 'art-string ':initial-value 32))
  ;;1If the header is true, then print the header information.*
  (if header
      (progn
(if output-to-window
    (progn
      (setf new-item-list (cons " " new-item-list))
      (setf new-item-list  (cons (list "Relation :  " (list ':item1 (string-upcase relation) 'relation)
       "    Database :  "
       (list ':item1  *active-db* 'database)
       "    Cardinality :  " card)
 new-item-list))
      (setf new-item-list (cons rowline new-item-list))
      (putp relation (if (setf qtrieve-var  (length (send *output-window* ':items)))
 qtrieve-var
 1)
    ':index)
      (setf first (+ 4 qtrieve-var))))
;;1Eventhough the code for *standard-output* and pathname looks alike, we have to repeat inorder*
;;1to allow for both options when in lisp-listener.*
(if stream
  (progn
    (terpri stream)
    (format stream  "Relation :  ~S    Database :  ~S    Cardinality :  ~S"
    (string-upcase relation) *active-db* card)
    (terpri stream)
    (format stream rowline)
    (terpri stream)))
(if pathname
    (progn
      (format pathname "~%Relation :  ~S    Database :  ~S   Cardinality :  ~S"
      (string-upcase relation) *active-db* card)
      (terpri pathname)
      (format pathname rowline)
      (terpri pathname)))
(setf attr-list (list "|"))
(mapcar (function (lambda (tup tupfmt &aux len)
    (setf tup (format nil "~s" tup))
    (setf len (length tup))
    (setf attr-list (append
      attr-list
      (list (cond ((> len tupfmt)
   (list ':item1 (list
   (concatenate 'string
     (subseq tup 0 (- tupfmt 1))
     "@") tup)
 'attribute))
  (t
   (list ':item1
 (list (concatenate 'string
 tup
 (subseq blanks 0 (- tupfmt len)))
       tup)
 'attribute))))
      (list "|")))))
project-attributes tuple-format)
(if output-to-window
    (setf new-item-list (cons attr-list new-item-list)))
(mapcar (function (lambda (x &aux y)
    (cond ((listp x)
   (cond-every (pathname
(princ (if (listp (setf y (cadr x)))
   (car y)
   y)
       pathname))
       (stream
(princ (if (listp (setf y (cadr x)))
   (car y)
   y)
       stream))))
  (t
   (cond-every (pathname
(princ x pathname))
       (stream
(princ x stream)))))))
attr-list)
(if pathname
    (progn
      (terpri pathname)
      (format pathname rowline)
      (terpri pathname)))
(if output-to-window
    (setf new-item-list (cons rowline new-item-list)))
(if stream
    (progn
      (terpri stream)
      (format stream rowline)
      (terpri stream)))))
  ;;1Now see if there are any list-of-tuples. Otherwise, print all tuples.*
  (setf item-list (append item-list (reverse new-item-list)))
  (if list-of-tuples
      (setf item-list (append item-list (print-tuple list-of-tuples tuple-format pathname output-to-window
     blanks stream))))
  (setf last (- (length item-list) 1))
  ;;1See if the tail is to be printed.*
  (if pathname
      (progn
(format pathname rowline)
(close pathname)))
  (if stream
      (format stream rowline))
  (if (and tail output-to-window)
      (setf item-list (append item-list (list rowline))))
  (if output-to-window
      (progn
(send *output-window* ':set-items item-list)
(putp relation (list first last) 'items)))
 (return-from printrel-internal* relation)))
ring-equal))
   (progn
     (if *provide-error-messages*
 (format *standLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540797. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "PRINT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360237. :AUTHOR "REL3" :LENGTH-IN-BYTES 3284. :LENGTH-IN-BLOCKS 7. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              pp2\COMPILE-DATA\SW-MFG,GODZILLA>FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8PRINT\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPPRINT-TUPLECAFS$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÀTUPLETUPLE-FORMAT*PATHNAMEOUTPUT-TO-WINDOWÀBLANKSSTREAMB:\CATTR-LISTLENB:B:B:À%TUPLEB:B:TUPÀTUPFMTCXB:B:\)MACROS-EXPANDED\pBTlCOND-EVERYWITH-OUTPUT-TO-STRINGSETFPROGpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSPRINT-TUPLE*l|LISTjMAKE-STRING-OUTPUT-STREAMPRIN1*GET-OUTPUT-STREAM-STRINGSTRINGSUBSEQl@CONCATENATEAPPENDPRINCTERPRIQQQQQBрQDCvCQDSEP@EQQGF+FSGSIHJHQJQJQHÊCA@QAQI#	PHQJIm
P	PHQQJIQAc
HQP@FGFG@QF'FSJJ5KLۂJSQLK݅JSQLKLKۂJQQKL݅JQQKLFLKۂQKL݅QKL@QCCDDBOBPBz@AhFL$B:BV]FB:B:B:BYFB^Bz\B`BaBbBdBeB:\
BhB:BiB:B:B:BjBkB:B:\Bn\BsBqBtBwByl|Bl~SFORMATBBl@BBQA|ASBCDۂPQDC݄PQDCBQQCERESCSGFPFQFÊC@G#PFQJGm	P
FHIۂFQQIH݄FQQIHPFQQJGQ@c
FIHۂFQQHI݄FQQHIIHۂPQHI݄PQHIECECIHۂQHI݄QHIAńOBzPRINT-TUPLE-WIDEeᆀF|$B:BV]FB:B:B:BYFB^B\ÀTUPLESCPROJECT-ATTRIBUTESNUMBER-PER-LINEBcBbBeB:\ÀITEMSATT-STSÀSCREENB:B:B:ATTRB`CLINE-ITEMLINE-LENGTHÁNUMBER-IN-LINEB:B:B:VALÀAT-STÀVAL-STDUM-VALB:B:Bl\Bn\BrBqBtBwBypBTSENDBsÀplTVDEFAULT-SCREENHEIGHTWIDTHl~SBCPRINT-TUPLE-WIDE*BITEM1CATTRIBUTEB|l: B}B~Bl  pB\,*APPENDBl *REVERSEPPyUJnJBCсQEDDQESFPFQCCDEECQA	QQQQQAQBQJ	QDDSGHIJ߁QGQAQMLKoKSLSMSONFPQPNQCPQJ+JIaOaPaB#RSۄQ
SR݅Q
SRJIHQ@]@HHQPFQPPN7TNQTQTQNQQQQPHSRۄFQQPQNQQPQRS݅FQQPQNQQPQRSJJIaOaPaIKLMKLMHHQ@]@P@]@SRۄQ
RS݅Q
Q
RSDf@QOBB
=A
FG$B:BV]FB:B:B:BYFB^B\BBBBbBeBBB:\B:B`BBBB:B:B:BBBBB:B:\Bn\BqBsBtBwByl~SBBB~l: Bl  Q@v@SABCD߁QAQQGFESESFSGSJIHKPIQCKQD+JCaJaKa#LMۃQML݄QMLDCBMLۃHQQPQIQQ	PQLM݄HQQPQIQQ	PQLMDJCaJaKaCEFGEFGMLۃQLM݄QQLM@ŊOBCPRINT-WIDE-FORMAT*mBFC$B:BV]FB:B:B:BYFB^B\
RELATIONBBBcBbCITEM-LISTÁLIST-OF-TUPLESCATTRIBUTESCARDBeB:\CNEW-ITEMSTEMP\Bn\BBs*OUTPUT-WINDOW*у*ACTIVE-DB*Relation:  BBB|  Database:  DATABASE,  Cardinality:  ITEMSINDEXPUTPl BҬRelation: ~S  Database:  ~S  Cardinality: ~SB~%Relation: ~S  Database:  ~S  Cardinality: ~SBBBCLOSEiSET-ITEMSPPQP	PPP
PPQC@QPCAAQJPP@]@QQPQPQQQQQPQPQQQQ@QQQQQQQQPQOBCPRINTREL-INTERNAL*CGCFE$B:BV]FB:B:B:BYFB^B\BBBBWIDE-FORMATBeÁOUTPUT-TO-FILEBaÀHEADERTAILBj&OPTIONAL\ÀPRINT?BY\ÁRETURN-TUPLESB:B:\BbBcROWLINEBgBރQTRIEVE-VARÁNEW-ITEM-LISTBdFIRSTLASTB:B:B:BB:B:BFORMBjBkBhBlCYB:\Bn\BqBpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETBtBwByBs1fplEH*CONDITION-HANDLERS*Bj*STANDARD-OUTPUT**PROVIDE-ERROR-MESSAGES*BSTRING-UPCASE*READ-FROM-STRINGp,G5649FERRORpB\ERRSET-HANDLERiEXPOSED-PB|pB$G5657F\OPEN\iDIRECTIONOUTPUTBҪEVALpB$G5665FB2B3B0B,ERROR - WRITE-STRINGB~, is a bad file.BpBTlLISTARRAYSCROLL-TO-BOTTOMҬ~%~sBBBl~Sj+pB\lSIMPLE-MAKE-ARRAYl Relation :  BB,    Database :  B    Cardinality :  BBRelation :  ~S    Database :  ~S    Cardinality :  ~S~%Relation :  ~S    Database :  ~S   Cardinality :  ~Sl|l~sBBl@BBBBBBPBBv݀7JтQLK	KQLSM	
CKLLJQPPTPPPJCJPJCNPJ!BJ!B\BAAۆ@5PPTPPPJCKPJCOPQPJ!BJ!BPPTPPPJCLPJCJֆQ@PP\B@
PQ PQ@A!P"DA#APQ$PQ%@@Q$PQ%@Q&SLQ	QQAQ@QDQQۊQQ
J'OOтQQLKJJQKSLSQPQQQ(PPQ%CCJKLKLOQQCkQ)PEa	J-J*BQCkQ)PEa	J J*GA$+PCF,P-PQ	.P/P-PP0P1PQF]FBQF]FQ!PCEEQJ2P3JEaHQQ4PQ	PQ%QQBQ%Q@@Q5PQ	PQ%@Q@QBQ%@Q6PCOOтQQLKJ/JQKSLSSRT7PRQ%RÊCTCQ-PTQS#8PRQJSm9:P8PRQGQJSQTc9;RQ<P6PCCJKLKLACQF]FOOCQLK9KQLSUVU5JW@UWV5VSVQ@Q=WJ݅UWV5VSVQQ=WJWQWJ@UQ@Q=JW݅UQQ=JWJQCKLL@@Q@QBQ%@QABQF]FQQBQ%QDQFQ>?D
DQQQ@QAQGQQ@?DDQCmI@@QBQ%@Q&QBQ%ADQBQ?DA	APDQQHQIQBP3OLB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B-i\B~z\B<p\B`sN\B|\BaM*\By(̢\Bw*j\Bt=#\Bs[\Br5%\Bq9))
      (progn
(terpri stream)
(format stream "Relation: ~S  Database:  ~S  Cardinality: ~S" relation *active-db* card)
(terpri stream)
(terpri stream)))
  (if pathname
      (progn
(terpri pathname)
(format pathname "~%Relation: ~S  Database:  ~S  Cardinality: ~S" relation *active-db* card)
(terpri pathname)
(terpri pathname)))
  (if list-of-tuples
      (setf item-list (append item-list(reverse new-items)
      (print-tuple-wide list-of-tuples project-attributes number-per-line
output-to-window pathname stream))))
  (if pathname
      (close pathname))
  (if output-to-windLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540800. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "RELATION-OPS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2751306599. :AUTHOR "REL3" :LENGTH-IN-BYTES 54309. :LENGTH-IN-BLOCKS 54. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; RELATION-OPS*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp d as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     errset*

;1;*;1 If the INTO parameter has been provided, it determines the name of the output relation. PROJECT* 1is used to indicate the attributes from *
;1;; relations relA and relB to be used in the output relation. If the user wants to rename any attributes, he will have to do it the way it is *
;1;; done for relB.b1. If any attributes are unique, then the prefix "relX." is not necessary (same thing applies to WHERE clause). Finally, the *
;1;; user can use "*" to indicate that he wants all attributes from that relation are to be used. WHERE is used to indicate the attributes to *
;1;; which the THETA-OPERATORS are applied. The individual where-clauses are implicitly anded. *
;1;*;
;1;*;1 Right now JOIN is done as follows: Take a tuple in relA and substitute the values for all the relA attributes in the WHERE clause. Call *
;1;; retrieve for relB with the modified WHERE clause as the where-cl. Form a projected cartesan product of all the tuples returned and the *
;1;; tuple in relA. This is repeated for all tuples in relA and the result is inserted into relC.*
;;1;*
(defun join-internal (keyword-list
      &aux rela-attributes-user relb-attributes-user unknown-attributes-user print all-attrs
      from-clause jrelb-project jrela-format jrelb-format jrelc-format temp join-attrc
      join-insert-list where attrsa attrsb a-join-attrc reader-package jrela jrelb jrelc impa
      ssa attr-imp jrelb-implementation-type jrelb-storage-structure jrelb-key)
  (block join-internal
  1 *(if (not (active-database))
1        *(return-from join-internal nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (cond ((or (null keyword-list) (null (car keyword-list)))
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - No parameters passed to JOIN")
(return-from join-internal nil)))))
1   *(setf jrela nil
1 *join-attrc nil
1 *a-join-attrc nil
1 *jrelb nil)
   (setf print (member 'print keyword-list))
   (if print
       (setf print (cadr print)))
1   *(setf keyword-list (get-keyword-value-prereq '(into where from imp sto key format dir doc print tuples
       project unique)
        keyword-list))
1   *(setf jrelc (car (get-keyword-value '(into) keyword-list))
 where (or (car (get-keyword-value '(where) keyword-list)) t)
 from-clause (car (get-keyword-value '(project) keyword-list)))
   ;;
   ;;1The original from-clause used to be what the project-clause now is.*
   ;;
   (if (and (null (car (get-keyword-value '(tuples) keyword-list))) (null jrelc) (null print)
    (null (member 'print  keyword-list)))
       (setf print t))
   (if (and (setf temp (car (get-keyword-value '(from) keyword-list))) (not (listp temp)))
       (setf temp (list temp)))
   (cond-every ((first temp)
(if (null (setf jrela (validate-sym (first temp))))
    (return-from join-internal nil)))
       ((second temp)
(if (null (setf jrelb (validate-sym (second temp))))
    (return-from join-internal nil)))
       ((null (first temp))
(setf jrela nil))
       ((null (second temp))
(setf jrelb nil))
       ((third temp)
(if *provide-warning-messages*
    (format *standard-output* "~%WARNING - More than two relations are provided for joining. The first two will be considered."))))
   ;1;*
   ;1;Parse the FROM clause.*
   ;1;*
  (cond ((and (null jrela) (null jrelb)(null from-clause))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The relations to be joined are not provided."))
 (return-from join-internal nil))
((null jrelb)
 (setf jrelb jrela)))
  (cond ((null from-clause)
 (setf from-clause (list (add-dot jrela "*") (add-dot jrelb "*")))))
  (cond (jrela
 (setf reader-package (package-name (symbol-package jrela))))
(jrelb
 (setf reader-package (package-name (symbol-package jrelb)))))
  (multiple-value-setq (from-clause jrela jrelb join-attrc a-join-attrc unknown-attributes-user
    rela-attributes-user relb-attributes-user)
    (parse-from-clause from-clause jrela jrelb join-attrc a-join-attrc unknown-attributes-user
       rela-attributes-user relb-attributes-user))
  ;;
  ;;1  This section was added to handle the problem of a NIL reader-package. Reader-package must not be NIL. 12/12/85 smc*
  ;;
  (cond ((null reader-package)
 (cond ((symbolp jrela)
(setf reader-package (package-name (symbol-package jrela))))
       ((symbolp jrelb)
(setf reader-package (package-name (symbol-package jrelb))))
       (t
(setf reader-package *pkg-string*)))))
  (if (or (string-equal reader-package "GLOBAL")(equal reader-package 'global))
      (setf reader-package *pkg-string*))

  ;;1See if two relations have been provided. If only one is provided, we will perform self-join.*
  ;;
  (cond ((and (null jrela) (null jrelb))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - The FROM clause has not specified the relations to be joined."))
 (return-from join-internal nil))
((null jrelb)
 (setf jrelb jrela)))
  ;;
  ;;1 Get the attributes of relation A*
  ;;
  ;;1 jrela is reset because it might have been a view name. In this case, the view defination would have been executed and the name of
   *;1; the resultant relation would be returned.*
  ;;
  (setf attrsa (get-relation jrela '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY" "TUPLE-FORMAT"
     "CARDINALITY") nil))
  (cond ((null (cadr attrsa))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Relation ~s does not exist" jrela))
 (return-from join-internal nil)))
  (setf attrsb (get-relation jrelb '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY" "TUPLE-FORMAT"
     "CARDINALITY") nil))
  (cond ((null (cadr attrsb))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Relation ~s does not exist" jrelb))
 (return-from join-internal nil)))
  ;;
  ;;1  Determine the smallest relation and make it the second relation. This is done to improve the speed.*
  ;;
  (if (> (sixth (second attrsa)) (sixth (second attrsb)))
      (progn
(setf temp attrsa)
(setf attrsa attrsb)
(setf attrsb temp)
(setf temp rela-attributes-user)
(setf rela-attributes-user relb-attributes-user)
(setf relb-attributes-user temp)))
  (setf jrela (car attrsa)
attrsa (cadr attrsa)
impa (second attrsa)
ssa (third attrsa)
jrela-format (fifth attrsa)
attrsa (first attrsa))
  ;;
  ;;1 Get the attributes of relation B*
  ;;
  ;;1 jrelb is reset because it might have been a view name. In this case, the view definition would have been executed and the name of
   *;1; the resultant relation would be returned.*
  ;;
  (setf jrelb (car attrsb)
attrsb (cadr attrsb)
jrelb-implementation-type (second attrsb)
jrelb-storage-structure (third attrsb)
jrelb-key (fourth attrsb)
jrelb-format (fifth attrsb)
attrsb (first attrsb))
  ;;
  ;;1  Determine if the attributes specified are really from the specified relations*
  ;;
  (cond ((or (not (symbolp jrela))(not (symbolp jrelb)))
 (cond ((symbolp jrela)
(setf jrelb (find-symbol (string-upcase jrelb))))
       ((symbolp jrelb)
(setf jrela (find-symbol (string-upcase jrela))))
       (t
(setf jrelb (find-symbol (string-upcase jrelb))
      jrela (find-symbol (string-upcase jrela)))))))
  (setf rela-attributes-user (convert-attributes rela-attributes-user)
relb-attributes-user (convert-attributes relb-attributes-user)
unknown-attributes-user (convert-attributes unknown-attributes-user))
  (mapc (function (lambda (attribute)
    (cond ((not (member attribute attrsa :test 'string-equal))
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - ~s is not an attribute of relation ~s"
       attribute jrela))
   (return-from join-internal nil)))))
rela-attributes-user)
  (mapc (function (lambda (attribute)
    (cond ((not (member attribute attrsb :test 'string-equal))
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - ~s is not an attribute of relation ~s"
       attribute jrelb))
   (return-from join-internal nil)))))
relb-attributes-user)
  ;;
  ;;1  Determine if the unknown attributes are from either relation. If so, make sure that they have been specified correctly in the
   *;1; attribute-name lists.*
  ;;
  (mapc (function (lambda (attribute)
    (cond ((and (not (member attribute attrsa :test 'string-equal))
(not (member attribute attrsb :test 'string-equal)))
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - ~s is not an attribute of either relation"
       attribute))
   (return-from join-internal nil))
  ((and (member attribute attrsa :test 'string-equal)
(member attribute attrsb :test 'string-equal))
   (cond (*provide-error-messages*
  (format *standard-output*
  "~%ERROR - ~s is an attribute of both relations: ~S and ~S."
  attribute jrela jrelb)
  (format *standard-output*
  "~%        It is unclear which attribute should be used")))
   (return-from join-internal nil)))))
unknown-attributes-user)
  ;;
  ;;1  Put the attribute names in the form in which they will appear in the resultant relation. Must expand the relx.* forms to the final names.*
  ;;
  (multiple-value-setq (join-attrc a-join-attrc jrelb-project)
    (parse-join-attributes join-attrc a-join-attrc jrelb-project attrsa attrsb jrela jrelb))
  ;;
  ;;1  Make a list of all of the attribute which are in both relations with the proper relation name appened to each.*
  ;;
  ;;1 I need the following list in EVAL*
  ;;
  (setf all-attrs (append1 *(mapcar (function (lambda (attr)
      (add-dot jrela attr)))
  attrsa)
  (mapcar (function (lambda (attr)
      (add-dot jrelb attr)))
  jrelb-project)))

  ;;
  ;;1  Make sure that no attribute was specified more than once*
  ;;
  (setf temp nil
join-attrc (reverse join-attrc))
  (do ((attribute join-attrc (cdr attribute)))
      ((null attribute) t)
    (cond ((member (car attribute) (cdr attribute) :test 'string-equal)
   (setf temp (append temp (list  (concatenate 'string (string-upcase jrelb) "."
       (string-upcase (car attribute)))))))
  (t
   (setf temp (append temp (list (string-upcase (car attribute))))))))
  (setf join-attrc (reverse temp))
  (setf jrelc-format (car (project-list (list (append jrela-format jrelb-format)) all-attrs a-join-attrc)))

  ;;1See if the resultant relAtion exists.*
  (if jrelc
      (progn
(setf attr-imp nil)
(multiple-value-setq (jrelc attr-imp)
  (join-into jrelc join-attrc a-join-attrc keyword-list jrelc-format impa ssa attr-imp))
(if (not jrelc)
    (return-from join-internal nil))))
  (setf join-insert-list (join-eval jrela jrelb attrsa attrsb jrelb-project jrelb-key where
    jrelb-storage-structure jrelb-implementation-type reader-package))
  (cond ((string-equal (string-upcase jrela) (string-upcase jrelb))
 (setf all-attrs nil)
 (do ((attribute a-join-attrc (cdr attribute)))
     ((null attribute) t)
   (if (member (car attribute) (cdr attribute) :test 'string-equal)
       (setf all-attrs (append all-attrs (list (remove-dot-attr (car attribute)))))
       (setf all-attrs (append all-attrs (list (car attribute))))))
 (setf a-join-attrc all-attrs)
 (setf all-attrs (append attrsa (mapcar (function (lambda (attr)
    (add-dot jrelb attr)))
jrelb-project)))))
  (setf join-insert-list (project-list join-insert-list all-attrs a-join-attrc))
  ;;
  ;;1  Complete the join by inserting the tuple*s1 formed by the join*
  ;;
  (if (and (car (get-keyword-value '(unique) keyword-list)) join-insert-list)
      (setf join-insert-list (unique-tuples join-insert-list)))
  (if (and jrelc join-insert-list)
      (progn
(funcall (find-symbol
   (concatenate 'string "INSERT-"
  (if (cadr attr-imp)
      (concatenate 'string (string-upcase (second (second attr-imp))) "-"
   (string-upcase (third (second attr-imp))))
      (concatenate 'string (string-upcase
     (or (car (get-keyword-value '(imp) keyword-list))
 impa))
     "-"
     (string-upcase
       (or (car (get-keyword-value '(sto) keyword-list))
   ssa))))) *pkg-string*)
 jrelc join-attrc join-insert-list
 (if (cadr attr-imp)
     (fourth (second attr-imp))
     join-attrc)
 jrelc)
(delete-or-modify 'system-relation t (list 'string-equal 'relation-name (string-upcase (string jrelc)))
  '("MODIFIEDP" "CARDINALITY") (list t (+ (if (cadr attr-imp)
      (fifth (second attr-imp))
      0)
  (length join-insert-list))))
(delete-or-modify 'system-relation t (list 'string-equal 'relation-name "SYSTEM-RELATION")
  '("MODIFIEDP") (list t))))
  (cond ((car (get-keyword-value '(tuples) keyword-list))
 (return-from join-internal join-insert-list))
((and print jrelc)
 (printrel-internal* jrelc join-insert-list join-attrc nil nil nil nil
     (if (second attr-imp)
 (sixth (second attr-imp))
 (or (car (get-keyword-value '(format) keyword-list)) jrelc-format))
     t t (length join-insert-list))
 (return-from join-internal jrelc))
(print
 (printrel-internal* 'join join-insert-list join-attrc nil nil nil nil
     (if (< (length (car (get-keyword-value '(format) keyword-list)))
    (length join-attrc))
 (append (car (get-keyword-value '(format) keyword-list))
 (make-list (length join-attrc) ':initial-element *default-anyp-width*))
       (car (get-keyword-value '(format) keyword-list))) t t (length join-insert-list))
 (return-from join-internal t)))
 (return-from join-internal (or jrelc jrela))))

(defun join (&rest keyword-list
     &key from &key &optional project where into directory documentation format implementation-type
     key storage-structure print tuples1 *unique
     &allow-other-keys)
  "This function provides the capability to combine two relations into a new relation
   in which the tuples which are to participate in the operation are selected
   by a where clause.

   FROM                 - A list consisting of the relations to be joined.
   PROJECT              - This clause specifies the attributes that are to be in the resultant relation
                          and their associated names in that new relation. It should be of the form
                          (<[relation-name.]attribute-name>). The optional part relation-name can be
                          skipped if the attribute is unique in one of the two relations being joined.
                          If the keyword FROM is not specified, this clause should contain the names
                          of the relations to be joined. Also, if * is given instead of the attribute-name
                          it indicates that RTMS should use all the attributes in that relation.
   WHERE                - Can be used to perform theta-joins. It is a condition used in joining the relations.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation."
   from where into directory documentation format project implementation-type key storage-structure print
   tuples unique
   (join-internal keyword-list))

(defun process-where (tuplea attrsa where-exp jrela jrelb attrsb
      &aux new-where temp)
  (block process-where
   (if (and (listp where-exp)
    (apply 'or (mapcar #'(lambda (x)
   (listp x))
       (cdr where-exp))))
       (return-from process-where (cons (car where-exp) (mapcar (function (lambda (x)
 (process-where tuplea attrsa x jrela jrelb attrsb)))
     (cdr where-exp)))))
   (cond ((not (listp where-exp))
  (setf new-where (car (process-where tuplea attrsa (list where-exp) jrela jrelb attrsb))))
 ((equal (car where-exp) 'quote)
  (setf new-where where-exp))
 (t
  (setf jrela (string-upcase jrela)
jrelb (string-upcase jrelb))
  (mapc (function (lambda (x)
    (cond ((and (and (or (symbolp x) (stringp x)) (POSITION #\. (string-upcase x)))
(member (string-upcase (remove-dot-attr x)) attrsa :test 'string-equal)
(string-equal (string-upcase (remove-dot-rel x)) jrela))
   ;;
   ;;1We need to quote the value being substituted in the where clause from the tupleA.*
   ;;1Consider (EQ attrA attrB) if we substitute RAJINI for attrA and call RETRIEVE**
   ;;1with (EQ RAJINI attrB) as the where clause it will give an error stating that*
   ;;1the variable RAJINI is unbound.*
   ;;
   (setf temp `(quote ,(nth (position (string-upcase (remove-dot-attr x))
      attrsa :test 'equal)
    tuplea)))
   ;;
   ;;1To allow WHERE of the form (EQUAL rel1.a1 rel1.a1) and instead of substituting the rel.a1*
   ;;1value in both occurences and hence end up with a cartesan product, we have the following *
   ;;1check.*
   ;;
   (if (and (member temp new-where) (equal (string-upcase (remove-dot-rel x))
   jrelb))
       (setf new-where (append new-where (list (remove-dot-attr x))))
       (setf new-where (append new-where (list temp)))))
  ((member (string-upcase x) attrsa :test 'string-equal)
   (setf temp `(quote ,(nth (position (string-upcase x) attrsa :test 'equal)
    tuplea)))
   (setf new-where (append new-where (list temp))))
  ((and (and (or (symbolp x) (stringp x)) (POSITION #\. (string-upcase x)))
(member (string-upcase (remove-dot-attr x)) attrsb :test 'string-equal)
(string-equal (string-upcase (remove-dot-rel x)) jrelb))
   (setf new-where (append new-where (list (remove-dot-attr x)))))
  (t
   (setf new-where (append new-where (list x)))))))
where-exp)))
   (return-from process-where new-where)))

(defun process-set-relation (relation-name project-list
     &aux attributes domains)
  (setf attributes (get-relation relation-name '("ATTRIBUTES" "DOMAINS") nil))
  (cond ((null (cadr attributes))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The ~s relation is not defined in the database ~s"
     relation-name *active-db*))
 (setf relation-name nil))
(t
 (setf relation-name (car attributes)
       domains (second (cadr attributes))
       attributes (caadr attributes))
 (cond (project-list
(if (not (listp project-list))
    (setf project-list (list project-list)))
(mapc #'(lambda (att)
  (cond ((not (member att attributes :test 'string-equal))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - ~S is not an attribute in the relation ~S."
     att relation-name))
 (setf relation-name nil))))
      project-list)
(setf domains (mapcar #'(lambda (attr)
  (nth (- (length attributes) (length (member attr attributes
      :test 'string-equal)))
       domains))
      project-list))
(setf attributes project-list)))))
  (values relation-name attributes domains))

(defun set-compatibility (rela relb attrsa attrsb
  &aux attributesa attributesb domainsa domainsb)
  (block set-compatibility
  ;;
  ;;1  Obtain the attribute of the specified relations and bring them into memory if they do not already reside there.*
  ;;
  (multiple-value-setq (rela attributesa domainsa)
    (process-set-relation rela attrsa))
  (if (null rela)
      (return-from set-compatibility nil))
  ;;
  ;;1  Process the second relation*
  ;;
  (multiple-value-setq (relb attributesb domainsb)
    (process-set-relation relb attrsb))
  (if (null relb)
      (return-from set-compatibility nil))
  ;;
  ;;1  Do they have the same number of attributes ?*
  ;;
  (cond ((null (equal (length attributesa) (length attributesb)))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - Relations ~S and ~S do not have the same number of attributes, thus they are not compatible."
     rela relb))
 (return-from set-compatibility nil)))
  (mapc (function (lambda (attra attrb doma domb)
    (cond ((null (equal doma domb))
   (if *provide-error-messages*
       (format *standard-output*
       "~%ERROR - Attribute ~s of relation ~S and attribute ~s of relation ~S are not compatible domains"
       attra rela attrb relb))
   (return-from set-compatibility nil)))))
attributesa attributesb domainsa domainsb)
  (return-from set-compatibility t)))

(defun set-create-relc (rela relc keyword-list attrsa doc
&aux attribute-descriptor attributes dir dom imp key modp  qtrieve-var ss tuple-format)
  (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes*
  '("MODIFIEDP" "SAVE-DIRECTORY" "ATTRIBUTES" "IMPLEMENTATION-TYPE"
    "STORAGE-STRUCTURE" "KEY" "TUPLE-FORMAT" "DOC" "DOMAINS")
  *system-relation-key*
  (list 'string-equal 'relation-name (string-upcase rela)))))
  (setf modp (first qtrieve-var)
dir (or (car (get-keyword-value '(dir) keyword-list)) (second qtrieve-var))
attributes (third qtrieve-var)
imp (or (car (get-keyword-value '(imp) keyword-list)) (fourth qtrieve-var))
ss (or (car (get-keyword-value '(sto) keyword-list)) (fifth qtrieve-var) )
doc (or (car (get-keyword-value '(doc) keyword-list)) doc)
key (car (get-keyword-value '(key) keyword-list))
tuple-format (or (car (get-keyword-value '(format) keyword-list)) (nth 6 qtrieve-var))
dom (nth 8 qtrieve-var))
  (cond (attrsa
 (if (not (listp attrsa))
     (setf attrsa (list attrsa)))
 (setf dom (mapcar #'(lambda (attr)
       (nth (- (length attributes) (length (member attr attributes
   :test 'string-equal))) dom))
   attrsa))
 (setf attributes attrsa)))
  (do ((dom dom (cdr dom))
       (attributes attributes (cdr attributes)))
      ((null attributes) t)
    (setf attribute-descriptor (append attribute-descriptor (list (car attributes) (list 'dom (car dom))))))
  (defrel relc attribute-descriptor (list 'imp imp 'sto ss 'key key 'format tuple-format 'doc doc 'dir dir)))

(defun relation-difference (&rest keyword-list
    &key &optional from into directory documentation format implementation-type
    storage-structure key print tuples unique
    &allow-other-keys
    &aux tempa temp-tuples temp table rela relb relc print1 tuples1 attrsa wherea
    attrsb whereb attrsc reader-package)
  "Difference of the tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the DIFFERENCE operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation."
   from into directory documentation format unique implementation-type storage-structure key print tuples
  (block relation-difference
(if (not (active-databasep))
    (return-from relation-difference nil))
  (multiple-value-setq (rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package print1)
  (validate-relation-ops keyword-list "2DIFFERENCE"*))
  (if (not rela)
      (return-from relation-difference nil))
  (setf table (make-hash-table :test 'equal))
  (setf temp (retrieve (find-symbol (string-upcase relb)) 'project attrsb 'tuples t
       'unique (car (get-keyword-value '(unique) keyword-list)) 'where whereb))
  (mapc #'(lambda (tuple)
    (puthash tuple (cons tuple (gethash tuple table)) table))
temp)
  (mapc (function (lambda (tuplea)
    (cond ((not (gethash tuplea table))
   ;;1This tuple is in relA but not in relB*
   (setf temp-tuples (cons tuplea temp-tuples))))))
(retrieve (find-symbol (string-upcase rela)) 'tuples t 'project attrsa
  'unique (car (get-keyword-value '(unique) keyword-list)) 'where wherea))
  (cond ((and temp-tuples relc)
 (setf tempa *validity-checking*)
 (setf *validity-checking* nil)
 (insert relc 'tuples temp-tuples 'attributes attrsc)
 (setf *validity-checking* tempa)))
  (clrhash table)
  (cond (tuples1 (return-from relation-difference temp-tuples))
((and print1 relc)
 (setf tempa (cadr (get-relation relc '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
 (printrel-internal* relc temp-tuples (unconvert-attributes (or attrsc (car tempa)) reader-package)
     nil nil nil nil (cadr tempa) t t (length temp-tuples))
 (return-from relation-difference relc))
(print1
 (setf tempa (cadr (get-relation rela '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
 (printrel-internal* 'difference temp-tuples
     (unconvert-attributes (or attrsa (car tempa)) reader-package)
     nil nil nil nil (or (car (get-keyword-value '(format) keyword-list))
 (if attrsa
     (car (project-list (cdr tempa) (car tempa) attrsa))
     (cadr tempa)))
     t t (length temp-tuples))
(return-from relation-difference t)))
  (return-from relation-difference (or relc rela))))

(defun relation-intersection (&rest keyword-list
      &key &optional from into directory documentation format implementation-type
      storage-structure key print tuples unique
      &allow-other-keys
      &aux tempa (tempb nil) temp table rela relb relc tuples1 print1 attrsa wherea
      attrsb whereb attrsc reader-package)
   "Intersection of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the INTERSECTION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation."
   from into directory documentation format implementation-type storage-structure key print tuples unique
  (block relation-intersection
(if (not (active-databasep))
    (return-from relation-intersection nil))
  (multiple-value-setq (rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package print1)
  (validate-relation-ops keyword-list "2DIFFERENCE"*))
  (if (not rela)
      (return-from relation-intersection nil))
  (setf temp (retrieve rela 'tuples t 'project attrsa 'where wherea))
  (setf table (make-hash-table :test 'equal))
  (mapc #'(lambda (tuple)
    (puthash tuple (cons tuple (gethash tuple table)) table))
temp)
  (mapc (function (lambda (tupleb)
    (cond ((gethash tupleb table)
   ;;1This tuple is in both relA and relB*
   (setf tempb (cons tupleb tempb))))))
(retrieve (find-symbol (string-upcase relb)) 'tuples t
  'unique (car (get-keyword-value '(unique) keyword-list)) 'where whereb 'project attrsb))
  (cond ((and tempb relc)
 (setf tempa *validity-checking*)
 (setf *validity-checking* nil)
 (insert relc 'tuples tempb 'attributes attrsc)
 (setf *validity-checking* tempa)))
  (clrhash table)
  (cond (tuples1 (return-from relation-intersection tempb))
((and print1 relc)
 (setf tempa (cadr (get-relation relc '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
 (printrel-internal* relc tempb (unconvert-attributes (or attrsc (car tempa)) reader-package)
     nil nil nil nil (cadr tempa) t t (length tempb))
 (return-from relation-intersection relc))
(print1
 (setf tempa (cadr (get-relation rela '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
 (printrel-internal* 'intersection tempb (unconvert-attributes (or attrsa (car tempa)) reader-package)
     nil nil nil nil (or (car (get-keyword-value '(format) keyword-list))
 (if attrsa
     (car (project-list (cdr tempa) (car tempa) attrsa))
     (cadr tempa)))
     t t (length tempb))
 (return-from relation-intersection t)))
  (return-from relation-intersection (or relc rela))))

(defun relation-union (&rest keyword-list
       &key &optional from into directory documentation format implementation-type
       storage-structure key print tuples unique
       &allow-other-keys
       &aux tempa rela relb relc table tuples1 print1 temp temp-union attrsa wherea attrsb
       whereb attrsc reader-package)
   "Union of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the UNION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation."
   from into directory documentation format implementation-type storage-structure key print tuples unique
  (block relation-union
(if (not (active-databasep))
    (return-from relation-union nil))
  (multiple-value-setq (rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package print1)
  (validate-relation-ops keyword-list "2DIFFERENCE"*))
  (if (not rela)
      (return-from relation-union nil))
  (setf table (make-hash-table :test 'equal))
  (setf temp (retrieve (find-symbol (string-upcase rela))
       'unique (car (get-keyword-value '(unique) keyword-list)) 'project attrsa
       'where wherea 'tuples t))
  (mapc #'(lambda (tuple)
    (puthash tuple (cons tuple (gethash tuple table)) table))
temp)
  (if relc
      (insert relc 'tuples temp 'attributes attrsc))
  (setf temp-union nil)
  (mapc (function (lambda (tuple)
    ;;1See if this tuple exists in RELA.*
    (cond ((null (gethash tuple table))
   (setf temp-union (cons tuple temp-union))))))
(retrieve (find-symbol (string-upcase relb)) 'tuples t
  'unique (car (get-keyword-value '(unique) keyword-list)) 'project attrsb 'where whereb))
  (cond ((and temp-union relc)
 (setf tempa *validity-checking*)
 (setf *validity-checking* nil)
 (insert relc 'tuples temp-union 'attributes attrsc)
 (setf *validity-checking* tempa)))
  (clrhash table)
  (cond (tuples1 (return-from relation-union (append temp temp-union)))
((and print1 relc)
 ;;1Since we don't have all tuples *it 1makes sense to call RETRIEVE.*
 (retrieve (find-symbol (string-upcase relc)) 'project attrsc)
 (return-from relation-union relc))
(print1
 (setf tempa (cadr (get-relation rela '("ATTRIBUTES" "TUPLE-FORMAT") nil)))
 (printrel-internal* 'union (append temp temp-union)
     (unconvert-attributes (or attrsa (car tempa)) reader-package)
     nil nil nil nil (or (car (get-keyword-value '(format) keyword-list))
 (if attrsa
     (car (project-list (cdr tempa) (car tempa) attrsa))
     (cadr tempa)))
     t t (length (append temp temp-union)))
 (return-from relation-union t)))
  (return-from relation-union (or relc rela))))

(defun validate-where (where-clause rela-name relb-name attsa attsb
       &aux test-attribute test-relation)
  (block validate-where
  (cond ((null where-clause)
 (return-from validate-where t))
((equal where-clause t)
 (return-from validate-where t))
((or (> (length where-clause) 3) (listp (first where-clause)) (listp (second where-clause))
     (listp (third where-clause)))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s improperly formed where subclause" where-clause))
 (return-from validate-where nil))
(t
 (setf test-relation (remove-dot-rel (second where-clause)))
 (setf test-attribute (remove-dot-attr (second where-clause)))
 (cond ((null test-relation)
(cond ((not (or (member test-attribute attsa :test 'string-equal)
(member test-attribute attsb :test 'string-equal)))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is an unrecognized attribute"
   test-attribute))
       (return-from validate-where nil))))
       ((equal rela-name test-relation)
(cond ((null (member test-attribute attsa :test 'string-equal))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR -~s is an unrecognized attribute"
   (second where-clause)))
       (return-from validate-where nil))))
       ((equal relb-name test-relation)
(cond ((null (member test-attribute attsb :test 'string-equal))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is an unrecognized attribute"
   (second where-clause)))
       (return-from validate-where nil))))
       (t
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is not a relation in the ~s database"
    test-relation *active-db*))
(return-from validate-where nil)))
 (setf test-relation (remove-dot-rel (third where-clause)))
 (setf test-attribute (remove-dot-attr (third where-clause)))
 (cond ((null test-relation)
(cond ((not (or (member test-attribute attsa :test 'string-equal)
(member test-attribute attsb :test 'string-equal)))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is an unrecognized attribute"
   test-attribute))
       (return-from validate-where nil))))
       ((equal rela-name test-relation)
(cond ((null (member test-attribute attsa :test 'string-equal))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is an unrecognized attribute"
   (third where-clause)))
       (return-from validate-where nil))
      (t
       (return-from validate-where t))))
       ((equal relb-name test-relation)
(cond ((null (member test-attribute attsb :test 'string-equal))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - ~s is an unrecognized attribute"
   (third where-clause)))
       (return-from validate-where nil))
      (t
       (return-from validate-where t))))
       (t
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is not a relation in the ~s database"
    (remove-dot-rel (third where-clause)) *active-db*))
(return-from validate-where nil)))))))

(defun pre-relation-ops (keyword-list
 &aux temp rela relb relc tuples1 attrsa wherea attrsb whereb attrsc var reader-package)
  ;;
  ;;1  Obtain the names of the relations which will be involved in the operation*
  ;;
  (if (and (setf temp (car (get-keyword-value '(from) keyword-list))) (not (listp temp)))
      (setf temp (list temp)))
  (setf rela (validate-sym (first temp)))
  (cond (rela
 (setf reader-package (package-name (symbol-package rela)))
 ;;
 ;;1  A project list and a where clause may be specified in the from clause. This allows the relation operation to be performed on*
 ;1; a subset of the each relation.*
 ;;
(if (and (listp (setf var (second temp))) (> (length var) 1))
    (setf wherea (car (get-keyword-value '(where) var))
  attrsa (convert-attributes (car (get-keyword-value '(project) var)))
  temp (append (list rela) (nthcdr 2 temp))))))
  (setf relb (validate-sym (second temp)))
  (cond (relb
 (setf reader-package (package-name (symbol-package relb)))
 (if (and (listp (setf var (third temp))) (> (length var) 1))
     (setf whereb (car (get-keyword-value '(where) var))
   attrsb (convert-attributes (car (get-keyword-value '(project) var)))))))
  ;;
  ;;1  The relations which will participate have been obtained, process the rest of the keywords.*
  ;;
  (setf relc (car (get-keyword-value '(into) keyword-list))
tuples1 (car (get-keyword-value '(tuples) keyword-list)))
  (if (and (listp relc) (listp (setf var (second relc))) (> (length var) 1))
      (setf attrsc (convert-attributes (car (get-keyword-value '(project) var)))))
  (setf relc (validate-sym (if (listp relc) (first relc) relc)))
  (values rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package))

(defun parse-from-clause (from-clause jrela jrelb join-attrc a-join-attrc unknown-attributes-user
  rela-attributes-user relb-attributes-user
  &aux period-index mystery-relation-name)
  (mapc (function (lambda (attr &aux temp1)
(cond ((listp attr)
       ;;
       ;;1  The attribute was specified in a list, this probably means that the user has supplied an new name for this attribute.*
       ;;1 Use the new attribute-name if it is provided, else the name remains the same*
       ;1;*
       (setf join-attrc (append join-attrc (if (cadr attr)
       (list (car attr))
       attr)))
       (setf a-join-attrc (append a-join-attrc (list (cadr attr))))
       (cond ((setf period-index (POSITION #\. (string (cadr attr))))
      ;;
      ;;1  Set the relation name if both have not already been found*
      ;;
      (setf temp1 (remove-dot-rel (cadr attr)))
      (if jrela
  (if (and (null jrelb)
   (null (string-equal (string-upcase jrela) (string-upcase temp1))))
      (setf jrelb (validate-sym temp1)))
  (setf jrela (string-upcase (remove-dot-rel (validate-sym (cadr attr) t))))))))
      ;;
      ;;1 The attribute name was not a list, process it*
      ;;
      (t
       (cond ((setf period-index (POSITION #\. (string attr)))
      ;;
      ;;1  Set the relation name if both have not already been found*
      ;;
      (setf temp1 (remove-dot-rel attr))
      (if jrela
  (if (and (null jrelb)
   (null (string-equal (string-upcase jrela) (string-upcase temp1))))
      (setf jrelb (validate-sym temp1)))
  (setf jrela (string-upcase (remove-dot-rel (validate-sym attr t)))))
      ;;
      ;;1  Add attribute to the attribute lists*
      ;;
      (setf join-attrc (append join-attrc (list attr)))
      (setf a-join-attrc (append a-join-attrc (list attr))))
     (t
      (setf join-attrc (append join-attrc (list attr)))
      (setf a-join-attrc (append a-join-attrc (list attr)))
      (setf unknown-attributes-user (append unknown-attributes-user (list attr)))))))
;;
;;1  Determine, if possible, which relation the user has said that this relation belongs.*
;;
  (if (listp attr)
      (setf attr (cadr attr)))
  (cond ((and period-index
      (not (string-equal (subseq (string attr) (+ period-index 1) (+ period-index 2)) "*")))
 (setf mystery-relation-name (read-from-string (subseq (string attr) 0 period-index)))
 (cond ((string-equal mystery-relation-name jrela)
(setf rela-attributes-user (append rela-attributes-user (list (remove-dot-attr attr)))))
       ((string-equal mystery-relation-name jrelb)
(setf relb-attributes-user (append relb-attributes-user (list (remove-dot-attr attr)))))
       (t
(setf unknown-attributes-user (append unknown-attributes-user
      (list (remove-dot-attr attr)))))))
(period-index)
(t
 (setf unknown-attributes-user (append unknown-attributes-user (list attr)))))))
from-clause)
  (values from-clause jrela jrelb join-attrc a-join-attrc unknown-attributes-user rela-attributes-user
  relb-attributes-user))

(defun parse-join-attributes (join-attrc a-join-attrc jrelb-project attrsa attrsb jrela jrelb
      &aux temp)
  (setf temp join-attrc
join-attrc nil)
  (mapc (function (lambda (attr)
     (cond ((and (or (symbolp attr) (stringp attr))
 (string-equal (string-upcase attr) (string-upcase (add-dot jrela "*"))))
    (setf join-attrc (append join-attrc attrsa)))
   ((and (or (symbolp attr) (stringp attr))
 (string-equal (string-upcase attr) (string-upcase (add-dot jrelb "*"))))
    (setf join-attrc (append join-attrc attrsb)))
   ;;
   1;; I am not sure if the following two clauses are necessary. But I think they are useful in situations like,*
   ;1; (rel1.* rel2.s4) where s4 is not an attribute of rel1 and we want the output relation to contain s4 not rel2.s4.*
   ;;
   ((and (POSITION #\. (string attr)) (string-equal jrela (remove-dot-rel attr)))
    (setf join-attrc (append join-attrc (list (string-upcase (remove-dot-attr attr))))))
   ((and (POSITION #\. (string attr)) (string-equal jrelb (remove-dot-rel attr)))
    (setf join-attrc (append join-attrc (list (string-upcase (remove-dot-attr attr))))))
   (t
    (setf join-attrc (append join-attrc (list attr)))))))
  temp)
  ;;
  ;;1  Form an attribute list for the final relation with the relation names appended to each attribute name. These will be the attribute*
  ;1; names as they orginally appeared in the join relations.*
  ;;
  (setf temp (convert-attributes a-join-attrc)
a-join-attrc nil
jrelb-project nil)
  (cond ((and (string-equal (string-upcase jrela) (string-upcase jrelb)) ;self join
      (equal temp (convert-attributes (list (add-dot jrela "*") (add-dot jrelb "*")))))
 (setf jrelb-project attrsa)))
  (mapc (function (lambda (attr)
    (cond ((equal attr (string-upcase (add-dot jrela "*")))
   (setf a-join-attrc (append a-join-attrc
      (mapcar (function (lambda (attr1)
  (string-upcase
    (add-dot jrela attr1))))
      attrsa))))
  ((equal attr (string-upcase (add-dot jrelb "*")))
   (setf a-join-attrc (append a-join-attrc
      (mapcar (function (lambda (attr2)
  (string-upcase
    (add-dot jrelb attr2))))
      attrsb)))
   (setf jrelb-project attrsb))
  (t
   (cond ((POSITION #\. (string attr) :test 'string-equal)
  (cond ((member (string-upcase (remove-dot-attr attr)) attrsb
 :test 'string-equal)
 (setf jrelb-project (append jrelb-project
     (list (string-upcase
     (remove-dot-attr attr)))))))
  (setf a-join-attrc (append a-join-attrc (list attr))))
 (t
  (cond ((and (member (string-upcase attr) attrsa :test 'string-equal)
      (null (member (add-dot jrela attr) a-join-attrc
    :test 'string-equal)))
 (setf a-join-attrc (append a-join-attrc
    (list (string-upcase
    (add-dot jrela attr))))))
(t
 (setf jrelb-project (append jrelb-project (list (string-upcase attr))))
 (setf a-join-attrc (append a-join-attrc
    (list (string-upcase
    (add-dot jrelb attr)))))))))))))
temp)
  (values join-attrc a-join-attrc jrelb-project))

(defun join-into (jrelc join-attrc a-join-attrc keyword-list jrelc-format impa ssa attr-imp
  &aux temp)
  (setf attr-imp (get-relation jrelc '("ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE" "KEY"
       "CARDINALITY" "TUPLE-FORMAT")
     nil))
  (if (null (cadr attr-imp))
      (progn

;;1Form the attribute descriptor pair. Consider one attribute at a time and get the descriptor values from the system-attribute*
;;1relation. Right now the resultant key is the list of all resultant attributes. In the following MAPCAR, a-attr is of the form rela.a1*
;1; and attr is the actual attribute in the output relation.*
(setf temp join-attrc
      join-attrc nil)
(mapc (function (lambda (a-attr attr &aux attd)
       (setf attd (car (qtrieve 'system-attribute *system-attribute-attributes*
'("DOMAIN-FUNCTION" "DEFAULT-VALUE" "DOC")
*system-attribute-key*
       (list 'and (list 'string-equal 'relation-name
(string (remove-dot-rel a-attr)))
     (list 'string-equal 'attribute-name
   (string (remove-dot-attr a-attr)))))))
       (setf join-attrc (append join-attrc
(list attr (list 'dom (first attd) 'def (second attd)
 'doc (third attd)))))))
a-join-attrc temp)
(cond ((null (defrel jrelc join-attrc
       (list 'imp (or (car (get-keyword-value '(imp) keyword-list)) impa)
     'sto (or (car (get-keyword-value '(sto) keyword-list)) ssa)
     'key (car (get-keyword-value '(key) keyword-list))
     'format (or (car (get-keyword-value '(format) keyword-list)) jrelc-format)
     'dir (car (get-keyword-value '(dir) keyword-list))
     'doc (or (car (get-keyword-value '(doc) keyword-list)) "..."))))
       (values nil attr-imp))
      (t
       (values jrelc attr-imp))))
    (values (setf jrelc (car attr-imp)) attr-imp)))

(defun join-eval (jrela jrelb attrsa attrsb jrelb-project jrelb-key where jrelb-storage-structure
  jrelb-implementation-type reader-package
  &aux key-value tupleb retrieve-function key-function tuples index-name attr1 attr2 num1 num2
  table table1 temp1 temp join-insert-list)
   (setf join-insert-list nil)
  (multiple-value-setq (index-name key-value jrelb-storage-structure jrelb-key)
    (extract-key jrelb attrsb jrelb-key nil jrelb-storage-structure where nil))
   (cond ((equal where t)
  (setf tupleb (funcall (find-symbol (concatenate 'string "RETRIEVE-" jrelb-implementation-type "-"
    jrelb-storage-structure) *pkg-string*)
(find-symbol (string-upcase jrelb))
attrsb jrelb-project jrelb-key where key-value
(find-symbol (string-upcase jrelb))))))
   (setf retrieve-function (find-symbol (concatenate 'string "RETRIEVE-" jrelb-implementation-type "-"
       jrelb-storage-structure) *pkg-string*)
 key-function (find-symbol (concatenate 'string "EXTRACT-KEY-" jrelb-storage-structure) *pkg-string*))
   (cond ((and (listp where)
       (equal (first where) 'equal)
       (or (and (member (setf attr1 (second where)) attrsa :test 'string-equal)
(member (setf attr2 (third where)) attrsb :test 'string-equal))
   (and (member (setf attr2 (second where)) attrsb :test 'string-equal)
(member (setf attr1 (third where)) attrsa :test 'string-equal))))
  (setf num1 (- (length attrsa) (length (member attr1 attrsa :test 'string-equal))))
  (setf num2 (- (length attrsb) (length (member attr2 attrsb :test 'string-equal))))
  (setf table (make-hash-table :test 'equal)
table1 (make-hash-table :test 'equal))
  (mapc #'(lambda (tuple &aux (key (nth num1 tuple)))
    (puthash key (cons tuple (gethash key table)) table))
(getp jrela 'entry-point))
  (mapc #'(lambda (tuple &aux (key (nth num2 tuple)) (temp nil))
    (cond ((setf temp1 (gethash key table))
   (mapc #'(lambda (temp-t)
     (setf temp (cons (append tuple temp-t) temp)))
 temp1)
   (puthash key (append temp (gethash key table1)) table1))))
(getp jrelb 'entry-point))
  (maphash #'(lambda (key tuple)
       key
       (setf join-insert-list (append tuple join-insert-list)))
   table1)
  (clrhash table)
  (clrhash table1))
 (t
  (mapt (function (lambda (tuplea)
    (cond ((equal where t)
   (setf tuples nil)
   (mapc (function (lambda (tuple)
     (setf tuples (cons (append tuplea tuple) tuples))))
 tupleb))
  (t
   (setf temp where)
   (cond ((equal temp '(t)) (setf temp t))
 (t
  (setf temp (process-where tuplea attrsa temp jrela jrelb attrsb))))
   (setf key-value (funcall key-function attrsb jrelb-key nil temp
    reader-package))
   (setf tuples nil)
1   ;;*
1   ;;  For now it projects all of the attributes from jrelB, it should only project those which are*
1   ;; needed*
1   ;;*
   (mapc (function (lambda (tupleb)
     (setf tuples (cons (append tuplea tupleb) tuples))))
 (funcall retrieve-function (find-symbol (string-upcase jrelb))
  attrsb jrelb-project jrelb-key temp key-value
  (find-symbol (string-upcase index-name))))))
    (if tuples
(setf join-insert-list (append tuples join-insert-list)))))
(read-from-string (string-upcase jrela)))))
   join-insert-list)

(defun validate-relation-ops (keyword-list operation
      &aux attrsa attrsb attrsc print1 reader-package rel-exists? rela relb relc tempa
      tuples1 wherea whereb)
  (block validate-relation-ops
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf print1 (member 'print keyword-list))
  (if print1
      (setf print1 (cadr print1)))
  (setf keyword-list (get-keyword-value-prereq '(into from format dir doc key imp sto print tuples unique)
       keyword-list))
  ;;
  ;;1  Return the attributes which are to participate in the difference operation as well as the selection critera for the tuples which will be*
  ;1; involved. The relation names and the attribute lists return-from validate-relation-ops stringified.*
  ;;
  (multiple-value-setq (rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package)
    (pre-relation-ops keyword-list))
  (if (and (null tuples1) (null relc) (null print1) (null (member 'print  keyword-list)))
      (setf print1 t))
  ;;
  ;;1  If two relations are not specified, generate an error message and exit*
  ;;
  (cond ((or (null rela) (null relb))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - Relations to participate in 2relational set operation* 2have *not 2been *provided."))
 (return-from validate-relation-ops nil)))
  ;;
  ;;1  Determine if the relations specified and the attributes specified are compatible for performing the difference operation*
  ;;
  (if (null (set-compatibility rela relb attrsa attrsb))
      (return-from validate-relation-ops nil))
  (cond (relc
 (setf tempa  (get-relation relc '(attributes) nil))
 (setf relc (car tempa))
 ;;
 ;;1  Relation C does not exist, create it.*
 ;;
 (cond ((null (setf rel-exists? (caadr tempa)))
(if (not (set-create-relc rela relc keyword-list attrsa
  (format nil "Relation 2~s *of ~S and ~S" operation rela relb)))
    (return-from validate-relation-ops nil)))
1       ;;*
1       ;;  Relation C already exists in the database, is it compatible with the other relations*
1       ;;*
       (t
(if (null (set-compatibility rela relc attrsa attrsc))
    (return-from validate-relation-ops nil))))))
  (values rela attrsa wherea relb attrsb whereb relc attrsc tuples1 reader-package print1)))
 destroyed.
  RENAME-ATTRIBUTES    - List of list of OLD-NEW attribute names.
  IMPLEMENTATION-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved.  (MODIFY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL RELATION-NAME ADD-ATTRIBUTES DELETE-ATTRIBUTES RENAME-ATTRIBUTES IMPLEMENTATION-TYPE STORAGE-STRUCTURE FORMAT KEY DOCUMENTATION DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB	BÁADD-ATTRIBUTESCDELETE-ATTRIBUTESCRENAME-ATTRIBUTESBBBBBBBBB	PAPPPQPQPQ	PQ
PQPQPQPQPQPQPQJ@AQ@QO	B
	1\B\B\B8\BLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540804. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "RELATION-OPS" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360567. :AUTHOR "REL3" :LENGTH-IN-BYTES 12012. :LENGTH-IN-BLOCKS 24. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8RELATION-OPS\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPÁJOIN-INTERNALQSQ@F$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\KEYWORD-LISTB:\!RELA-ATTRIBUTES-USERRELB-ATTRIBUTES-USERUNKNOWN-ATTRIBUTES-USERPRINTCALL-ATTRSFROM-CLAUSEÁJRELB-PROJECTJRELA-FORMATJRELB-FORMATJRELC-FORMATTEMPCJOIN-ATTRCJOIN-INSERT-LISTÀWHEREÀATTRSAÀATTRSBA-JOIN-ATTRCÁREADER-PACKAGEÀJRELAÀJRELBÀJRELCIMPASSAATTR-IMPCJRELB-IMPLEMENTATION-TYPEJRELB-STORAGE-STRUCTURECJRELB-KEYB`B:B:CATTRIBUTEB:B:\)MACROS-EXPANDED\pBTINHIBIT-STYLE-WARNINGSpZLC,DO-NAMEDFOURTHFIFTHSIXTHTHIRDSECONDFIRSTpBTlCOND-EVERYPROGSETF *DEFAULT-ANYP-WIDTH*у*PKG-STRING*C*PROVIDE-WARNING-MESSAGES**PROVIDE-ERROR-MESSAGES*ACTIVE-DATABASETERPRIҬERROR - No parameters passed to JOINWRITE-STRINGBe\INTOBoFROMIMPSTOKEYFORMATDIRDOCBeÀTUPLESPROJECTÀUNIQUEGET-KEYWORD-VALUE-PREREQ\BCGET-KEYWORD-VALUE\Bo\B\B\BLIST҃VALIDATE-SYMWARNING - More than two relations are provided for joining. The first two will be considered.ERROR - The relations to be joined are not provided.l*ADD-DOTҪPACKAGE-NAME҆CPARSE-FROM-CLAUSEGLOBALpB\STRING-EQUAL*ÀGLOBALERROR - The FROM clause has not specified the relations to be joined.\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATCARDINALITYGET-RELATIONlERROR - Relation PRIN1, does not existSTRING-UPCASEҪFIND-SYMBOLCCONVERT-ATTRIBUTESҪSTRING-EQUALpB\MEMBER-TEST,ERROR - l is not an attribute of relation , is not an attribute of either relation is an attribute of both relations:  and e.jWRITE-CHARҬ        It is unclear which attribute should be usedFÂPARSE-JOIN-ATTRIBUTESpB\,*APPEND*REVERSESTRINGl.CONCATENATE҃PROJECT-LISTFCJOIN-INTOCJOIN-EVALREMOVE-DOT-ATTR\BÁUNIQUE-TUPLES,INSERT-l-\B\BpBTSTRING-APPENDSYSTEM-RELATIONÁRELATION-NAMEB\lMODIFIEDPCARDINALITYDELETE-OR-MODIFY,SYSTEM-RELATION\lMODIFIEDP\BCPRINTREL-INTERNAL*҃JOINRQ[S[[S5[Q	
PRRKPSPQCCCWCPQPQBTPQBMPQBEPQTCPCPQBJJ5JQJJJSRR]\JJWSR]\JR]\JS]\JQ
	P]]\R
SE	PRSRQSERQPSQPERRQSSQCQEQRQSQKQPQBQ@QAQPPAA@BPKSREQRRQCSSQPQQQPQQ &PQRS
	!PRSRQSRQ"P#NN
	$PRQ%&PRSQ"P#OO
	$PSQ%&PRNWBBOWBByNQJOQNJQO@QJAQ@JQANSRNWNNWUN[VNUBGNSNOSSOWOOWXO[YOQBZOUBHOSOR	SRSQ'(S
SSQ'(SRQ'(R@Q)@AQ)ABQ)B@Q\\S^NQ*P+		,P^Q%-PRQ%R\AQ\\S^OQ*P+		,P^Q%-PSQ%R\BQ\6\S^NQ*P+^QOQ*P+
	,P^Q%.PR^QNQ*P+^QOQ*P+	,P^Q%/PRQ%0PSQ%1P2	3PR\KQPQFQNQOQRQSQ4P5PAFPK]]NQ`__QRQ`SC_``]Q``FQ]\\QSQ]SC\]]`Q6DJKQ7K^^S^U*P+	JQ8PSQ'9P^S':JQ^S'6J^JQ7KGQHQ6DQPQ;BITWTQKQPQQIQUQVQWQ<P=PAWTRRQSQNQOQFQZQMQYQXQQQ
J>LRQ'SQ'*DPQ^^S^U*P+DQ^S?DQ^S6D^DQPNQ``FQ]\\QSQ]SC\]]`Q6DLQDQPQ;L@PQLLQALTMLKBPW8PWQB'CPWUB8PDPQBUQ'CPEPQBVQ':FP(`TQKQLQWWWBKQTQ`GP*PHPTQI'JPWWWBBJLQCaKGP*PHPLPMPKPQLCDTTQLQKQWWWBBNPQBIQLQCJOTC&PPLQKQNPQBCKQCxNPQBPKQCC6NPQBLQCJOSTQROBPB`8F$B:BV]FB:B:B:BYFB^B\&RESTB`&KEYBBj&OPTIONALBBoBjDIRECTORYDOCUMENTATIONBIMPLEMENTATION-TYPEBCSTORAGE-STRUCTUREBeBBj&ALLOW-OTHER-KEYSB:\B`BBBoBBBBBBBBeBB\DOCUMENTATIONThis function provides the capability to combine two relations into a new relation
   in which the tuples which are to participate in the operation are selected
   by a where clause.

   FROM                 - A list consisting of the relations to be joined.
   PROJECT              - This clause specifies the attributes that are to be in the resultant relation
                          and their associated names in that new relation. It should be of the form
                          (<[relation-name.]attribute-name>). The optional part relation-name can be
                          skipped if the attribute is unique in one of the two relations being joined.
                          If the keyword FROM is not specified, this clause should contain the names
                          of the relations to be joined. Also, if * is given instead of the attribute-name
                          it indicates that RTMS should use all the attributes in that relation.
   WHERE                - Can be used to perform theta-joins. It is a condition used in joining the relations.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.\FROM)PROJECTWHEREINTOiDIRECTORYBFORMATIMPLEMENTATION-TYPEKEYiSTORAGE-STRUCTUREPRINTTUPLESUNIQUEpB\STORE-KEYARGSBP@@QPA@QOBÁPROCESS-WHEREUAFg$B:BV]FB:B:B:BYFB^B\ÀTUPLEABpCWHERE-EXPBtBuBqB:\CNEW-WHEREBlB:B:B:B:CX\B\pB\lXR-BQ-LISTBBBBjORBBB8BBpB\lPOSITION*BBBÁREMOVE-DOT-RELBEQUALpB\lMEMBER-EQLB֒5-BтUDCCQDS5>BCCDDBQPDSDDтUBEEQQQBSQQQCEBBDQ
C5QQQQQQB@@S&Q@@QQQD_DSFF7&PFQ	!FQ
QPFQQPFQ
QP	QCA@QFQ+*FQQPPFQQP	QCA@QAQFF7PFQ	FQ
QP
FQQ@QFQ
@QFQ@Dš@O2BPROCESS-SET-RELATION/q@FB$B:BV]FB:B:B:BYFB^B3\BBB:\CATTRIBUTESDOMAINSB:ATTB:B:ATTR\B\BBBBB*ACTIVE-DB*B\lATTRIBUTES,DOMAINSBBҬERROR - The BBl relation is not defined in the database BBB,ERROR -  is not an attribute in the relation BBђQP@@	P	Q
P	P
E@S@QBA@Q	B@;5QQBBSC@QPP	CQ
P	Q
PBBBсQEDDQESF@QCFQ@QPCcAQCCDEEBQAQ@Q@QAQOKB3CSET-COMPATIBILITY0pA0F@$B:BV]FB:B:B:BYFB^BL\RELARELBBpBqB:\ATTRIBUTESAATTRIBUTESBDOMAINSADOMAINSBB:B:B:B:ÀATTRAÀATTRBDOMADOMB\B\BBBFB3BlERROR - Relations BB and l do not have the same number of attributes, thus they are not compatible.lERROR - Attribute  of relation , and attribute  are not compatible domainsQQPPAB@RQQPPACAR@QCAQC|PQ	
PQ	PR@QAQBQCQGFED&DSESFSGSKJIHJQK+PHQ	PQ	PIQ	PQ	PRDEFGDEFGSOjBLSET-CREATE-RELCB@F`$B:BV]FB:B:B:BYFB^Bk\BURELCB`BpBB:\ATTRIBUTE-DESCRIPTORB=BDOMBBMODPQTRIEVE-VARCSSTUPLE-FORMATB:B:B:B@BwB=\B\	BBBBBBBBBÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*B\	lMODIFIEDPSAVE-DIRECTORYlATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATDOC,DOMAINSBBBBQTRIEVE\BB\B\B\B\B\BBBwBBBBBBBÀDEFRELPPPPP	PQ
BGGSFPQBGWBG[APQBGQBDPQBGUBHPQBQPQBEPQBJGQCIJGQCC!5QJуQLKKQLSMAQCMQAQPCcCQCCKLLJQCQACQNAQO@QOSPNS@NOQ@QPDQPHQPEQPIQPQPBQJOBkRELATION-DIFFERENCE#\ۆ#F$B:BV]FB:B:B:BYFB^B\BB`BBBBBBBBBBBeBBBB:\B`BBBBBBBBBeBBÀTEMPATEMP-TUPLESBlÀTABLEBUBVBtÀPRINT1TUPLES1BpÀWHEREABqÀWHEREBÀATTRSCBsB:ÀTUPLEB:B"\B\BBBB#Difference of the tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the DIFFERENCE operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.*VALIDITY-CHECKING*\B
BBBBBBBBBBBACTIVE-DATABASEPlDIFFERENCEÂVALIDATE-RELATION-OPSҩTESTB/*MAKE-HASH-TABLEBBBBB\BBBoRETRIEVE*GETHASHpBT,PUTHASHB=ÀINSERT*CLRHASH\lATTRIBUTESTUPLE-FORMATB҃UNCONVERT-ATTRIBUTESBCDIFFERENCE\BBے@@QPAR@QP	P
PASZTYRXWQVUPRPPOQQPWQPPP@QBPXQ	JN[[S\\Q\QOQ
COQ[PQPPUQPP@QBPVQ	J]
]S^OQ^QM]M]MRPLRQPMQPYQLQOQTMSCRRQPBLRQMQYQLSZQLWMQCJRS&PQPBL PMQUQLSZQ!P@QB	ULULSUQ"BLWMQCJSRQPOBÂRELATION-INTERSECTION#YՆ#F|$B:BV]FB:B:B:BYFB^B\BB`BBBBBBBBBBBeBBBB:\B`BBBBBBBBBeBBBÀTEMPBBlBBUBVBtBBBpBBqBBBsB:BB:ÀTUPLEB\B\BBBB#Intersection of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the INTERSECTION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.B\B
BBBBBBBBBBBBlDIFFERENCEBBBBoBBB/BBBBBB\BBB=BB\lATTRIBUTESTUPLE-FORMATBBBҪINTERSECTION\BBے@@QPAR@QP	P
PATZSYRXWQVUPRPQPPUQPVQJNPPONQ[[S\\Q\QOQ
COQ[QQPPP@QBPXQPWQ	J]
]S^OQ^QM]M]MRPLRQPMQPYQLQOQSMTCRRQPBLRQMQYQLSZQLWMQCJRT&PQPBL PMQUQLSZQ!P@QB	ULULSUQ"BLWMQCJSRQPOBÁRELATION-UNION$Z؆$F~$B:BV]FB:B:B:BYFB^B\BB`BBBBBBBBBBBeBBBB:\B`BBBBBBBBBeBBBBUBVBtBBBBlCTEMP-UNIONBpBBqBBBsB:BB:\B\BBBBUnion of tuples in two relations.

   FROM                 - This clause specifies the relations to participate in the UNION operation.
                          In addition, RTMS allows users to specify the attributes in these relations to
                          participate in the operation as well as a where-clause to specify the tuples.
                          It should be of the format: (RelA [(PROJECT <attrA> WHERE where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   PRINT                - If NIL, the resultant relation will not be printed out.
   TUPLES               - If T, the resultant tuples will be returned.
   UNIQUE               - If T, only unique tuples will be part of the resultant relation.B\B
BBBBBBBBBBBBlDIFFERENCEBBB/BBBB\BBBBoBBBBB=BBB\lATTRIBUTESTUPLE-FORMATBUNIONB\BBB@@QPAR@QP	P
PARZQYOXWNVUMRPPPMQPP@QBPUQPVQP	JS[[S\\Q\QPQ
CPQ[OOQPSQPYQTNQPPP@QBPWQPXQ	J]
]S\PQ\QT]T]TOPLOQPTQPYQLQPQQSQTQR5OOQPYQOR*MQPBLPSQTQUQLSZQ !P@QB	ULULSUQ"BLWSQTQCJ#SOQMOBÁVALIDATE-WHERE_ІAHFq$B:BV]FB:B:B:BYFB^B\WHERE-CLAUSECRELA-NAMECRELB-NAMEÀATTSAÀATTSBB:\ÁTEST-ATTRIBUTEÁTEST-RELATION\B\BBBBBCBB,ERROR - BBl improperly formed where subclauseB.BBB is an unrecognized attribute,ERROR -l is not a relation in the l databaseSQSQJ	S5W5[5
PQ	PRW
AW@A@QQPA@QQP<P@QPRQA+@QQP*PWPRQA+@QQPPWPRPAQPPPR[
A[@A@QQP@QQP	P@QPRQA+@QQP
P[PRSQA+@QQP
P[PRSP[
PPPROBPRE-RELATION-OPS9@pFF$B:BV]FB:B:B:BYFB^B\B`B:\BlBUBVBtBBpBBqBBVARBs\B\BBBB\BBBBB\Bo\BB\B\BPQB@@5@Q@@SAAQCK@WJ5JQJPJQBF	PJQB
EAQ@Y
C@@WBBQCK@[J5JQJPJQBH	PJQB
GPQBCPQBDC5CWJ5
JQJ	PJQB
IC5CSCQCAQEQFQBQGQHQCQIQDQKQO BBXBFh$B:BV]FB:B:B:BYFB^B\BgBtBuBmBrBdBbBcB:\PERIOD-INDEXÂMYSTERY-RELATION-NAMEB:B@ÀTEMP1\B\BBBBBBpBlSTRING-SEARCH-CHARB.BBBBSUBSEQl**READ-FROM-STRINGBߒQBBSCDC5.QCCSCQQCWPCWJ@QCWDJQDQ	DDQ
@CW
9PCQJ@"CQDQDQ	
DQ
CQ
QCQQCQQCQQCQQCQC5CWC@+CQ@kJ@aP	 CQJ@QAÁQ	QCQAQQ	QCQQCQ@QCQB\QQQQQQQQO4BBoAF$B:BV]FB:B:B:BYFB^B\BmBrBhBpBqBtBuB:\
BlB:B@B:B:B:B:ÀATTR1B:ÀATTR2\B\BBBBBl*BBBB0B.BBBBBBB-BʒQ@@QACASBB7BQQPQQ/BB7BQQPQQ PBQJQBQ	PBQJ
QBQ	QBQ
QBQAŽQ@ۂۅQQ@QQPQPrQ@QCvCSBÅQPrQDDуQFEEQFSGQGQCEFFDQTBQQPrQFFфQDHHQDSIQIQCHDDFQQ5PBQPBQ
QPQBQ
QBQBQQP
QBQQPQQQBQQQBQCŊQQQOCBB$8B$F\$B:BV]FB:B:B:BYFB^B\BvBmBrB`BkBwBxByB:\BlB:B:ÀA-ATTRB@ATTD\B\BBBBBBÂ*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYCARDINALITYTUPLE-FORMATBSYSTEM-ATTRIBUTE\,DOMAIN-FUNCTIONDEFAULT-VALUEDOCANDBBB.BBÁATTRIBUTE-NAMEBBBwpBTDEFBBB\BBB\BB\BB\BB\B\B...BQPeQ@ۂQ@QBA)ASBSDCEPPPP	P
PPCQ
PPCQBEQDQPESPEWPE[ABABQQPPQBQPPQBQPPQBPPQBQP PQBP!PQB"PJ#QQSÇQOjBB^ۆF}$B:BV]FB:B:B:BYFB^B\
BtBuBpBqBhB|BoB{BzBsB:\B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGCKEY-VALUEBCRETRIEVE-FUNCTIONKEY-FUNCTIONBCINDEX-NAMEB>B?NUM1NUM2BÀTABLE1B,BlBnB:B:BBBlB:ÀTEMP-T\B\BBBBBBINTERNAL-FEF-OFFSETS\FFiVARIABLES-USED-IN-LEXICAL-CLOSURES\BnBlBBB~B}BB|BsBoB|BhBqBpBuBtEBEXTRACT-KEYBlRETRIEVE-l-BBBҬEXTRACT-KEY-B/BBBB҃ENTRY-POINTGETPBBB\FFFFF
F	FFF\)INTERNALB*MAPHASHB\BBFB3҃MAPTQQQۇQQPPAFKQPPQ	PQ
PUQQQQQFQQJUGPPQ	PQ
PHPPQ
PI5zS&wWLÂQP[MÃQPWMÃQPe[LÂQP_QCLQQPCcNQCMQQPCcOPPPPPQQPVVSWNQWQCXWQXQPQ
CPQVQPU"USWOQWQCXYXQPQRRQZ	ZS[WQ[QY]YZXQYQXQQQQQUPPCQQPQQQTPPCQTOBB
@F$B:BV]FB:B:B:BYFB^B\BBB:\B:B:Bu\B\BiLEXICAL-PARENT-DEBUG-INFOBpB֒QPOBB%R@\F-$B:BV]FB:B:B:BYFB^B\B"B:\B:B:BuB:BB:B\B\BBBBBpB\BYBBBƒPPC:CSDQDQ\C0P*QPPPPPPPPPĪPEPPPPPPPJźE	ESFQFQ\EPPROBB5|@FG$B:BV]FB:B:B:BYFB^B\B`COPERATIONB:\BpBqBBBsREL-EXISTS?BUBVBtBBBBB`\B\BBBBe\BBBBBBBBBeBBB҆BBҬERROR - Relations to participate in relational set operation have not been provided.BBL\B=B,Relation ~s of ~S and ~SBBkQMSMMS5MQPQCCCWCPQPPADJBHLAGK@FJHCPCFG	
PRFQGQ@QAQRHHQPIISHIQ	BEFQHQQ@QPQFQGQRFQHQ@QBQRFQ@QKQGQAQLQHQBQJQDQCQOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\B*.ً\B[\B=#\B
9\Bz(\B{\B:}n\B{Ĳ\BZi\Bx\B*j\B(̢ where-clause-A)] RelB
                          [(PROJECT <attrB> WHERE where-clause-B)]) where attrA indicates attributes in
                          relation relA and where-clause-A indicates a where-clause involving the attributes
                          in relation relA.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relatLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540807. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "RENAME" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846753. :AUTHOR "REL3" :LENGTH-IN-BYTES 20066. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; RENAME*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     copy-array-contents*
;1;;     deff*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     rename-attribute-flavor*
;1;;     rename-relation-flavor*
;1;;*

(deff rename-attr 'rename-attribute)

(defun rename-attribute (relation-name &rest attributes
 &aux relation-tuple pos pos-k sto rel-owner-id attribute-list key-list imp)
  "Use this function to rename attributes in a relation.

   RELATION-NAME  - Name of the relation whose attributes are to be renamed.
   ATTRIBUTES     - Specify old-attribute and new-attribute names.

   Example: (RENAME-ATTRIBUTE 'parts 'number 'id 'name 'description)."
    (block rename-attribute
  (if (not (active-database))
      (return-from rename-attribute nil))
  (if (null (setf relation-name (validate-sym relation-name t)))
 (return-from rename-attribute nil))
  (setf attributes  (do ((attr-l attributes (car attr-l)))
((not (listp (car attr-l))) attr-l) ()))
  (setf attributes (convert-attributes attributes))
  (cond ((member relation-name *system-relations*  :test 'string-equal)
 (if *provide-error-messages*
     (format *standard-output*
 "~%ERROR - The attributes cannot be renamed because ~s is a system relation." relation-name))
 (return-from rename-attribute nil)))
  (setf relation-tuple (cadr (get-relation relation-name '("OWNER-ID" "SAVE-DIRECTORY" "ATTRIBUTES" "KEY"
   "TUPLE-FORMAT" "IMPLEMENTATION-TYPE"
   "STORAGE-STRUCTURE" "DOC")
  nil)))
  (cond ((not relation-tuple)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
      relation-name *active-db*))
 (return-from rename-attribute nil)))
  (setf rel-owner-id (first relation-tuple)
attribute-list (third relation-tuple)
key-list (fourth relation-tuple)
imp (sixth relation-tuple)
sto (seventh relation-tuple))
  (if (not
   (do ((attribute-name (first attributes) (first attributes))
(new-attribute-name (second attributes) (second attributes))
(attributes (cddr attributes) (cddr attributes)))
       ((null new-attribute-name) (return-from rename-attribute t))
     (if (null (setf attribute-name (validate-sym attribute-name t)))
 (return-from rename-attribute nil))
     (cond ((null (setf pos (position attribute-name attribute-list :test 'equal)))
    (if *provide-error-messages*
(format *standard-output* "~%ERROR - The attribute ~S is not defined in ~S."
attribute-name relation-name))
    (return-from rename-attribute nil))
   ((member new-attribute-name attribute-list  :test 'string-equal)
    (if *provide-error-messages*
(format *standard-output* "~%ERROR - The attribute ~S is already defined in the relation ~S."
new-attribute-name relation-name))
    (return-from rename-attribute nil))
   (t
    ;;1 define the new attribute-list of the relation*
    (setf attribute-list (append (firstn pos attribute-list) (cons new-attribute-name
   (nthcdr (1+ pos) attribute-list))))
    ;;1 if the attribute is part of the key, rename it there too*
    (cond ((setf pos-k (position attribute-name key-list :test 'equal))
   (setf key-list (append (firstn pos-k key-list) (cons new-attribute-name
(nthcdr (1+ pos-k) key-list))))))))
1      *(if *provide-status-messages*
(format *standard-output* "~%The attribute ~S will be renamed to ~S."
attribute-name new-attribute-name))))
      (return-from rename-attribute nil))
  (funcall (find-symbol (concatenate 'string "RENAME-ATTRIBUTE-" imp) *pkg-string*) relation-name
   attribute-list key-list attributes relation-tuple)
  (if *provide-status-messages*
      (format *standard-output* "~%Renaming attributes completed."))
  (return-from rename-attribute relation-name)))

(defun rename-attribute-array  (relation-name attribute-list key-list attributes ignore )
  (rename-attribute-utility-array-list relation-name attribute-list key-list attributes))

(defun rename-attribute-flavor (relation-name attribute-list key-list ignore relation-tuple)
  (rename-attribute-utility-redef-rel relation-name attribute-list key-list relation-tuple))

(defun rename-attribute-list (relation-name attribute-list key-list attributes ignore )
  (rename-attribute-utility-array-list relation-name attribute-list key-list attributes))

(defun rename-attribute-struct (relation-name attribute-list key-list ignore relation-tuple)
  (rename-attribute-utility-redef-rel relation-name attribute-list key-list relation-tuple))

(defun rename-attribute-utility-array-list (relation-name attribute-list key-list attributes)
  (delete-or-modify 'system-relation t (list 'string-equal 'relation-name (string relation-name))
    '("MODIFIEDP" "ATTRIBUTES" "KEY") (list 't `(quote ,attribute-list) `(quote ,key-list)))
  (do ((attribute-name (first attributes) (first attributes))
       (new-attribute-name (second attributes) (second attributes))
       (attributes (cddr attributes) (cddr attributes)))
      ((null new-attribute-name) (return t))
    (delete-or-modify 'system-attribute t (list 'and (list 'string-equal 'relation-name (string relation-name))
(list 'string-equal 'attribute-name (string attribute-name)))
      '("ATTRIBUTE-NAME") (list `(string (quote ,new-attribute-name)))))
  (save-system-relations))

(defun rename-attribute-utility-redef-rel (relation-name attribute-list key-list relation-tuple
   &aux system-attribute-list attr-des-pair tuple-list imp ss
   tuple-format-list doc dir)
  (setf system-attribute-list (get-system-attribute-list relation-name))
  (setf imp (sixth relation-tuple)
ss (seventh relation-tuple)
tuple-format-list (fifth relation-tuple)
doc (nth 7 relation-tuple)
dir (second relation-tuple))
  (setf attr-des-pair (create-attr-descriptor attribute-list system-attribute-list))
  (setf tuple-list (retrieve (read-from-string (string-upcase relation-name)) 'tuples t))
  (redefine-rel (read-from-string (string-upcase relation-name)) attr-des-pair imp ss key-list
tuple-format-list doc dir tuple-list)
  (save-system-relations)
  (save-relation (read-from-string (string-upcase relation-name))))

(deff rename-db 'rename-database)

(defun rename-database (&rest databases
&aux database-name new-database-name pathname path rel-name save-dir
relation-tuple-list)
  "Used to rename a database.

   DATABASES - Specify old-database-name and new-database-name.

   Example: (RENAME-DATABASE parts suppliers micro-parts micro-suppliers)."
    (block rename-database
  (if (not (active-database))
      (return-from rename-database nil))
  (setf databases (do ((db-l databases (car db-l)))
      ((not (listp (car db-l))) db-l) ()))
  (setf database-name (validate-sym (first databases) t))
  (setf new-database-name (validate-sym (second databases) t))
  (if (or (null database-name) (null new-database-name))
      (return-from rename-database nil))
  (cond ((not (string-equal database-name *active-db*))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The database to rename has to be the active database ~S."
       *active-db*))
 (return-from rename-database nil)))
  (cond ((string-equal new-database-name database-name)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The new database name ~S is identical to the actual name"
       new-database-name))
 (return-from rename-database nil)))
  (setf *active-db* new-database-name)
  (setf relation-tuple-list
(funcall (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation* "-"
     *system-relation-storage-structure*) *pkg-string*)
 'system-relation *system-relation-attributes* '("RELATION-NAME" "SAVE-DIRECTORY")
 *system-relation-key* t nil 'system-relation))
  ;;
  ;;1 if the database has been saved before,the file database-name.LISP exists In that case, the files need to be renamed.*
  ;1;*
  (setf save-dir (get-save-directory))
  (cond ((setf path (or (probe-file (concatenate 'string save-dir database-name ".XLD"))
(probe-file (concatenate 'string save-dir database-name ".LISP"))
(probe-file (concatenate 'string save-dir database-name ".XFASL"))
(probe-file (concatenate 'string save-dir database-name ".QFASL"))))
 ;; 1the system relations have to be saved, even if there are not modified, because the database name and thus the file name*
 ;1; are changed. so, to be sure that save-relation will save them, modifiedp has to be true*
 ;1;*
 (delete-or-modify 'system-relation t '(member relation-name *system-relations*  :test 'string-equal)
   '("MODIFIEDP") (list 't ))
 (save-system-relations)
 (delete-file path);1because it is a rename and not a copy !*
 ;;1 go through all the relation files of the database. the old system relation files are deleted because it is a rename and not a*
 ;1; copy the user relation files are renamed*
 ;1;*
 (mapcar (function (lambda (rel-tuple)
     (setf rel-name (first rel-tuple)
   save-dir (second rel-tuple))
     (setf pathname (concatenate 'string save-dir database-name "-" rel-name "."))
     (setf path nil)
     (cond ((setf path (probe-file (concatenate 'string pathname "XLD")))
    (cond ((not (member rel-name *system-relations* :test 'string-equal))
   (rename-file path (concatenate 'string save-dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatenate 'string pathname "XLD")))))
   ((setf path (probe-file (concatenate 'string pathname "QFASL")))
    (cond ((not (member rel-name *system-relations* :test 'string-equal))
   (rename-file path (concatenate 'string save-dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatenate 'string pathname "QFASL")))))
   ((setf path (probe-file (concatenate 'string pathname "XFASL")))
    (cond ((not (member rel-name *system-relations* :test 'string-equal))
   (rename-file path (concatenate 'string save-dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatenate 'string pathname "XFASL")))))
   ((setf path (probe-file (concatenate 'string pathname "LISP")))
    (cond ((not (member rel-name *system-relations* :test 'string-equal))
   (rename-file path (concatenate 'string save-dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatenate 'string pathname "LISP"))))))))
 relation-tuple-list))
(t (save-database *active-db*)))
  (cond (*provide-status-messages*
 (format *standard-output* "~%The database ~S has been renamed to ~S." database-name new-database-name)
 (format *standard-output* "~%Renaming database completed.")))
  (return-from rename-database new-database-name)))

(deff rename-rel 'rename-relation)

(defun rename-relation (&rest relations
&aux last-new-relation-name posrelation-tuple rel-owner-id imp pathname path save-dir
(result nil) db-relations-list relation-tuple-list (call-save-db nil))
  "Rename relations in the active database.

   RELATIONS - Specify <old-rel-name new-rel-name>

   Example: (RENAME-RELATION rel1 new-rel1 rel2 new-rel2)"
  (block rename-relation
(if (not (active-database))
    (return-from rename-relation nil))
(setf relations (do ((rel-l relations (car rel-l)))
    ((or (not (listp (car rel-l))) (> (length rel-l) 1)) rel-l) ()))
(setf relation-tuple-list
      (funcall (find-symbol (concatenate 'string "RETRIEVE-" *system-relation-base-implementation* "-"
   *system-relation-storage-structure*) *pkg-string*)
       'system-relation *system-relation-attributes* '("RELATION-NAME" "OWNER-ID")
       *system-relation-key* t nil 'system-relation))
;;
;;1 Take the system relations away from the list relation-tuple-list, because the user is not allowed to rename the system relations.*
(setf db-relations-list (do ((rel-l relation-tuple-list (cdr rel-l)))
    ((null rel-l) (reverse result))
  (if (not (member (caar rel-l) *system-relations* :test 'string-equal))
      (setf result (cons (caar rel-l) result)))))
(if (not (do ((relation-name (first relations) (first relations))
      (new-relation-name (second relations)(second relations))
      (relations (cddr relations)(cddr relations)))
     ((null new-relation-name)(return t))
   (setf relation-name (validate-sym relation-name))
   (setf new-relation-name (validate-sym new-relation-name))
   (if (or (null relation-name) (null new-relation-name))
       (return-from rename-relation nil))
   (cond ((null (setf pos (position (string-upcase relation-name) db-relations-list
    :test 'equal)))
  (if *provide-error-messages*
      (if (member (string-upcase relation-name) *system-relations* :test 'string-equal)
  (format *standard-output*
  "~%ERROR - The relation ~S cannot be renamed because it is a system relation."
  relation-name)
  (format *standard-output*
  "~%ERROR - The relation ~S is not defined in the database ~S."
  relation-name *active-db*)))
  (return-from rename-relation nil))
 ((or (member (string-upcase new-relation-name) db-relations-list :test 'string-equal)
      (member (string-upcase new-relation-name) *system-relations* :test 'string-equal))
  (if *provide-error-messages*
      (format *standard-output*
      "~%ERROR - The relation ~S is already defined in the database ~S."
      new-relation-name *active-db*))
  (return-from rename-relation nil))
 (t
  (setf db-relations-list (append (firstn pos db-relations-list)
  (cons (string-upcase new-relation-name)
(nthcdr (1+ pos) db-relations-list))))))))
    (return-from rename-relation nil))
(if (not (do ((relation-name (validate-sym (first relations)) (first relations))
      (new-relation-name (validate-sym (second relations)) (second relations))
      (relations (cddr relations)(cddr relations)))
     ((null new-relation-name)(return-from rename-relation t))
   (setf relation-tuple (cadr (get-relation relation-name '("OWNER-ID" "SAVE-DIRECTORY"
    "ATTRIBUTES" "KEY" "TUPLE-FORMAT"
    "IMPLEMENTATION-TYPE"
    "STORAGE-STRUCTURE" "DOC")
     nil)))
   (setf rel-owner-id (first relation-tuple)
 imp (sixth relation-tuple))
   (funcall (find-symbol (concatenate 'string "RENAME-RELATION-" imp) *pkg-string*)
    relation-name new-relation-name relation-tuple)
   (setf save-dir (second relation-tuple))
   (setf pathname  (concatenate 'string save-dir *active-db* "-"
(string relation-name) "."))
   (setf path nil)
   (cond ((setf path (probe-file (concatenate 'string pathname "XLD")))
  (rename-file path (concatenate 'string save-dir *active-db* "-"
 (string-upcase new-relation-name) "." "XLD#>")))
 ((setf path (probe-file (concatenate 'string pathname "XFASL")))
  (rename-file path (concatenate 'string save-dir *active-db* "-"
 (string-upcase new-relation-name) "." "XLD#>")))
 ((setf path (probe-file (concatenate 'string pathname "QFASL")))
  (rename-file path (concatenate 'string save-dir *active-db* "-"
 (string-upcase new-relation-name) "." "XLD#>")))
 ((setf path (probe-file (concatenate 'string pathname "LISP")))
  (rename-file path (concatenate 'string save-dir *active-db* "-"
 (string-upcase new-relation-name) "." "XLD#>")))
 (t
  (setf call-save-db t)))
   (cond (path
  (save-system-relations)))
   (if *provide-status-messages*
       (format *standard-output* "~%The relation ~S has been renamed to ~S."
       relation-name new-relation-name))
   (setf last-new-relation-name new-relation-name)))
    (return-from rename-relation nil))
(if (and *auto-save* call-save-db)
    (save-database *active-db*))
(if *provide-status-messages*
    (format *standard-output* "~%Renaming relations completed."))
(return-from rename-relation last-new-relation-name)))


(defun rename-relation-array (relation-name new-relation-name ignore
      &aux array-name new-array-name)
  (multiple-value-setq (array-name)
    (intern (read-from-string (concatenate 'string relation-name "ARRAY"))))
  (multiple-value-setq (new-array-name)
    (intern (read-from-string (concatenate 'string new-relation-name "ARRAY"))))
  (eval `(copy-array-contents ,array-name ,new-array-name))
  (rename-relation-utility-array-list relation-name new-relation-name))

(defun rename-relation-flavor (relation-name new-relation-name relation-tuple)
  (rename-relation-utility-redef-rel relation-name new-relation-name relation-tuple))

(defun rename-relation-list (relation-name new-relation-name ignore)
  (rename-relation-utility-array-list relation-name new-relation-name))

(defun rename-relation-struct (relation-name new-relation-name relation-tuple)
  (rename-relation-utility-redef-rel relation-name new-relation-name relation-tuple))

(defun rename-relation-utility-array-list (relation-name new-relation-name)
    (delete-or-modify 'system-relation t  (list 'string-equal 'relation-name (string-upcase relation-name))
       '("MODIFIEDP" "RELATION-NAME")
       (list 't (eval `(string-upcase (quote ,new-relation-name)))))
     (delete-or-modify 'system-attribute t (list 'string-equal 'relation-name (string-upcase relation-name))
       '("RELATION-NAME") (list (eval `(string-upcase (quote ,new-relation-name)))))
     (delete-or-modify 'system-index t (list 'string-equal 'relation-name (string-upcase relation-name))
       '("RELATION-NAME") (list (eval `(string-upcase (quote ,new-relation-name)))))
     (putp new-relation-name (getp relation-name 'entry-point) 'entry-point)
     (putp relation-name nil 'entry-point))

(defun rename-relation-utility-redef-rel (relation-name new-relation-name relation-tuple
  &aux system-attribute-list attr-des-pair tuple-list index-list
  imp ss tuple-format-list attribute-list key-list doc dir domains)
  (setf system-attribute-list (get-system-attribute-list relation-name))
  (setf imp (sixth relation-tuple)
ss (seventh relation-tuple)
tuple-format-list (fifth relation-tuple)
attribute-list (third relation-tuple)
key-list (fourth relation-tuple)
doc (nth 7 relation-tuple)
dir (second relation-tuple))
  (setf attr-des-pair (create-attr-descriptor attribute-list system-attribute-list))
  (setf tuple-list (retrieve relation-name 'tuples t))
  (define-relation new-relation-name attr-des-pair
    'imp imp 'modifiedp t 'sto ss 'key key-list'format tuple-format-list 'doc doc 'dir dir)
  (delete-or-modify 'system-index t (list 'string-equal 'relation-name (string relation-name))
2     *'("RELATION-NAME") (list (eval `(string-upcase (quote ,new-relation-name)))))
  (setf index-list (qtrieve 'system-index *system-index-attributes* '("INDEX-NAME2"* "INDEX-TYPE2"* "KEY2"*)
    *system-index-key*
    (list 'string-equal 'relation-name (string-upcase new-relation-name))))
  (cond (index-list
 (setf domains (caar (qtrieve 'system-relation *system-relation-attributes* '("2DOMAINS"*)
      *system-relation-key*
      (list 'string-equal 'relation-name (string-upcase new-relation-name)))))))
  (mapc (function (lambda (index-info)
    (funcall (find-symbol (concatenate 'string "2DELETE-"* imp "2-"* (second index-info))
  *pkg-string*)
     new-relation-name attribute-list (third index-info) nil t (first index-info))))
index-list)
  (if tuple-list
      (insert new-relation-name (list 'tuples tuple-list)))
  (destroy-relation relation-name))
	PBQJ
QBQ	QBQ
QBQAŽQ@ۂۅQQ@QQPQPrQ@QCvCSBÅQPrQDDуQFEEQFSGQGQCEFFDQTBQQPrQFFфQDHHQDSIQIQCHDDFQQ5PBQPBQ
QPQBQ
QBQBQQP
QBQQPQQQBQQQBQCŊQQQOCBB$8B$F\$B:BV]FBLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540810. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "RENAME" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360779. :AUTHOR "REL3" :LENGTH-IN-BYTES 4902. :LENGTH-IN-BLOCKS 10. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pp2\COMPILE-DATA\SW-MFG,GODZILLA\FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8RENAME\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPRENAME-ATTRIBUTEOPRENAME-ATTRBP!TɆ`!xFu$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAME&RESTCATTRIBUTESB:\BcÁRELATION-TUPLEPOSÀPOS-KSTOREL-OWNER-IDÁATTRIBUTE-LISTKEY-LISTIMPÀATTR-LÁATTRIBUTE-NAMECNEW-ATTRIBUTE-NAMEBcB:\)MACROS-EXPANDED\SECOND*SEVENTHSIXTHFOURTHTHIRDFIRSTPROGSETFDOCUMENTATIONUse this function to rename attributes in a relation.

   RELATION-NAME  - Name of the relation whose attributes are to be renamed.
   ATTRIBUTES     - Specify old-attribute and new-attribute names.

   Example: (RENAME-ATTRIBUTE 'parts 'number 'id 'name 'description).*PKG-STRING*C*PROVIDE-STATUS-MESSAGES*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*C*SYSTEM-RELATIONS*ACTIVE-DATABASE҃VALIDATE-SYMCCONVERT-ATTRIBUTESҪSTRING-EQUALpB]MEMBER-TESTTERPRIlERROR - The attributes cannot be renamed because WRITE-STRINGPRIN1 is a system relation.\,OWNER-IDSAVE-DIRECTORYlATTRIBUTESKEYTUPLE-FORMATIMPLEMENTATION-TYPElSTORAGE-STRUCTUREDOCGET-RELATIONERROR - The relation , is not defined in the database EQUALpB]lPOSITION*ERROR - The attribute  is not defined in e.jWRITE-CHARҬ is already defined in the relation pBUFIRSTNpB],*APPENDThe attribute  will be renamed to RQ	R@QISIIS5IQ@
@QPP
PQPRQPBA	PQPPRASEA[FAQBGAYBHAQBBD@S@W@YLKJYJQ	JRJQFQPBPJQPQPRKQFQPPKQPQPRBQFQKQBkFQ
C
CFJQGQPC
CQGQKQCkGQ
C
CGPJQ PKQPLSJLWKLKSOBPÂRENAME-ATTRIBUTE-ARRAY
@F$B:BW]FB:B:B:BZFB_B\BaBjBkBcIGNOREB:B:B:RENAME-ATTRIBUTE-UTILITY-ARRAY-LISTQQQQOBRENAME-ATTRIBUTE-FLAVOR
@F$B:BW]FB:B:B:BZFB_B\BaBjBkBBeB:B:B:CRENAME-ATTRIBUTE-UTILITY-REDEF-RELQQQQOBÂRENAME-ATTRIBUTE-LIST
@F$B:BW]FB:B:B:BZFB_B\BaBjBkBcBB:B:B:BQQQQOBRENAME-ATTRIBUTE-STRUCT
@F$B:BW]FB:B:B:BZFB_B\BaBjBkBBeB:B:B:BQQQQOBBGAF,$B:BW]FB:B:B:BZFB_B\BaBjBkBcB:\BnBoBc\Bq\BsBxBypB]lXR-BQ-LISTSYSTEM-RELATIONBBaSTRINGҪLIST\lMODIFIEDPlATTRIBUTESKEYB8DELETE-OR-MODIFYSYSTEM-ATTRIBUTEANDBn\ATTRIBUTE-NAMEBÂSAVE-SYSTEM-RELATIONSPPPQP	PQ	PQ
SWYBA@PPPPQPP@QPP	PAQ
BS@BWABAOBB<A F$$B:BW]FB:B:B:BZFB_B\BaBjBkBeB:\ÂSYSTEM-ATTRIBUTE-LISTÁATTR-DES-PAIRCTUPLE-LISTBlCSSCTUPLE-FORMAT-LISTDOCDIR\Bq\BsFIFTHBtBuBzCGET-SYSTEM-ATTRIBUTE-LISTÂCREATE-ATTR-DESCRIPTORSTRING-UPCASE*READ-FROM-STRINGÀTUPLESRETRIEVE҃REDEFINE-RELBÁSAVE-RELATIONQ@YBCQBBDUBEJQCFWGQ@QAQPBQAQCQDQQEQFQGQBQ	J	
QO	BRENAME-DATABASEO
CRENAME-DBB
7y)`74F$B:BW]FB:B:B:BZFB_B
\BbCDATABASESB:\BÁDATABASE-NAMECNEW-DATABASE-NAME*PATHNAMEPATHREL-NAMESAVE-DIRRELATION-TUPLE-LISTDB-LB:B:B:CREL-TUPLE\Bq\pZLC,DO-NAMEDpBUINHIBIT-STYLE-WARNINGSBsBxByBzB{,Used to rename a database.

   DATABASES - Specify old-database-name and new-database-name.

   Example: (RENAME-DATABASE parts suppliers micro-parts micro-suppliers).B~BÂ*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*B}у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*BBBBpB]STRING-EQUAL*BERROR - The database to rename has to be the active database BBBBERROR - The new database name , is identical to the actual nameBlRETRIEVE-l-CONCATENATEҪFIND-SYMBOLB\RELATION-NAMESAVE-DIRECTORYCGET-SAVE-DIRECTORYҬ.XLDjPROBE-FILE.LISP.XFASL.QFASL\MEMBERBaBTEST\B8B\lMODIFIEDPBBBҪDELETE-FILEl.XLDBBXLD#>RENAME-FILEQFASLXFASLLISPÁSAVE-DATABASEThe database  has been renamed to Renaming database completed.R@QHSHHS5HQ@@SA@WBABRAQP

PPPRBQAQ

PBQPRBQPP	PPPPIPPPPPJIGFPFQAQP PFQAQ!P PFQAQ"P PFQAQ#P DvP$P%P&'(DQ)IIGQKJcJQKSLLSELWFPFQAQPEQ*PCDPCQ+P DEQP,P-DQPFQBQPEQ*P.PJ/7PCQ+P)1PCQ0P D	EQP,P-PCQ0PPCQ1P D	EQP,P-PCQ1PPCQ2P D	EQP,P-PCQ2PCJKKP34PAQ5PBQP6PBOOB
RENAME-RELATIONOPCRENAME-RELBP7;7F$B:BW]FB:B:B:BZFB_BP\BbCRELATIONSB:\BZÂLAST-NEW-RELATION-NAMEBfBeBiBlBBBÀRESULTCDB-RELATIONS-LISTBCALL-SAVE-DBÀREL-LB:BaCNEW-RELATION-NAMEBZ\Bq\BuBsBxByBzB{,Rename relations in the active database.

   RELATIONS - Specify <old-rel-name new-rel-name>

   Example: (RENAME-RELATION rel1 new-rel1 rel2 new-rel2)*AUTO-SAVE*B~BBBB'B(B}B)B*BBlRETRIEVE-l-B2B3B\RELATION-NAME,OWNER-IDBB*REVERSEBBBBBERROR - The relation BBҬ cannot be renamed because it is a system relation., is not defined in the database BBҬ is already defined in the database BB\,OWNER-IDSAVE-DIRECTORYlATTRIBUTESKEYTUPLE-FORMATIMPLEMENTATION-TYPElSTORAGE-STRUCTUREDOCB,RENAME-RELATION-Bl.XLDB9XLD#>BGXFASLQFASLLISPBThe relation  has been renamed to R@QMSMMS5MQJMQ@PPPPPPNP
PP	PPJNKMMQBPPMQBI]IMIQJ@S@W@YQPOXOQOPQPOPROQJQPBOQPPPOQ !PRPOQ "PP #P$RPQJQPPQPPPPQ %PP #P$RBQJQ&PQBkJQ
C
C'JQSOQWPQP@S@W@YQPOcOQ(P)BCCSDCYBEP*PEQPNOQPQCQNCWHPHQPPOQ+,PFGPFQ-P.GGQPHQPPPQ,P/PJ0PFQ1P.GPFQ2P.GPFQ3P.GLG45POQ 6PPQ #P$PQAQSOQWPQPSOBPÂRENAME-RELATION-ARRAY"@F$B:BW]FB:B:B:BZFB_B\BaBaBB:\CARRAY-NAMEÁNEW-ARRAY-NAME\Bq\B߀BARRAYB2BINTERNpBUCOPY-ARRAY-CONTENTSBҪEVALCRENAME-RELATION-UTILITY-ARRAY-LISTPQP@PQPAP@QAQ	
QQOBÂRENAME-RELATION-FLAVORFF$B:BW]FB:B:B:BZFB_B\BaBaBeB:B:B:CRENAME-RELATION-UTILITY-REDEF-RELQQQOBRENAME-RELATION-LISTFF$B:BW]FB:B:B:BZFB_B\BaBaBB:B:B:BQQOBÂRENAME-RELATION-STRUCTFF$B:BW]FB:B:B:BZFB_B\BaBaBeB:B:B:BQQQOBBOFF1$B:BW]FB:B:B:BZFB_B\BaBaB:B:\Bq\B߀BBBaBB\lMODIFIEDPRELATION-NAMEBB8BBB\RELATION-NAMESYSTEM-INDEXENTRY-POINTGETP҃PUTPPPPQP	P
PQPPPQP	P
PQPPPQP	P
PQQQPPQPOBB*>@*Fh$B:BW]FB:B:B:BZFB_B\BaBaBeB:\BBBCINDEX-LISTBlBBBjBkBBDOMAINSB:CINDEX-INFOB:\Bq\BxByB#BBsBvBwBBtBuBzB}B'B(C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*BBBBBlCMODIFIEDPBhKEYFORMATBBDEFINE-RELATIONBBBaBB\RELATION-NAMEBB8BB\lINDEX-NAMElINDEX-TYPEKEYBQTRIEVEB\,DOMAINSB,DELETE-l-B2B3ÀINSERTDESTROY-RELATIONQ@YBDQBBEUBF[GQBHJQCIWJGQ@Q	AQ
PBQAQPDQPPEQPHQPFQPIQPJQJPPPQPPPQPPPPPPQ C!PP"PPPPQ BKCQLLSM#P$PDQ%PMW&P'NQGQM[MSNLBQ
PBQ(Q)OB1\pB],FASL-RECORD-FILE-MACROS-EXPANDED\B8\\pBUDEFFb\DEFUN'\B%(̢\B#*j\BZi\B߆.ً\Bz[\By=#\Bxz(\Bw:}n\Bvx\Bu{Ĳ\Bt2=\Bs{dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatenate 'string pathname "XLD")))))
   ((setf path (probe-file (concatenate 'string pathname "QFASL")))
    (cond ((not (member rel-name *system-relations* :test 'string-equal))
   (rename-file path (concatenate 'string save-dir new-database-name
  "-" rel-name "." "XLD#>")))
  (t
   (delete-file (concatLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540814. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "RESTORE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2753699816. :AUTHOR "REL3" :LENGTH-IN-BYTES 16986. :LENGTH-IN-BLOCKS 17. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; RESTORE*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     fs:directory-list*
;1;;     errset*
;1;;     deff*
;;;  Change History
;;;  04.01.87  MRR  Changed the way Load-database, Load-environment, and Load-relation probe for the presence of a directory.
;;;                     Now databases and relations can be loaded remotely.
;;;  04.03.87  MRR  Fixed Load-database to catch Unknown-host-name error condition (SPR #4426).

(defun get-relation (relation project-list manip? &optional (saving? nil))
  (let (qtrieve-var)
    (setf project-list (convert-attributes project-list))
    (setf qtrieve-var (car (qtrieve 'system-relation *system-relation-attributes*
    (append '("DISK" "SAVE-DIRECTORY") project-list) *system-relation-key*
    `(string-equal relation-name ,(string relation)))))
    ;1;*
    ;1; The relation does not exist ... it could be a view, however views can not be modified in the current system, so do not retrieve*
    ;1; the view definition if the current operation would manipulate it.*
    (cond ((and (null qtrieve-var) (null manip?))
   (setf qtrieve-var (caar (qtrieve 'system-view *system-view-attributes* '("VIEW-DEFINITION")
    *system-view-key*
    (list 'and (list 'string-equal 'view-name (string relation))
  (list 'string-equal 'owner-id user-id)))))
   ;1;*
   ;1; A view is defined by evaluation of the view definition*
   (if qtrieve-var
       (get-relation (setf relation (eval qtrieve-var)) project-list manip?)
       (list relation nil)))
  ((null qtrieve-var)
   (list relation nil))
  ((and qtrieve-var (car qtrieve-var)(not saving?))
   (load-relation relation 'dir (cadr qtrieve-var))
   (list relation (cddr qtrieve-var)))
  (t
   (list relation (cddr qtrieve-var))))))

(deff load-db 'load-database)

(defun load-database (dbname &rest keyword-list
      &key &optional directory
      &allow-other-keys
      &aux pathname temp-dir temp-status (dir-changed? nil))
  "A database saved on the disk can be loaded using this function.

   DBNAME    - Name of the database to be restored.
   DIRECTORY - Name of the directory in which it can be found."
  directory
  (block load-database
       (unwind-protect
   (progn
     ;;
     ;;  1If there is an activedb, determine if any relation has been modified, if so do not* 1do anything which would provoke*
     ;1; those relations, i.e. terminate the function.*
     ;;
     (cond ((active-database 'restore)
    (cond ((car (funcall
  (find-symbol (concatenate 'string "RETRIEVE-"
    *system-relation-base-implementation*
      "-" *system-relation-storage-structure*)
       *pkg-string*)
  'system-relation *system-relation-attributes* '("RELATION-NAME")
  *system-relation-key* (list 'string-equal 'modifiedp "T") nil
  'system-relation))
     (when *provide-error-messages*;mrr 04.03.87 - changed "if" to "when"
       (format *standard-output*
       "~%ERROR - ~s is the current database and it has modified relations"
       *active-db*)
       (format *standard-output*
       "~%          Please resolve this conflict by either saving or destroying this database")
       (format *standard-output*
       "~%          before restoring a saved database"))
   (return-from load-database nil)))))
     (cond ((null (setf dbname (validate-sym dbname t)))
    (return-from load-database nil)))
     (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
    ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
     (if (not keyword-list)
 (setf keyword-list (list 'dir *save-directory*)))
     (setf keyword-list (get-keyword-value-prereq '(dir) keyword-list))
     (setf pathname (concatenate 'string (setf temp-dir (get-directory keyword-list))
   dbname "-" "system-relation" "."))
     (cond ((errset (fs:directory-list temp-dir) nil);mrr 04.01.87
      (setf *save-directory* temp-dir)
      (setf *restore-operation* nil
     *donot-commit* t)
      (cond ((or
     (probe-file (setf pathname (concatenate 'string *save-directory* dbname ".XLD")))
     (probe-file (setf pathname (concatenate 'string *save-directory* dbname
     ".2XFASL*")))
     (probe-file (setf pathname (concatenate 'string *save-directory* dbname "2.LISP"*))))
   (if (active-databasep)
       (destroy-database *active-db*))
   (errset (load pathname :verbose (if *provide-status-messages*
    t
    nil))))
  (t
   (if *provide-error-messages*
       (format *standard-output*
       "~%ERROR - Database ~s does not exist in directory ~s"
       dbname *save-directory*))
   (setf *donot-commit* nil)
   (return-from load-database nil)))
    (setf *restore-operation* t
  *donot-commit* nil)
    ;;1The DEFDB would have set the property COMMIT-TUPLES to a list of system-tuples which will be duplicated in*
    ;1; the following call. So, reset them.*
    (mapcar (function (lambda (sys-rel)
(putp sys-rel nil 'commit-tuples)))
    *system-relations*)
    (mapcar (function (lambda (relation)
(load-relation relation 'dir temp-dir)
(setf *restore-operation* t)))
    (reverse *system-relations*))
    (setf *restore-operation* nil)
    ;;1We will get rid of all the tuples for relations which might have been saved without saving the relations*
    ;1; themselves. (No way to restore them !)*
    (mapc (function (lambda (sys-tup &aux rel path)
(setf rel (car (project-list (list sys-tup)
     *system-relation-attributes*
     '("RELATION-NAME" "SAVE-DIRECTORY"))))
(setf path (cadr rel)
      rel (car rel))
(if (not (member rel *system-relations* :test 'string-equal))
    (unless (condition-case ();mrr 04.03.87
  (or (probe-file (concatenate 'string path dbname "-" rel
  ".XLD"))
      (probe-file (concatenate 'string path dbname "-" rel
  ".LISP"))
       (probe-file (concatenate 'string path dbname "-" rel
  ".XFASL"))
       (probe-file (concatenate 'string path dbname "-" rel
  ".QFASL")))
        ((sys:network-error
  sys:unknown-host-name) nil))
(if (or (probe-file (concatenate 'string temp-dir dbname "-"
 rel ".XLD"))
(probe-file (concatenate 'string temp-dir dbname "-"
 rel ".LISP"))
(probe-file (concatenate 'string temp-dir dbname "-" rel
       ".XFASL"))
(probe-file (concatenate 'string temp-dir dbname "-" rel
       ".QFASL")))
    ;;1 The files corresponding to this relation have been transferred to the*
    ;1; directory same as that of the database.*
  (delete-or-modify 'system-relation t
    `(string-equal relation-name ,rel)
    '("SAVE-DIRECTORY") (list temp-dir))
  (progn
    (setf temp-status *provide-status-messages*)
    (setf *provide-status-messages* nil)
    (destroy-rel rel)
    (setf *provide-status-messages* temp-status))))
    (if (not (string-equal path temp-dir))
(setf dir-changed? t)))))
    (qtrieve 'system-relation *system-relation-attributes* *system-relation-attributes*
     *system-relation-key* t))
    (delete-or-modify 'system-relation t t '("MODIFIEDP") '(nil))
    (delete-or-modify 'system-relation t '(not (equal 0 (search "SYSTEM" relation-name)))
      '("DISK") '(t))
    ;;1In case the files have been transferred from one machine to another.*1 *
    (if dir-changed?
(delete-or-modify 'system-relation t '(equal 0 (search "SYSTEM" relation-name))
  '("SAVE-DIRECTORY") (list temp-dir)))
    (init-where-opt)
    (cond ((qtrieve 'system-storage-structure *system-storage-structure-attributes*
    '("STORAGE-STRUCTURE-NAME") *system-storage-structure-key*
    '(string-equal storage-structure-name "ISAM"))
   (modify-tuples 'system-storage-structure 'attr '("STORAGE-STRUCTURE-NAME")
  'where '(string-equal storage-structure-name "ISAM")
  'values '("2AVL"*))
   (delete-or-modify 'system-optfunc nil '(string-equal storage-structure-type "ISAM"))
   (insert 'system-optfunc 'tuples
   '(("=" "AVL" "OPT-AVL-EQUAL" "RTMS")
     ("<" "AVL" "OPT-AVL-LT" "RTMS")
     (">" "AVL" "OPT-AVL-GT" "RTMS")
     ("<=" "AVL" "OPT-AVL-LT" "RTMS")
     (">=" "AVL" "OPT-AVL-GT" "RTMS")
     ("AND" "AVL" "OPT-AVL-AND" "RTMS")
     ("EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS")
     ("LESSP" "AVL" "OPT-AVL-LT" "RTMS")
     ("STRING-LESSP" "AVL" "OPT-AVL-LT" "RTMS")
     ("GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
     ("STRING-GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
     ("OR" "AVL" "OPT-AVL-OR" "RTMS")
     ("STRING-EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS"))))))
   (t
    (if *provide-error-messages*
(format *standard-output* "~%ERROR - The Directory ~S does not exist" temp-dir))
    (return-from load-database nil)))
     (return-from load-database dbname))
 (setf *restore-operation* nil))))

(deff load-env 'load-environment)

(defun load-environment (envname &rest keyword-list
 &key &optional directory &allow-other-keys
 &aux pathname dir)
  "Load a saved environment.

   ENVNAME   - Name of the environment to be restored.
   DIRECTORY - Name of the directory in which it can be found."
  directory
  (block load-environment
  (if (not (setf envname (validate-sym envname t)))
      (return-from load-environment nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf keyword-list (get-keyword-value-prereq '(dir) keyword-list))
  (setf pathname (concatenate 'string
   (if (errset (fs:directory-list (setf dir (get-directory keyword-list))) nil);mrr 04.01.87
       dir
       (progn
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR -The directory ~S does not exist." dir))
 (return-from load-environment nil)))
   "rtms-environment-" envname))
  (cond ((or (setf pathname (probe-file (concatenate 'string pathname ".XLD")))
     (setf pathname (probe-file (concatenate 'string pathname ".2XFASL*")))
     (setf pathname (probe-file (concatenate 'string pathname ".2LISP*"))))
 (load pathname :verbose (if *provide-status-messages*
t
      nil))
 (return-from load-environment envname))
((string-equal *environment-name* envname)
 (if *provide-status-messages*
     (format *standard-output* "~%Environment ~s defined" envname))
 (return-from load-environment envname))
(t
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Environment ~s does not exist in directory ~s"
     envname (get-directory keyword-list)))
 (return-from load-environment nil)))))

;1;*;
;1;*;1  RTMS will now look first for xfasl extensions for relation names.  9/24/85 SMC*
;1;*;
(defun load-relation (relation-name &rest keyword-list
      &key &optional directory &allow-other-keys
      &aux indices pathname xldf xfaslf qfaslf lispf relation-info temp1 temp2 dir)
  "Load a saved relation.

   RELATION-NAME    - Name of the relation to be restored.
   DIRECTORY        - Name of the directory in which it can be found."
  directory
  (block load-relation
(unwind-protect
    (progn
      (if (not (active-database))
  (return-from load-relation nil))
      (if (null (setf relation-name (validate-sym relation-name t)))
  (return-from load-relation nil))
      (if (and (not (member relation-name *system-relations* :test 'string-equal))
       (not (relationp relation-name)))
  (progn
    (if *provide-error-messages*
(format *standard-output* "~%ERROR -The relation ~S does not exist in the database ~S"
relation-name *active-db*))
    (return-from load-relation nil)))
      ;;
      ;;1 Right now we will support only QFASL and LISP type formats. If a relation is stored as QFASL it will be used. Later using*
      ;1; the message ':modified-date on the file stream, we will use the latest relation file. set the restore key*
      ;;
      (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
     ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
      (if (null (cadr keyword-list))
  (setf keyword-list (list 'dir (if (member relation-name *system-relations*
    :test 'string-equal)
    *save-directory*
    (caar (qtrieve 'system-relation *system-relation-attributes*
   '("SAVE-DIRECTORY") *system-relation-key*
   (list 'string-equal 'relation-name
 (string-upcase relation-name))))))))
      (setf keyword-list (get-keyword-value-prereq '(dir) keyword-list))
      (errset
(progn
  (setf *restore-operation* t)
  ;;
  ;;1get the directory and form the pathname*
  ;;
  (setf pathname (concatenate 'string
   (if (errset (fs:directory-list (setf dir (get-directory keyword-list))) nil);mrr 04.01.87
       dir
       (progn
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR -The directory ~S does not exist."
     dir))
 (return-from load-relation nil)))
   *active-db* "-" relation-name))
  ;;1Find out if there are both QFASL and LISP formats for this relation. If so, restore the latest.*
  (setf xldf (concatenate 'string pathname ".XLD")
xfaslf (concatenate 'string pathname "2.XFASL"*)
qfaslf (concatenate 'string pathname ".QFASL")
lispf (concatenate 'string pathname ".LISP"))
  (if (and (probe-file xldf) (probe-file xfaslf))
      (progn
(if (> (send (setf temp1 (open xldf)) ':creation-date)
       (send (setf temp2 (open xfaslf)) ':creation-date))
    (load xldf :verbose (if *provide-status-messages*
      t
      nil))
    (load xfaslf :verbose (if *provide-status-messages*
     t
     nil)))
(close temp1)
(close temp2))
      ;;1see if the relation exists as QFASL.*
      ;;
      (if (not (probe-file xldf))
  ;;
  ;;1A QFASL does not exist for the relation. See if LISP type file exists for the relation.*
  ;;
  (cond ((probe-file xfaslf)
 (load xfaslf :verbose (if *provide-status-messages*
   t
   nil)))
((probe-file qfaslf)
 (load qfaslf :verbose (if *provide-status-messages*
   t
   nil)))
((probe-file lispf)
 (load lispf :verbose (if *provide-status-messages*
  t
  nil)))
((string-equal relation-name "SYSTEM-INDEX")
 (define-system-index)
 (setf *system-relations* (cdr *system-relations*))
 (commit-system-relation)
 (delete-or-modify 'system-relation t
   `(string-equal relation-name "SYSTEM-INDEX")
   '("MODIFIEDP") '(t)))
(t
 (setf *restore-operation* nil)
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR -The relation ~S does not exist in the database ~S"
     relation-name *active-db*))
 (return-from load-relation nil)))
  ;;
  ;;1if it does then load the relation file*
  ;;
  (load xldf :verbose (if *provide-status-messages*
    t
    nil))))))
      ;;
      ;;1reset the restore key*
      ;;
      (delete-or-modify 'system-relation t `(string-equal relation-name ,(string-upcase relation-name))
'("DISK") '(nil))
      ;;
      ;;1  Need to determine if there are indexes defined on this relation, if so  they must also be defined.*
      ;;
      (cond ((and (not (member relation-name *system-relations* :test 'string-equal))
  (setf indices (qtrieve 'system-index *system-index-attributes*
 '("2INDEX-NAME"* "2KEY"* "2INDEX-TYPE"*)
 *system-index-key*
 `(string-equal relation-name ,relation-name))))
     (setf relation-info (car (qtrieve 'system-relation *system-relation-attributes*
       '("2ATTRIBUTES*" "2IMPLEMENTATION-TYPE"*
 "2STORAGE-STRUCTURE"*)
       *system-relation-key*
       (list 'string-equal 'relation-name
     (string-upcase relation-name)))))
     (mapc (function (lambda (index-info)
       (create-index-relation relation-name (first index-info)
      (first relation-info)
      (second index-info) (third index-info)
      (second relation-info) (third relation-info))))
   indices)))
      (setf *restore-operation* nil)
      (return-from load-relation relation-name))
  (setf *restore-operation* nil))))

 (relation-name new-relation-name relation-tuple)
  (rename-relation-utility-redef-rel relation-name new-relation-name relation-tuple))

(defun rename-relation-list (relation-name new-relation-name ignore)
  (rename-relation-utility-array-list relation-name new-relation-name))

(defun rename-relation-struct (relation-name new-relation-name relation-tuple)
  (rename-relation-utility-redef-rel relation-name new-relation-LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540817. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "RESTORE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360130. :AUTHOR "REL3" :LENGTH-IN-BYTES 4432. :LENGTH-IN-BLOCKS 9. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8,RESTORE\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPGET-RELATIONXF9$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\RELATIONPROJECT-LISTÀMANIP?j&OPTIONAL\SAVING?B:B:\QTRIEVE-VAR\)MACROS-EXPANDED\pB\lXR-BQ-LISTSETFpBT,USER-IDC*SYSTEM-VIEW-KEY**SYSTEM-VIEW-ATTRIBUTES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*CCONVERT-ATTRIBUTESSYSTEM-RELATION\DISKSAVE-DIRECTORYpB\,*APPENDҪSTRING-EQUALÁRELATION-NAMESTRINGҪLISTQTRIEVE҃SYSTEM-VIEW\,VIEW-DEFINITIONANDCVIEW-NAMEOWNER-IDEVALBP҃DIRÁLOAD-RELATIONQ	PP
PQPPPQB@ PPPPPPPQPPPB@@QÁQQQ@@QP@WQ@YOBPÁLOAD-DATABASEOLOAD-DBBmAm@FW$B:BV]FB:B:B:BYFB^B\ÀDBNAME&RESTKEYWORD-LIST&KEYBcjDIRECTORYj&ALLOW-OTHER-KEYSB:\BB*PATHNAMETEMP-DIRTEMP-STATUSDIR-CHANGED?B:BB:B:B:pB\TEMB`SYS-TUPRELPATHB:B:pB\.CASE.ITEM.\Bi\BlpBTSENDpB\SELECT-MEMQpBTlCONDITION-CASE-IFpBTCONDITION-CASEUNLESSpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETPROGBmWHENDOCUMENTATIONA database saved on the disk can be loaded using this function.

   DBNAME    - Name of the database to be restored.
   DIRECTORY - Name of the directory in which it can be found. plEH*CONDITION-HANDLERS*Ã*SYSTEM-STORAGE-STRUCTURE-KEY*Ä*SYSTEM-STORAGE-STRUCTURE-ATTRIBUTES*C*SYSTEM-RELATIONS*C*PROVIDE-STATUS-MESSAGES*Á*DONOT-COMMIT*у*RESTORE-OPERATION**SAVE-DIRECTORY*у*ACTIVE-DB**PROVIDE-ERROR-MESSAGES*BrBsу*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*\iDIRECTORYpB\STORE-KEYARGSFRESTOREACTIVE-DATABASEB}lRETRIEVE-l-CONCATENATEҪFIND-SYMBOLBu\RELATION-NAMEB{CMODIFIEDPlTB~TERPRI,ERROR - WRITE-STRINGPRIN1 is the current database and it has modified relations          Please resolve this conflict by either saving or destroying this database          before restoring a saved databaseVALIDATE-SYMB\BGET-KEYWORD-VALUE-PREREQÁGET-DIRECTORY,system-relationl.p,G3813FPERRORpB\ERRSET-HANDLERpB4DIRECTORY-LISTҬ.XLDjPROBE-FILE.XFASL.LISPACTIVE-DATABASEPDESTROY-DATABASEpBG3821F)VERBOSELOADlERROR - Database  does not exist in directory ÁCOMMIT-TUPLESPUTP*REVERSEBB\RELATION-NAMESAVE-DIRECTORYBapB\MEMBER-TESTpBG3856F\pNETNETWORK-ERRORpBlUNKNOWN-HOST-NAMEpB\CONDITION-CASE-THROW.QFASL)CONDITION-NAMESBBB|\SAVE-DIRECTORYDELETE-OR-MODIFY҃DESTROY-RELpB\STRING-EQUAL*\lMODIFIEDP\B:\NOT\EQUAL\SEARCHSYSTEMB|\DISK\BY\B'\B*SYSTEMB|ÁINIT-WHERE-OPTSYSTEM-STORAGE-STRUCTURE\STORAGE-STRUCTURE-NAME\B{ÂSTORAGE-STRUCTURE-NAMEISAMATTRÀWHEREVALUES\AVLÁMODIFY-TUPLESÁSYSTEM-OPTFUNC\B{ÂSTORAGE-STRUCTURE-TYPEISAMÀTUPLES\\l=AVLOPT-AVL-EQUALRTMS\l<AVLlOPT-AVL-LTRTMS\l>AVLlOPT-AVL-GTRTMS\l<=AVLlOPT-AVL-LTRTMS\l>=AVLlOPT-AVL-GTRTMS\ANDAVLOPT-AVL-ANDRTMS\EQUALAVLOPT-AVL-EQUALRTMS\LESSPAVLlOPT-AVL-LTRTMS\STRING-LESSPAVLlOPT-AVL-LTRTMS\,GREATERPAVLlOPT-AVL-GTRTMS\,STRING-GREATERPAVLlOPT-AVL-GTRTMS\lORAVLlOPT-AVL-ORRTMS\STRING-EQUALAVLOPT-AVL-EQUALRTMSÀINSERTERROR - The Directory , does not exist@@QPAPUP,PPPPPPFPPPPP P!P"PJF#$P%P&'P%#(P%#)P%]ZQ*@QGSGGS5GQ@+PP"@,P@Q-@P@Q.CÀQP/P0PB1P2PT3P4P1PJCHPJCICQ5"J!BJ!B\\rCQ
	PPQ6PB7PPQ8PB7PPQ9PB7#:P;<P=PT3P4P<PJCFPJCJBQ>P?"E\\K	#@P%Q&AP%P&	n
	JJPHF	FQHSBPCCFHHJJPDHFFQHSL+PCQE
CFHH
PPPPFIISMNOMQ"PGPHBNNWONSNPPI{JPKPTLPMPJPJCPPJCQPOQQPNQ6P7POQQPNQ9P7POQQPNQ8P7POQQPNQNP7J!BJ!B\
\QOPQRPPRQP<PCQQPNQ6P7PCQQPNQ9P7PCQQPNQ8P7	PCQQPNQNP7PPRPNQ"SPCQ"TPDNQUDQOQCQVEIkPWPXPTPYPZP[PTEP\PSPCQ"T]^PP_PP`PF^PaP_PbP`PcPdPJefPgPTfPhPiPjr#kP%CQ&lP~Q]ZJ]ZP
OBLOAD-ENVIRONMENTOLOAD-ENVB&B`&\Fh$B:BV]FB:B:B:BYFB^B\ENVNAMEBBBBcBBB:\BBBBBB:B:\Bi\BBBBBBBmB,Load a saved environment.

   ENVNAME   - Name of the environment to be restored.
   DIRECTORY - Name of the directory in which it can be found.BC*ENVIRONMENT-NAME*BBБ\BBB\BBB}pBG3959FBBBBB~BERROR -The directory BB, does not exist.lrtms-environment-BҬ.XLDB.XFASL.LISPBBB ҬEnvironment , definedERROR - Environment  does not exist in directory @@QPAQ	R@QDSDDS5DQ@
P@Q@PPPTPPPJCEPJCF@QCJ!BJ!B\\CQ
PCQPRPQBPBQPBPBQPBPBQPB	BQP PQ!
"PQ#P
$PQ%P@QROBBJJ@F$B:BV]FB:B:B:BYFB^B\B|BBBBcBBB:\BBINDICESBXLDFÀXFASLFÀQFASLFÀLISPFÁRELATION-INFOÀTEMP1ÀTEMP2BBB:B:B:B:BCINDEX-INFO\Bi\THIRDSECONDFIRSTBBlBBBBBBBBmB,Load a saved relation.

   RELATION-NAME    - Name of the relation to be restored.
   DIRECTORY        - Name of the directory in which it can be found. BC*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*BBBrBsBBBBʑ\BBFBBB{BCRELATIONPBҬERROR -The relation BB, does not exist in the database BBu\SAVE-DIRECTORYB|STRING-UPCASEB~B\BBpBG4015FBBB}pBG4023FBBERROR -The directory , does not exist.l-BҬ.XLD.XFASL.QFASL.LISPBCREATION-DATEOPENBBCLOSEҬSYSTEM-INDEXB ҃DEFINE-SYSTEM-INDEXÂCOMMIT-SYSTEM-RELATION\B{B|SYSTEM-INDEX\lMODIFIEDP\BYB\DISK\B:SYSTEM-INDEX\lINDEX-NAMEKEYlINDEX-TYPE\lATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREÂCREATE-INDEX-RELATION@@QPAPU]ZQQPPQPQPP@QLSLLS5LQ@@PQPPPP
PP	PPPQ !"B!@#P@Q$@%P&PT'P(P%PJCMPJCN)P*P+PT'P(P*PJCOPJCP@Q,K-!J!BJ!B\\KQ.PKQ/P\P0PQ1C)PCQ2P1D)PCQ3P1E)PCQ4P1F)PCQ5P1GDQ6EQ67PDQ8I7PEQ8JyDQEQ9P:IQ;JQ;5DQ6*EQ6EQ&FQ6FQ!GQ6GQQ<P=
>?P@PAPBPCPQPPDQ9P:!E\\QPPPQ !DPEPCQPP'FPPGPPPPQ!"BP
PHP	PPPQ !"BHBQOOSRQRSHSRWR[HWH[JIOڀQ]ZJ]ZPOB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\Bz(\B{\B:}n\B,a\B=#\B-i\B~z\B<p\B`sN\B|\B(̢\B*j\B6\B+\BjA\B<i\BaM*\Bm[\Bl.ًVL-AND" "RTMS")
     ("EQUAL" "AVL" "OPT-AVL-EQUAL" "RTMS")
     ("LESSP" "AVL" "OPT-AVL-LT" "RTMS")
     ("STRING-LESSP" "AVL" "OPT-AVL-LT" "RTMS")
     ("GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
     ("STRING-GREATERP" "AVL" "OPT-AVL-GT" "RTMS")
     ("OR" "AVL" "OPT-AVL-OR" "RTMS")
     ("STRING-EQUAL" "AVL" "OPT-AVL-EQUAL"LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540820. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "RETRIEVE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846786. :AUTHOR "REL3" :LENGTH-IN-BYTES 54403. :LENGTH-IN-BLOCKS 54. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;;; -*- Mode:Common-Lisp; Package:RTMS; Base:10; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*) -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved.
;1;; RETRIEVE*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     firstn*
;1;;     errset*
;1;;     deff*
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     retrieve-flavor-hash*
;1;;     retrieve-flavor-heap*
;1;;     retrieve-flavor-avl*
;1;;*

(defun obtain-project-&-format (relation-name project-list tuple-format sort-list *current-attributes*
*current-tuple-format*
&aux a-p-l actual-project-list final-project-list items temp-tuple-format)
  ;;
  ;;1  Make sure that the project-list and tuple-format values passed are in the proper initial form*
  ;;
  (cond ((null project-list)
 (setf project-list *current-attributes*
       actual-project-list project-list
       final-project-list project-list)
 (cond ((null tuple-format)
(setf tuple-format *current-tuple-format*))
       ((> (setf items (- (length project-list) (length tuple-format))) 0)
(setf tuple-format (append tuple-format (nthcdr items *current-tuple-format*))))
       ((< items 0)
(setf tuple-format (firstn (length project-list) tuple-format)))))
(t
 ;;
 ;;1  Do some error detection and corretion*
 ;;
 (if (not (listp project-list))
     (setf project-list (list project-list)))
 (if (and tuple-format (not (listp tuple-format)))
     (setf tuple-format (list tuple-format)))
 ;;
 ;;1  The PROJECT-LIST returned from PARSE-PROJECT contains all of the attributes whose values are needed.*
 ;;1  The ACTUAL-PROJECT-LIST is the user specified project-list will all of the illegal entries removed.*
 ;;1  The TEMP-TUPLE-FORMAT has the tuple format values for the actual attributes which will be output.*
 ;;
 (multiple-value-setq (project-list actual-project-list temp-tuple-format)
   (parse-project relation-name *current-attributes* project-list *current-tuple-format* tuple-format))
 ;;
 ;;1  Obtain the names of the attributes which are to be output and their format values*
 ;;
 ;;1  Form the list of attribute names as they will appear in the display. If the project element is a list, the first element of that*
 ;1; list will be the name of the attribute in the output.*
 ;;
 (setf a-p-l (mapcar #'(lambda (attr)
 (if (not (listp attr))
     attr
     (car attr)))
     actual-project-list))
 ;;1  *
 ;;1  The TUPLE-FORMAT contains the values for the format of the attributes which will comprise the results. They will match up*
 ;1; with the final output attribute list*
 ;;
 (if (< (length tuple-format) (length a-p-l))
     (setf tuple-format (append tuple-format (make-list (- (length a-p-l) (length tuple-format))
':initial-element 10))))
 ;;
 ;;1  Form the final project and tuple format lists. If a sort is requested, determine if the sort attributes are contained in the*
 ;1; project list. If not put them there so that their values may be projected in order that the sort may be performed.*
 ;;
 (cond (sort-list
(setf final-project-list project-list)
(mapcar (function (lambda (attribute)
    (cond ((and (not (member attribute project-list :test 'string-equal))
(member attribute *current-attributes* :test 'string-equal))
   (setf project-list (append project-list (list attribute))
 actual-project-list (append actual-project-list
     (list attribute))))
  ((null attribute)
   (setf project-list (copy-list project-list))))))
sort-list)))
 (setf tuple-format temp-tuple-format)))
  (values project-list tuple-format actual-project-list final-project-list))

(defun obtain-sort (sort quick-sort)
  ;;
  ;;1  Make sure that the sort value is a list of elements*
  ;;
  (cond ((and sort (not (listp sort)))
 (setf sort (list sort)))
((and (listp sort) (null (car sort)))
 (setf sort nil))
((listp (car sort))
 (setf sort (car sort))))
  ;;
  ;;1  Make sure that the quick-sort value is a list of elements*
  ;;
  (cond ((and quick-sort (not (listp quick-sort)))
 (setf quick-sort (list quick-sort)))
((and (listp quick-sort) (null (car quick-sort)))
 (setf quick-sort nil))
((listp (car quick-sort))
 (setf quick-sort (car quick-sort))))
  ;;
  ;;1  Validate that the names of the attributes were specified correctly*
  ;;
  (cond (sort
 (setf sort (mapcar (function (lambda (attribute)
(validate-sym attribute t)))
    sort))
 (cond ((member nil sort)
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - Illegally specified sort clause"))
(setf sort 0))))
(quick-sort
 (setf quick-sort (mapcar (function (lambda (attribute)
      (validate-sym attribute t)))
  quick-sort))
 (cond ((member nil quick-sort)
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - Illegally specified sort clause"))
(setf quick-sort 0)))))
  (values sort quick-sort))

(defun obtain-wide (widep number-per-line &aux (status t))
  (cond (widep
 ;;
 ;;1  RTMS will now accept a numeric value to be specified with the widep keyword instead of having to specify both.*
 ;;
 (cond ((and (numberp widep) (null number-per-line))
(setf number-per-line widep))
       ((null number-per-line)
(setf number-per-line -1)))
 (if (listp number-per-line)
     (setf number-per-line (car number-per-line)))
 ;;
 ;;1  Validate the value of number-per-line*
 ;;
 (cond ((or (not (numberp number-per-line)) (< number-per-line -1) (= 0 number-per-line))
(if *provide-error-messages*
    (format *standard-output* "~%ERROR - ~s is not a legal number specification"
    number-per-line))
(setf status nil))))
(t
 (setf number-per-line nil)))
  (values status number-per-line))

(defun process-quick-sort (tuple quick-sort actual-project-list
   &aux a-p-l)
  (setf a-p-l (mapcar #'(lambda (attr)
  (if (not (listp attr))
      (string attr)
      (string (car attr))))
      actual-project-list))
  (cond ((member quick-sort '(t (t)))
 (setf quick-sort (quick-sort-prereq t a-p-l)))
(t
 (setf quick-sort (quick-sort-prereq (mapcar #'(lambda (attr)
 (string attr))
     quick-sort)
     a-p-l))))
  (if quick-sort
      (quick-sort (copy-list tuple) quick-sort a-p-l)
      nil))

(defun process-sort (tuple sort project-list actual-project-list *current-attributes* *current-domains*
     &aux (domains nil) key-value attr-pos)
  ;;
  ;;1  Before the tuples list can be sorted, the domains of the attributes must be determined*
  ;;
  (do ((attr actual-project-list (cdr attr)))
      ((null attr) t)
    (cond ((setf key-value (- (length *current-attributes*)
      (length (member (if (not (listp (setf attr-pos (car attr))))
  attr-pos
  (setf attr-pos (car attr-pos)))
      *current-attributes* :test 'string-equal))))
   (setf domains (cons (if (member attr-pos *current-attributes* :test 'string-equal)
   (nth key-value *current-domains*)
   "ANYP")
       domains)))
  (t
   (setf domains (cons "ANYP" domains)))))
  (setf domains (reverse domains))
  ;;
  ;;1  Sort the tuple list*
  ;;
  (sort-list tuple sort project-list domains))

(defun convert-attributes (attribute-list)
  (cond ((null attribute-list)
 nil)
(t
 (if (not (listp attribute-list))
     (setf attribute-list (list attribute-list)))
 (mapcar #'(lambda (attribute)
     (cond ((symbolp attribute)
    (string attribute))
   ((stringp attribute)
    (string-upcase attribute))
   (t
    attribute)))
 attribute-list))))

(defun extract-key-heap (attribute-list key-list domains where-clause package-name)
  attribute-list key-list domains where-clause package-name
  nil)

(defun retrieve-internal (relation-name keyword-list
  &aux (tuple nil) current-attributes current-domains current-key
  current-implementation-type current-storage-structure actual-project-list
  current-tuple-format final-project-list key-value into project-list where-clause
  print qprint stream output-file-name tuple-format number-per-line return-tuples sort
  card retrieve-index-name quick-sort keyword-values status index-name
  (list-of-keywords '(into project where print output format num wide qprint tuple sort
      stream dir doc key imp sto unique quick-sort index-name)))
  (block retrieve-internal
  (cond (*parameter-checking*
 (if (or (not (active-database)) (null (setf relation-name (validate-sym relation-name))))
     (return-from retrieve-internal nil))))
  (setf tuple (get-relation relation-name '("ATTRIBUTES" "DOMAINS" "KEY" "IMPLEMENTATION-TYPE"
    "STORAGE-STRUCTURE" "TUPLE-FORMAT" "CARDINALITY") nil))
  (cond ((null (cadr tuple))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Relation ~s does not exist in the database ~s"
     relation-name *active-db*))
 (return-from retrieve-internal nil)))
  ;;
  ;;1  Obtain the information which has been passed by the user and that which is known about the current relation*
  ;;
  (setf relation-name (car tuple)
tuple (cadr tuple)
current-attributes (first tuple)
current-domains (second tuple)
current-key (third tuple)
current-implementation-type (fourth tuple)
current-storage-structure (fifth tuple)
current-tuple-format (sixth tuple)
card (seventh tuple))
  (if *parameter-checking*
      (setf keyword-list (get-keyword-value-prereq list-of-keywords keyword-list))
      (setf keyword-list (de-nest-keyword-list keyword-list)))
  (setfkeyword-values (get-keyword-value list-of-keywords keyword-list))

  ;;
  ;;1  Determine if the user requested a retrieve directly from an index. If so, must determine if the index requested exists in the database.*
  ;;
  (cond ((and (setf retrieve-index-name (nth 19 keyword-values)) *parameter-checking*)
 (setf retrieve-index-name (caar (funcall
   (find-symbol
     (concatenate 'string "2RETRIEVE-"*
  *system-relation-base-implementation*
  "2-"* *system-relation-storage-structure*) *pkg-string*)
   'system-index *system-index-attributes* '("2INDEX-NAME"*)
   *system-index-key*
   `(and (string-equal relation-name ,(string-upcase relation-name))
 (string-equal index-name ,(string-upcase retrieve-index-name)))
   nil 'system-index)))
 (cond ((null retrieve-index-name)
(if *provide-error-messages*
    (format *standard-output* "2~%ERROR - ~s is not a defined index on the relation ~s"*
    (nth 19 keyword-values) relation-name))
(return-from retrieve-internal nil)))))
  ;;
  ;;1  Obtain the values of any other keywords which may be present*
  ;;
  (setf where-clause (or (nth 2 keyword-values) t)
print (nth 3 keyword-values)
output-file-name (nth 4 keyword-values)
qprint (nth 8 keyword-values)
return-tuples (nth 9 keyword-values)
stream (nth 11 keyword-values))
  (if (null keyword-list)
      (setf print t))
  (if (and return-tuples (not (member 'print keyword-list)))
      (setf print nil))
  ;;
  ;;1  Obtain the values from the wide and number keywords*
  ;;
  (if (and (not return-tuples) print)
      (if (not (multiple-value-setq (status number-per-line)
    (obtain-wide (nth 7 keyword-values) (nth 6 keyword-values))))
  (return-from retrieve-internal nil)))
  ;;
  ;;1  Obtain the values of the sort and quick-sort keywords. The sort keyword value is in the 10th position in the keyword-values list
   *;1; while quick-sort is the 18th, based on 0 being the first position. An error condition is signaled if the value of sort or quick-sort is 0.
   *;1; The attribute name lists are return-from retrieve-internaled validated.*
  ;;
  (multiple-value-setq (sort quick-sort)
    (obtain-sort (nth 10 keyword-values) (nth 18 keyword-values)))
  (if (or (equal sort 0) (equal quick-sort 0))
      (return-from retrieve-internal nil))
  ;;
  ;;1  Obtain the values of the project and format lists which are needed to proceed*
  ;;
  ;;1  PROJECT-LIST contains a list of the attributes whose values are needed to complete the retrieve processing.*
  ;;1  TUPLE-FORMAT contaion the format widths which will be used for the final display*
  ;;1  ACTUAL-PROJECT-LIST contains the project list as the user specified with all of the illegal elements removed*
  ;;1  FINAL-PROJECT-LIST contains the name of the attributes which are to be returned. These attributes may be attributes of the relation
   *;1;                       or they may be calculated attributes. This list corresponds with the TUPLE-FORMAT list.*
  ;;
  (multiple-value-setq (project-list tuple-format actual-project-list final-project-list)
    (obtain-project-&-format relation-name (nth 1 keyword-values) (nth 5 keyword-values) (or sort quick-sort)
     current-attributes current-tuple-format))
  (cond ((null *parameter-checking*))
((null (car project-list))
 (if *provide-error-messages*
     (format *standard-output*
     "~%ERROR - There are no legal attributes contained in the PROJECT clause"))
 (return-from retrieve-internal nil))
;;
;;1  An error occured in OBTAIN-PROJECT-&-FORMAT.*
;;
((member nil project-list)
 (return-from retrieve-internal nil)))
  ;;
  ;;1  Determine if a key exists in the where clause for the current structure, if so utilize the key in the retrieval. Multiple keys may be
   *;1; returned from extract-key-?. They will be handled properly in the individual retrieve functions.*
  ;;
  (multiple-value-setq (index-name key-value current-storage-structure current-key)
    (extract-key relation-name current-attributes current-key current-domains current-storage-structure
 where-clause (nth 19 keyword-values)))
  (setf tuple (funcall (find-symbol (concatenate 'string "RETRIEVE-" current-implementation-type
   "-" current-storage-structure) *pkg-string*)
       relation-name current-attributes project-list current-key where-clause key-value
       index-name))
  (if (not (equal project-list actual-project-list))
      (multiple-value-setq (tuple project-list actual-project-list)
(calculate-attributes tuple project-list actual-project-list)))
  (if (and (nth 17 keyword-values) tuple)
      (setf tuple (unique-tuples tuple)))
  ;;
  ;;1  Sort the results with either the quick-sort or the sort method before proceeding if so requested*
  ;;
  (cond ((and sort tuple)
 (if (null (setf tuple (process-sort tuple sort project-list actual-project-list current-attributes
current-domains)))
     (return-from retrieve-internal nil)))
((and quick-sort tuple)
 (if (null (setf tuple (process-quick-sort tuple quick-sort actual-project-list)))
     (return-from retrieve-internal nil))))
  (cond (tuple
 ;;
 ;;1  If the final project list is not the same as the current project list, project the results a final time. This can occur if sort*
 ;1; attributes were not contained in the project list.*
 ;;
 (setf final-project-list nil)
 (setf actual-project-list (or (convert-attributes (nth 1 keyword-values)) current-attributes))
 (if (not (listp actual-project-list))
     (setf actual-project-list (list actual-project-list)))
 (do ((project-list actual-project-list (cdr project-list)))
     ((null project-list) t)
   (cond ((and (listp (car project-list))
       (not (member (string-upcase (caar project-list)) current-attributes
    :test 'string-equal)))
  (setf final-project-list (append final-project-list
   (list (string-upcase (caar project-list))))))
 ((and (not (listp (car project-list)))
       (member (car project-list) current-attributes :test 'string-equal))
  (setf final-project-list (append final-project-list (list (car project-list)))))))
 (cond ((null (car project-list))
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR - There are no legal attributes contained in the PROJECT clause"))
(return-from retrieve-internal nil))
       ((not (equal project-list final-project-list))
(setf tuple (project-list tuple project-list final-project-list))
(setf project-list final-project-list)))))
  ;;
  ;;1  Determine if the results of the retrieval should be piped into a relation. If so, do the proper things. The user specified value of the
   *;1; keyword INTO is in the 0th position in the keyword-values list. This value is the name of the relation into which the results are placed.*
  ;;
  (setf into (validate-sym (nth 0 keyword-values)))
  (cond (into
 (if (null (retrieve-into relation-name into tuple project-list actual-project-list current-key
  current-implementation-type current-storage-structure tuple-format
  keyword-list current-attributes))
     (return-from retrieve-internal nil)))
((nth 0 keyword-values)
 (return-from retrieve-internal nil)))
  ;;
  ;;1Later, we will have to define a temporary relation and not print these tuples.*
  ;;
  (cond (qprint
 (do ((tuple tuple (cdr tuple)))
     ((null tuple) t)
   (format *standard-output* "~%~s" (car tuple))))
((or print output-file-name stream)
 (setf project-list (unconvert-attributes project-list))
 (if into
     (setf tuple-format (or (nth 5 keyword-values) tuple-format)))
 (printrel-internal* (or into relation-name) tuple project-list number-per-line number-per-line stream
     output-file-name
     (if (<= (length project-list) (length tuple-format))
 tuple-format
 (append tuple-format (make-list (- (length project-list)
    (length tuple-format)) ':initial-element
 *default-anyp-width*)))
     t t
     (caar (qtrieve 'system-relation *system-relation-attributes* '("CARDINALITY")
    *system-relation-key*
    `(string-equal relation-name
   ,(string-upcase (or into relation-name)))))
     print return-tuples)))
  ;;
  ;;1 Return the resultant relation (either INTO or TEMPORARY) We want the option of having either a relation name returned or the tuples
   *;1; returned. For now, if a into is provided, the relation name is returned, otherwise the tuples will be returned. This will have to be
   *;1; modified in the future to handle the creation of a relation in which the user does not specify a name.*
  ;;
  (cond ((and (null return-tuples) *provide-status-messages*)
 (cond ((car (errset (send *output-window* ':exposed-p) nil))
(send *output-window* ':append-item (format nil "~s tuple~:P retrieved" (length tuple)))
(send *output-window* ':append-item " "))
       (stream
(terpri stream)
(format stream "~%~s tuple~:P retrieved" (length tuple)))
       (t
(terpri)
(format *standard-output* "~%~s tuple~:P retrieved" (length tuple))))
 (return-from retrieve-internal (or into relation-name)))
(t
 (if return-tuples (return-from retrieve-internal tuple))))
  (return-from retrieve-internal relation-name)))


(defun retrieve-flavor-hash (relation-name attribute-list project-list key where-clause key-value-list
     index-name)
  (retrieve-hash relation-name attribute-list project-list key where-clause key-value-list "flavor" index-name))

(defun retrieve-flavor-heap (relation-name attribute-list project-list key where-clause heap-traversal
     index-name)
  heap-traversal
  (cond (index-name
 (qtrieve-flavor-heap index-name attribute-list project-list key where-clause))
(t
 (qtrieve-flavor-heap relation-name attribute-list project-list key where-clause))))

(defun retrieve-hash (relation-name attribute-list project-list key where-clause key-value imp index-name
      &aux retrieve-bucket hash-relation temp-attribute-list conv-attribute-list
      (tuple-list nil))
   imp key
   (block retrieve-hash
   (cond ((not (listp where-clause))
  (if (eval where-clause)
      (setf where-clause t)
      (return-from retrieve-hash nil))))
   (setf hash-relation (getp index-name 'entry-point))
   (cond ((null key-value)
  ;;
  ;;1  There is not a key to use, therefore we have to look at the entire relation*
  ;;
  (maphash (function (lambda (key-val tuples)
key-val
(setf tuple-list (append tuples tuple-list))))
    hash-relation))
 (t
  ;;
  ;;1 Ay least one key has been extracted from the where clause. Select the buckets indicated by the keys and evaluate them*
  ;1; with respect to the where clause*
  ;;
   (do ((key-value% key-value (cdr key-value%)))
       ((null key-value%) t)
     (setf tuple-list (append tuple-list (gethash (car key-value%) hash-relation))))))

   ;1;*
   ;1;  The eval-where and project-list functions were put into this loop in an attempt to perserve memory at the expense of speed. This
    *;1; will not work for array-hash.*
   ;1;*
   (cond ((string-equal (string-upcase imp) "FLAVOR")
  (setf conv-attribute-list (project-flavor-prereq attribute-list))
  (setf tuple-list (fast-project-flavor tuple-list conv-attribute-list)))
 ((string-equal (string-upcase imp) "STRUCT")
  (setf conv-attribute-list (unconvert-attributes (mapcar #'(lambda (attr)
      (concatenate 'string
   (string relation-name)
   attr))
  attribute-list)))
  (setf tuple-list (fast-project-struct tuple-list conv-attribute-list))))
   (cond ((not (equal where-clause t))
  (multiple-value-setq (where-clause  temp-attribute-list)
    (eval-where-prereq where-clause attribute-list relation-name))
  (setf tuple-list (fast-eval-where tuple-list where-clause temp-attribute-list))))
   (cond (tuple-list
  (setf tuple-list (project-list tuple-list attribute-list project-list))
  (setf retrieve-bucket(append tuple-list retrieve-bucket))))
   (return-from retrieve-hash retrieve-bucket)))

(defun fast-project-struct (tuples attribute-list)
  (mapcar (function (lambda (tuple)
      (mapcar (function (lambda (attr)
  (funcall attr tuple)))
    attribute-list)))
  tuples))

(defun retrieve-list-avl (relation-name attribute-list project-list key where-clause key-value-list index-name)
  (retrieve-avl relation-name attribute-list project-list key where-clause key-value-list "LIST" index-name))

(defun retrieve-flavor-avl (relation-name attribute-list project-list key where-clause key-value-list
    index-name)
  (retrieve-avl relation-name attribute-list project-list key where-clause key-value-list "FLAVOR" index-name))

(defun retrieve-struct-avl (relation-name attribute-list project-list key where-clause key-value-list
    index-name)
  (retrieve-avl relation-name attribute-list project-list key where-clause key-value-list "2STRUCT*" index-name))

(defun retrieve-list-hash (relation-name attribute-list project-list key where-clause key-value-list index-name)
  (retrieve-hash relation-name attribute-list project-list key where-clause key-value-list "LIST" index-name))

(defun retrieve-list-heap (relation-name attribute-list project-list key where-clause heap-traversal index-name)
  heap-traversal
  (cond (index-name
 (qtrieve-list-heap index-name attribute-list project-list key where-clause))
(t
 (qtrieve-list-heap relation-name attribute-list project-list key where-clause))))

(defun retrieve-struct-hash (relation-name attribute-list project-list key where-clause key-value-list
     index-name)
  (retrieve-hash relation-name attribute-list project-list key where-clause key-value-list "STRUCT" index-name))

(defun retrieve-struct-heap (relation-name attribute-list project-list key where-clause heap-traversal
     index-name)
  heap-traversal
  (if index-name
      (qtrieve-struct-heap relation-name attribute-list project-list key where-clause
   (getp index-name 'entry-point))
      (qtrieve-struct-heap relation-name attribute-list project-list key where-clause)))

1(*defun select-tuples (relation-name &rest keyword-list
      &key &optional directory documentation format implementation-type into key number output
      print qprint quick-sort sort stream storage-structure tuples unique where wide
      &allow-other-keys)
  "Same as Retrieve except that all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved."
  directory documentation format implementation-type into key number output print qprint quick-sort sort stream
  storage-structure tuples unique where wide
  (retrieve relation-name (append (list 'project nil) keyword-list)))

(defun sort-list (tuples sort-clause attribute-list domain-list
  &aux (avl-tree nil) domain (key-list nil) key-value-list new-element relation-name
  (sort-order nil) sort-element% (already-sorted-p nil))
  (block sort-list
;;
;;1  Validate the sort-clause and form the insertion key*
;;
(cond ((equal sort-clause t)
       (setf sort-clause nil)
       (setf key-list attribute-list))
      ((and (not (listp sort-clause)) sort-clause)
       (setf sort-clause (list sort-clause)))
      ((listp (car sort-clause))
       (setf sort-clause (car sort-clause))))
;;
;;1  For version 0.0, ascending or decending order may only be specified for the tuples as a whole not on each attribute. This*
;1; restriction will go away soon.*
;;
(if (null (do ((sort-element sort-clause (cdr sort-element)))
      ((null sort-element) t)
    (if (null (setf sort-element% (validate-sym (car sort-element) t)))
(return-from sort-list nil))
    (cond ((member sort-element% attribute-list :test 'string-equal)
   ;;
   ;;1  Determine the domain for this attribute*
   ;;
   (setf domain (nth (- (length domain-list)
(length (member sort-element% attribute-list
:test 'string-equal)))
     domain-list))
   (setf key-list (append key-list (list sort-element%)))
   (cond ((not (member domain '("NUMBERP" "STRINGP" "ATOM") :test 'string-equal))
  (return-from sort-list (setf already-sorted-p (quick-sort tuples sort-clause
     attribute-list))))))
  ((member sort-element% '("ASC" "GT" "GTE" "GE" "INCREASING" "DES" "DESC"
   "DECREASING" "LT" "LTE" "LE") :test 'string-equal)
   (setf sort-order (or sort-order sort-element%)))
  (t
   (cond (*provide-warning-messages*
  (format *standard-output*
  "~%WARNING - ~s is not an attribute nor a recognized sort keyword"
  sort-element%)
  (format *standard-output* "~%          This element will be ignored")))))))
    (return-from sort-list nil))
(if already-sorted-p
    (return-from sort-list already-sorted-p))
(cond ((null key-list)
       (cond (*provide-error-messages*
      (format *standard-output* "~%ERROR - No attributes specified in the sort clause --> ~s"
      sort-clause)
      (format *standard-output* "~%        Sort can not proceed")))
       (return-from sort-list nil)))
;;
;;1  Loop through each tuple inserting each into the AVL tree based on the key*
;;
(setf key-value-list (project-list tuples attribute-list key-list)
      domain-list (car (project-list (list domain-list) attribute-list key-list))
      relation-name (read-from-string (concatenate 'string *pkg-string* "-TEMP-"
   (string (gensym)))))
(do ((tuples tuples (cdr tuples))
     (key-value-list key-value-list (cdr key-value-list)))
    ((null tuples) t)
  (setf new-element (cons (list (car tuples)) (append (list 0) (list nil) (list nil)))
avl-tree (insert-avl-list new-element avl-tree (car key-value-list) key-list attribute-list
  domain-list nil relation-name)))
;;
;;1  Convert from an AVL tree to a simply list-heap structure*
;;
;;1  Should determine if this relation might some how exist...later*
;;
(putp relation-name avl-tree 'entry-point)
(setf tuples (retrieve-list-avl relation-name attribute-list attribute-list key-list t nil
relation-name))
(putp relation-name nil 'entry-point)
;;
;;1  Place the tuples in the final order*
;;
(cond ((member sort-order '("DES" "DESC" "DECREASING" "LT" "LTE" "LE") :test 'string-equal)
       (setf tuples (reverse tuples))))
(return-from sort-list tuples)))

(defun maptuple (dbfunction relation)
  "Map a function on all the tuples in a relation using MAPCAR.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation."
  (block maptuple
(if (not (active-database))
    (return-from maptuple nil))
(cond ((null (car (errset (functionp dbfunction) t)))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - Illegal function definition"))
       (return-from maptuple nil)))
(if (not (setf relation (validate-sym relation)))
    (return-from maptuple nil))
(return-from maptuple (mapcar (function (lambda (tuple)
    (funcall dbfunction tuple)))
(retrieve relation 'tuples t)))))

(defun mapt (dbfunction relation)
  "Map a function on all the tuples in a relation using MAPC.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation."
  (block mapt
(if (not (active-database))
    (return-from mapt nil))
(cond ((null (car (errset (functionp dbfunction) t)))
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - Illegal function definition"))
       (return-from mapt nil)))
(if (not (setf relation (validate-sym relation)))
    (return-from mapt nil))
(mapc (function (lambda (tuple)
  (funcall dbfunction tuple)))
      (retrieve relation 'tuples t))
(return-from mapt relation)))

(defun print-relation (relation &rest keyword-list
       &key &optional directory documentation format implementation-type index-name into key
       number output print qprint quick-sort sort stream storage-structure tuples unique wide
       &allow-other-keys)
  "Same as Retrieve without a where clause and all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved."
  directory documentation format implementation-type into key number output print qprint quick-sort sort stream
  storage-structure tuples unique wide index-name
  (retrieve relation keyword-list))

(deff printrel 'print-relation)

(defun project (relation-name &rest keyword-list
&key &optional directory documentation format implementation-type index-name into key number
output print project qprint quick-sort sort stream storage-structure tuples unique wide
&allow-other-keys)
  "Same as Retrieve except that all tuples are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved."
  directory documentation format implementation-type into key number output print project qprint quick-sort
  sort stream storage-structure tuples unique wide index-name
  (retrieve relation-name (append (list 'where t 'unique t) keyword-list)))

(defun attr-calc (calc-list attribute-list
  &aux new-calc-list new-calc-element result result-element)
  (cond ((and (functionp calc-list) (not (member (string-upcase calc-list) attribute-list :test 'string-equal)))
 (setf new-calc-list calc-list))
((or (symbolp calc-list) (stringp calc-list))
 (if (member (setf new-calc-element (string-upcase calc-list)) attribute-list :test 'string-equal)
     (setf result (push new-calc-element result)
   new-calc-list (read-from-string new-calc-element))
     (setf new-calc-list calc-list)))
((listp calc-list)
 (mapc #'(lambda (x)
   (multiple-value-setq (result-element new-calc-element)
     (attr-calc x attribute-list))
   (setf result (append result result-element)
 new-calc-list (append new-calc-list (list new-calc-element))))
       calc-list))
(t
 (setf new-calc-list calc-list)))
  (values result new-calc-list))

(defun quick-sort-prereq (quick-sort a-p-l &aux (result nil))
  (block quick-sort-prereq
  (maplist #'(lambda (attr &aux attr%)
       (cond ((null (setf attr% (validate-sym (car attr) t)))
      (setf result nil)
      (return-from quick-sort-prereq nil)))
       (cond ((member attr% '("LT" "LTE" "LE" "DECREASING" "DESC" "DES""GT" "GTE" "GE" "INCREASING"
      "ASC") :test 'string-equal))
     ((and (member (validate-sym (cadr attr) t) '("LT" "LE" "LTE" "DECREASING" "DESC" "DES")
    :test 'string-equal)
   (member attr% a-p-l :test 'string-equal))
      (setf result (append result (list (list attr% 'dbgtp)))))
     ((and (member (validate-sym (cadr attr) t) '("GT" "GE" "GTE" "INCREASING" "ASC")
    :test 'string-equal)
   (member attr% a-p-l :test 'string-equal))
      (setf result (append result (list attr%))))
     ((and (or (not (listp attr%)) (equal (length attr%) 1))
   (member attr% a-p-l :test 'string-equal))
      (setf result (append result (list attr%))))
     (t (prog2
  (if *provide-warning-messages*
      (format *standard-output* "~%WARNING - ~S is neither a valid quick-sort keyword nor an attribute." attr%))
  nil))))
   quick-sort)
  (return-from quick-sort-prereq result)))

(defun retrieve (relation-name &rest keyword-list
 &key &optional directory documentation format implementation-type index-name into key number
 output print project qprint quick-sort sort stream storage-structure tuples unique where wide
 &allow-other-keys)
  "Retrieve some tuples from a relation satisying a where clause.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved. "
  directory documentation format implementation-type into key number output print project qprint quick-sort
  sort stream storage-structure tuples unique where wide index-name
  (retrieve-internal relation-name keyword-list))


(defun parse-project (relation-name *current-attributes* project-list *current-tuple-format* tuple-format
      &aux a-p-l new-attr actual-project-list temp-tuple-format project-element new-attr-part2)
  ;;
  ;;1We will have to process the project-list to make sure that the attributes specified are valid and to take care of the calculated*
  ;1; attributes.*
  ;;
  (setf a-p-l (convert-attributes project-list)
project-list nil)
  (do ((a-p-l a-p-l (cdr a-p-l))
       (tuple-format tuple-format (cdr tuple-format)))
      ((null a-p-l) t)
    (setf new-attr (car a-p-l))
    (cond ((and (not (listp new-attr)) (member new-attr *current-attributes* :test 'string-equal))
   ;;
   ;;1  The current element is an attribute of the current relation, no further processing is required, therefore the project and*
   ;1; tuple format lists can be completed.*
   ;;
   (push new-attr actual-project-list)
   (push new-attr project-list)
   (push (cond ((null tuple-format)
(nth (- (length *current-attributes*) (length (member new-attr *current-attributes*
       :test 'string-equal)))
     *current-tuple-format*))
       (t
(car tuple-format)))
 temp-tuple-format))
  ((not (listp new-attr))
   ;;
   ;;1  The element is not a list and it is not an attribute of the current relation therefore we have need to warn the user. This*
   ;1; element will not be included in the final solution*
   ;;
   (if (and (validate-sym new-attr t) *provide-warning-messages*)
       (format *standard-output* "~%WARNING - ~s is not an attribute of the ~s relation"
       new-attr relation-name)))
  ;;
  ;;1  If the second element of the new-attr list does not exist then this element is specified incorrectly*
  ;;
  ((not (second new-attr))
   (if *provide-warning-messages*
       (format *standard-output* "~%WARNING - Improperly specified project element ~s."
       (first new-attr))))
  ;;
  ;;1  The first element of the new-attr list must not be the name of an attribute in the current relation*
  ;;
  ((member (string-upcase (first new-attr)) *current-attributes* :test 'string-equal)
   (cond (*provide-warning-messages*
  (format *standard-output* "~%WARNING - Improperly specified project element ~s." new-attr)
  (format *standard-output* "~%          ~s is an attribute of the ~s relation."
  (first new-attr) relation-name))))
  ((listp (second new-attr))
   ;;
   ;;1  The second element of the new-attr is a list, indicating that this element is possibly true calculated attribute, further*
   ;1; checking is needed. In any case, it is not simply a rename*
   ;;
   ;;
   ;;1 Determine the tuple format for the current calculated attribute*
   ;;
   (push (cond ((null tuple-format)
(if (member (string-upcase (first new-attr)) *current-attributes* :test 'string-equal)
    (nth (+ 1 (- (length *current-attributes*)
 (length (member (string-upcase (first new-attr))
 *current-attributes* :test 'string-equal))))
 *current-tuple-format*)
    *default-anyp-width*))
       (t
(car tuple-format)))
 temp-tuple-format)
   (multiple-value-setq (project-element new-attr-part2)
     (attr-calc (second new-attr) *current-attributes*))
   (setf project-list (append project-element project-list))
   (push (append (list (first new-attr)) (list new-attr-part2)) actual-project-list))
  ;;
  ;;1  The second element of new-attr is not a list, therefore it must either be a rename attribute request or a output attribute*
  ;1; with a constant value*
  ;;
  (t
   ;;
   ;;1  The second element of the current list is not a list therefore it must be either a renamed attribute or a new attribute*
   ;1; which is assigned a constant value.*
   ;;
   (cond ((not (member (string-upcase (second new-attr)) *current-attributes* :test 'string-equal))
  ;;
  ;;1  The second element is not an attribute from the current relation, nothing more to be done here except setting*
  ;1; the tuple format for this element*
  ;;
  (push new-attr actual-project-list)
  (push (cond ((null tuple-format)
       *default-anyp-width*)
      (t
       (car tuple-format)))
temp-tuple-format))
 (t
  ;;
  ;;1  The second element is an attribute in the current relation so the element indicates that the attribute is going to*
  ;1; be renamed. Set the appropriate lists.*
  ;;
  (push (list (first new-attr) (second new-attr)) actual-project-list)
  ;;
  ;;1  Modify the value of new-attr in the process so that the string conversion only has to be done once*
  ;;
  (setf new-attr (string-upcase (second new-attr)))
  (push new-attr project-list)
  (push (cond ((null tuple-format)
       (if (member new-attr *current-attributes* :test 'string-equal)
   (nth (- (length *current-attributes*)
   (length (member new-attr *current-attributes* :test 'string-equal)))
     *current-tuple-format*)
   *default-anyp-width*))
      (t
       (car tuple-format)))
temp-tuple-format))))))
  (setf actual-project-list (reverse actual-project-list)
temp-tuple-format (reverse temp-tuple-format))
  ;;
  ;;1Get rid of duplicate elements in project-list*
  ;;
  (setf a-p-l project-list
project-list nil)
  (mapc (function (lambda (attr)
    (if (not (member attr project-list :test 'string-equal))
(push attr project-list))))
a-p-l)
  (values (convert-attributes project-list) actual-project-list temp-tuple-format))

(defun unconvert-attributes (attribute-list &optional (package-name *pkg-name*))
  (mapcar (function (lambda (attribute)
      (cond ((or (symbolp attribute) (stringp attribute))
     (read-from-string (concatenate 'string package-name ":" (string attribute))))
    (t
     attribute))))
  attribute-list))

(defun calculate-attributes (tuple project-list actual-project-list
     &aux result element)
  ;;
  ;;1  If the project-list contains a aggregrate function, modify the value contained in the actual project list*
  ;;
  (setf actual-project-list
(mapcar #'(lambda (x)
    (cond ((not (listp x))
   x)
  ((listp (second x))
   (list (car x) (third (parse-where (list 'equal 'x (second x))))))
  (t
   x)))
actual-project-list))
  (progv (unconvert-attributes project-list) nil
    (mapc (function (lambda (%tuple)
      ;;
      ;;1  Take each attribute contained in the attribute list and make a variable out of it. The value which represents*
      ;1; that attribute in the current tuple is assigned to the appropriate variable.*
      ;;
      (do ((att-list project-list (cdr att-list))
   (val-list %tuple (cdr val-list)))
  ((null att-list) t)
(set (read-from-string (car att-list)) (car val-list)))
      ;;
      ;;1 Substitute values for expressions*
      ;;
      (setf result (cons (mapcar (function (lambda (attr)
     (cond ((not (listp attr))
    (symbol-value (read-from-string
    (string attr))))
   ((listp attr)
    ;;
    ;;1  If the second element is a symbol and it is one of*
    ;1; the attributes from the relation, rid it of any*
    ;1; package indicators*
    ;;
    (cond ((and (symbolp (second attr))
(member (string-upcase
  (second attr))
project-list
 :test 'string-equal))
   (setf element (read-from-string
   (string-upcase
     (second attr)))))
  (t
   (setf element (second attr))))
    (if (or (stringp (car attr))
    (symbolp (car attr)))
(set (read-from-string
       (string (car attr)))
     (eval element))
(eval element))))))
 actual-project-list)
 result))))
  tuple))
  (setf project-list (mapcar (function (lambda (x)
 (if (not (listp x))
     (string-upcase x)
   (string-upcase (car x)))))
     actual-project-list))
  (setf result (nreverse result))
  (values result project-list actual-project-list))

(defun retrieve-into (relation-name into tuple project-list actual-project-list current-key
      current-implementation-type current-storage-structure tuple-format keyword-list
      current-attributes
      &aux temp a-p-l old-values final-project-list)
  (block retrieve-into
(setf temp (car (qtrieve 'system-relation *system-relation-attributes* '("ATTRIBUTES")
 *system-relation-key*
 `(string-equal relation-name ,(string into)))))
(if (null temp)
    (progn
      ;;1Form the attribute descriptor pair. Consider one attribute at a time and get the descriptor values from the*
      ;1; system-attribute relation. Also, if any of the key attributes are not part of the projected attributes, we will reset the*
      ;1; key to the entire list of projected attributes.*
      (setf temp actual-project-list
    a-p-l nil)
      (mapc (function (lambda (attr &aux attd)
(setf attd (car (qtrieve 'system-attribute *system-attribute-attributes*
 '("DOMAIN-FUNCTION" "DEFAULT-VALUE" "DOC")
 *system-attribute-key*
 (list 'and  (list 'string-equal 'relation-name
   (string relation-name))
       (list 'string-equal 'attribute-name
     (string-upcase (if (not (listp attr))
attr
(if (not (listp
   (cadr
     attr)))
    (cadr attr)
    nil))))))))
(if attd
    (setf a-p-l (append a-p-l (list (if (not (listp attr))
attr
(car attr))
    (list 'dom (first attd) 'def (second attd)
  'doc (if (not (listp attr))
   (third attd)
   nil)))))
    (setf a-p-l (append a-p-l (list (if (not (listp attr))
attr
(car attr))
    (list 'dom 'anyp)))))
(setf final-project-list (cons (if (listp attr)
  (string-upcase (car attr))
  attr) final-project-list))))
    temp)
      (let ((result nil))
(setf current-key (if (dolist (%attribute (or (car (get-keyword-value '(key) keyword-list))
      current-key) result)
(if (member %attribute final-project-list :test 'string-equal)
    (setf result %attribute)
    (return-from retrieve-into nil)))
      (or (car (get-keyword-value '(key) keyword-list)) current-key)
      (list (car (reverse final-project-list))))))
      (if (null (defrel into a-p-l
  (list
    'imp (or (car (get-keyword-value '(imp) keyword-list))
     current-implementation-type)
    'sto (or (car (get-keyword-value '(sto) keyword-list)) current-storage-structure)
    'key current-key
    'format (or (car (get-keyword-value '(format) keyword-list)) tuple-format)
    'dir (car (get-keyword-value '(dir) keyword-list))
    'doc (car (get-keyword-value '(doc) keyword-list)))))
  (return-from retrieve-into nil)))
  (if (equal (length (setf temp (car temp))) (length actual-project-list))
      (mapc (function (lambda (attr-rel attr-into &aux temp-d)
(if (listp attr-rel)
    (setf attr-rel (first attr-rel)))
(cond ((not (member attr-rel current-attributes :test 'string-equal)))
      ;;1It is a projected (calculated) attribute.*
      ((not
 (or (equal (caar (qtrieve 'system-attribute
   *system-attribute-attributes*
   '("DOMAIN-FUNCTION")
   *system-attribute-key*
   (list 'and
 (list 'string-equal 'relation-name
       (string-upcase relation-name))
 (list 'string-equal 'attribute-name
       (string-upcase attr-rel)))))
    (setf temp-d (caar (qtrieve 'system-attribute
*system-attribute-attributes*
'("DOMAIN-FUNCTION")
*system-attribute-key*
(list 'and
      (list 'string-equal
    'relation-name
    (string-upcase
      into))
      (list 'string-equal
    'attribute-name
    (string-upcase
      (if (not (listp
    attr-into))
  attr-into
  (car
    attr-into)
  ))))))))
     (string-equal temp-d "ANYP")))
       (if *provide-error-messages*
   (format *standard-output*
   "~%ERROR - The attribute ~S in relation ~S and the attribute ~S in the output relation ~S have different domain predicates." attr-rel relation-name attr-into into))
       (return-from retrieve-into nil)))))
    actual-project-list temp)
      (progn
(if *provide-error-messages*
    (format *standard-output*
    "~%ERROR - The output relation ~S does not have all the attributes required to insert the retrieved tuples. ~S has ~S as attributes and the retrieve call requires ~S attributes in the relation ~S to be projected."
    into into temp project-list relation-name))
(return-from retrieve-into nil))))
(setf old-values (list *provide-error-messages* *validity-checking*))
(setf *provide-error-messages* nil
      *validity-checking* nil)
(insert into (list 'tuples tuple))
(setf *provide-error-messages* (car old-values)
      *validity-checking* (cadr old-values))
(return-from retrieve-into relation-name)))


(defun unique-tuples (tuples &aux result-table)
  (setf result-table (make-hash-table :test 'equal))
  (mapc #'(lambda (x &aux hash-bucket)
  (cond ((setf hash-bucket (gethash x result-table))
 (cond ((not (member x hash-bucket))
(puthash x (cons x hash-bucket) result-table))))
(t
 (puthash x x result-table))))
tuples)
  (setf tuples nil)
  (maphash #'(lambda (x y)
     y
     (setf tuples (cons x tuples)))
   result-table)
  tuples)
-TYPE  - Name of the new implementation type.
  STORAGE-STRUCTURE    - Name of the new storage-structure.
  FORMAT               - List of new print-width values to be used for the attributes.
  KEY                  - List of attributes to form the new key for this relation.
  DOCUMENTATION        - New description of this relation.
  DIRECTORY            - New directory in which this relation is to be saved.  (MODIFY-RELATION RELATION &REST KEYWORD-LIST &KEY &OPTIONAL RELATION-NAME ADD-ATTRIBUTES DELETE-ATTRIBUTES RENAME-ATTRIBUTES IMPLEMENTATION-TYPE STORAGE-STRUCTURE FORMAT KEY DOCUMENTATION DIRECTORY &ALLOW-OTHER-KEYS)BBl~SB	BÁADD-ATTRIBUTESCDELETE-ATTRIBUTESCRENAME-ATTRIBUTESBBBBBBBBB	PAPPPQPQPQ	PQ
PQPQPQPQPQPQPQJ@AQ@QO	B
	1\B\B\B8\BLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540824. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "XLD" :NAME "RETRIEVE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360396. :AUTHOR "REL3" :LENGTH-IN-BYTES 13504. :LENGTH-IN-BLOCKS 27. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         pp2\COMPILE-DATA\SW-MFG,GODZILLAFF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8,RETRIEVE\B8LISP\B8FFONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*BASEF
)PACKAGERTMSMODECOMMON-LISPOBTAIN-PROJECT-&-FORMATIAFT$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\ÁRELATION-NAMEPROJECT-LISTTUPLE-FORMATCSORT-LIST*CURRENT-ATTRIBUTES*Â*CURRENT-TUPLE-FORMAT*B:\ÀA-P-LACTUAL-PROJECT-LISTCFINAL-PROJECT-LISTÀITEMSCTEMP-TUPLE-FORMATB:B:B:ATTRB:CATTRIBUTE\)MACROS-EXPANDED\PROGpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSSETFpB\,*APPENDpBTFIRSTNҪLISTFÁPARSE-PROJECTҪSTRING-EQUALpB\MEMBER-TESTjCOPY-LISTQAQBQQCQCcCvQCQQ
CsC?rQCQl5Q5QQQQQQPPADAEAQGFFQGSHH5HQHSCFGGEQ@QC@QCxQ
J@QCQCcC,QBGGуQEI"IQESJÁQP	JQQP	QJQAQJQAJQ
CIEEDQQQAQBQOBPOBTAIN-SORT	1k@	F:$B:BV]FB:B:B:BYFB^B\SORTCQUICK-SORTB:B:\Bo\BqBtBvBw*PROVIDE-ERROR-MESSAGES*B|҃VALIDATE-SYMTERPRI,ERROR - Illegally specified sort clauseWRITE-STRING5Q
5S5S5Q
5S5S@рQBAAQBSCABB@Qۀ$PBBсQ@CCQ@SCC@@BQہP߀QQOBOBTAIN-WIDE	1@	F$B:BV]FB:B:B:BYFB^B\ÀWIDEPNUMBER-PER-LINEB:\ÀSTATUS\Bo\BwBB,ERROR - BPRIN1Ҭ is not a legal number specification@݀ 1QL5S1QPQP@@QQOBCPROCESS-QUICK-SORT>@F#$B:BV]FB:B:B:BYFB^B\ÀTUPLEBBhB:\BgB:B:B:BlB:\Bo\BqBtBvBwSTRING\BY\BYCQUICK-SORT-PREREQBBAтQCBBQCSDD5DQDSCBCCAQ@QCCсQAEEQASCEAACQ@QQQ@QROBPROCESS-SORT2AF$B:BV]FB:B:B:BYFB^B\BB
BaBhBdC*CURRENT-DOMAINS*B:\DOMAINSCKEY-VALUEATTR-POSBl\Bo\BwBqBBҬANYP*REVERSEBcQCQCCSB5BQBSBÄQPCcA	BQQPAQQCP@]@C@Q@QQQ@QOBCCONVERT-ATTRIBUTES(@PF$B:BV]FB:B:B:BYFB^B\ÁATTRIBUTE-LISTB:\B:B:B:Bm\Bo\BqBtBvBwB|BSTRING-UPCASER5Q@рQBAAQBSCCQC7CQCQCABB@OBEXTRACT-KEY-HEAP@F$B:BV]FB:B:B:BYFB^B\BKEY-LISTBǃWHERE-CLAUSEPACKAGE-NAMEB:B:B:ROBCRETRIEVE-INTERNALTdTF\$B:BV]FB:B:B:BYFB^B\B`KEYWORD-LISTB:\ BCCURRENT-ATTRIBUTESCURRENT-DOMAINSCURRENT-KEYCURRENT-IMPLEMENTATION-TYPECCURRENT-STORAGE-STRUCTUREBhCURRENT-TUPLE-FORMATBiBȃINTOBaBPRINTÀQPRINTSTREAMOUTPUT-FILE-NAMEBbBÁRETURN-TUPLESB
CARDRETRIEVE-INDEX-NAMEBÁKEYWORD-VALUESBCINDEX-NAMEB:BaBB:B:\Bo\pBTSENDpBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETBqpB\lXR-BQ-LIST*SEVENTHSIXTHFIFTHFOURTHTHIRDSECONDFIRSTBw AplEH*CONDITION-HANDLERS**OUTPUT-WINDOW*C*PROVIDE-STATUS-MESSAGES*Â*SYSTEM-RELATION-KEY*у*SYSTEM-RELATION-ATTRIBUTES*у*DEFAULT-ANYP-WIDTH*C*SYSTEM-INDEX-KEY*C*SYSTEM-INDEX-ATTRIBUTES*у*PKG-STRING*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION*у*ACTIVE-DB*Bу*PARAMETER-CHECKING*ACTIVE-DATABASEB\lATTRIBUTES,DOMAINSKEYIMPLEMENTATION-TYPElSTORAGE-STRUCTURETUPLE-FORMATCARDINALITYGET-RELATIONBlERROR - Relation BB, does not exist in the database \BPROJECTÀWHEREBÀOUTPUTFORMATNUMWIDEBBB
BDIRDOCKEYIMPSTOÀUNIQUEBBGET-KEYWORD-VALUE-PREREQ҃DE-NEST-KEYWORD-LISTCGET-KEYWORD-VALUEBlRETRIEVE-l-CONCATENATEҪFIND-SYMBOL҃SYSTEM-INDEX\lINDEX-NAMEANDBB`BB|B,ERROR - , is not a defined index on the relation BFBB҆BPERROR - There are no legal attributes contained in the PROJECT clauseEXTRACT-KEYFCALCULATE-ATTRIBUTESÁUNIQUE-TUPLESBBBBByBaÁRETRIEVE-INTO҃UNCONVERT-ATTRIBUTESSYSTEM-RELATION\CARDINALITYQTRIEVECPRINTREL-INTERNAL*p,G7239FERRORpB\ERRSET-HANDLERiEXPOSED-PAPPEND-ITEM~s tuple~:P retrievedB=l ,~%~s tuple~:P retrieved tupleesjWRITE-CHARl retrievedQRQP@@	PQPPR@S@W@@SA@WB@[C@QBD@UBE@YBG@QBBUPQQPQXJXQCV0.P PP!PP"P#[$PP%P
P&P'P(PQ)*'P+PVQ)**$PJ[BV,PJXQC-PQRX[LXQBMJXQCPJXQCN	JXQCSJXQCOMS.PMSMJXQCJXQC/P0PARYR
JXQCJXQC/P1PAWTJW'RQXWJXQCTQWQAQGQ2P3PAHFQKK4PRKRQAQCQBQEQLQJXQC5P6PACEIZP PDQ!PEQ"P#[QAQKQCQLQIQZQJ[@KQF+	@QKQFQ7P8PAFK@JXQ@@Q9@T@
@QTQKQFQAQBQ:@RW@E@QWQFQ;@>HXW<AQFF5FQ*FFQ\\S5\QB)AQ'P=HQ\QB)
\S5
\SAQ'P=HQ\S*>H\K4PRKQH+@QKQHQ?@HQKXSJQJQ@QKQFQCQDQEQQQQAQJ@RXRN	@Q]D]S]>MPO8KQAKJJXQCQQQJQQ@QKQRQRQOQPQKQQQCQQ
QQ	PKQCQQCcC>BPPCPP'P(PJQQ)*DBMQSQJESHDFPGPTHPIPFPJC^PJC_JP*J!BJ!B\P_KPLP@QCM_KPNPOOQOQOP@QCM@QCPP@QCQPRSPJQS@OrBRETRIEVE-FLAVOR-HASHF
$B:BV]FB:B:B:BYFB^Bs\B`BBaBBBÁKEY-VALUE-LISTBB:B:B:flavorÁRETRIEVE-HASHQQQQQQPQJOBsRETRIEVE-FLAVOR-HEAPF	$B:BV]FB:B:B:BYFB^B\B`BBaBBBÁHEAP-TRAVERSALBB:B:B:QTRIEVE-FLAVOR-HEAPQQQQQQOBB~2~B<FL$B:BV]FB:B:B:BYFB^B~\B`BBaBBBBBCBB:\B:B:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGRETRIEVE-BUCKETÁHASH-RELATIONTEMP-ATTRIBUTE-LISTCONV-ATTRIBUTE-LISTCTUPLE-LISTCKEY-VALUE%B:B:B:\Bo\BtBvBqBwINTERNAL-FEF-OFFSETS\FiVARIABLES-USED-IN-LEXICAL-CLOSURES\BEVAL҃ENTRY-POINTGETP\FF
\)INTERNALB~*MAPHASH*GETHASHByBFLAVORpB\STRING-EQUAL*ÂPROJECT-FLAVOR-PREREQ҃FAST-PROJECT-FLAVORSTRUCTBBBKB\҃FAST-PROJECT-STRUCTFCEVAL-WHERE-PREREQFAST-EVAL-WHEREBa5QRQPGPPCGQQKJQKSGQ	
JKQPQIJQIQQPLсQNM
MQPQNSCMNNLQIJQIQJQQQQPPAHJQQHQJJJQQQJ
FFOB~B
@F$B:BV]FB:B:B:BYFB^B\KEY-VALÀTUPLESB:\B:B:B\Bo\BwiLEXICAL-PARENT-DEBUG-INFOBByQPOBB#@F$B:BV]FB:B:B:BYFB^B\BBB:\B:B:B:BB:B:B:\Bo\BqBtBv@рQBAAQBSCDDсQFEEQCQFSCEFFDQCABB@OBCRETRIEVE-LIST-AVLF
$B:BV]FB:B:B:BYFB^B\B`BBaBBBB|BB:B:B:LISTRETRIEVE-AVLQQQQQQPQJOBRETRIEVE-FLAVOR-AVLF
$B:BV]FB:B:B:BYFB^B\B`BBaBBBB|BB:B:B:FLAVORBQQQQQQPQJOBRETRIEVE-STRUCT-AVLF
$B:BV]FB:B:B:BYFB^B\B`BBaBBBB|BB:B:B:STRUCTBQQQQQQPQJOBCRETRIEVE-LIST-HASHF
$B:BV]FB:B:B:BYFB^B\B`BBaBBBB|BB:B:B:LISTB~QQQQQQPQJOBCRETRIEVE-LIST-HEAPF	$B:BV]FB:B:B:BYFB^B\B`BBaBBBBBB:B:B:CQTRIEVE-LIST-HEAPQQQQQQOBRETRIEVE-STRUCT-HASHF
$B:BV]FB:B:B:BYFB^B\B`BBaBBBB|BB:B:B:STRUCTB~QQQQQQPQJOBRETRIEVE-STRUCT-HEAP	F$B:BV]FB:B:B:BYFB^B\B`BBaBBBBBB:B:B:BB҃QTRIEVE-STRUCT-HEAP	QQQQQQPQQQQQO(BÁSELECT-TUPLES		@F$B:BV]FB:B:B:BYFB^B)\B`&RESTB&KEYj&OPTIONALjDIRECTORYDOCUMENTATIONB=IMPLEMENTATION-TYPEBBBNUMBERB<BBBB
BCSTORAGE-STRUCTUREBBEB;B?j&ALLOW-OTHER-KEYSB:\BB5B6B=B7BBBB8B<BBBB
BB9BBEB;B?\DOCUMENTATION쿇Same as Retrieve except that all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved. \iDIRECTORYB=FORMATIMPLEMENTATION-TYPEINTOKEYNUMBEROUTPUTPRINTQPRINTiQUICK-SORTSORTSTREAMiSTORAGE-STRUCTURETUPLESUNIQUEWHEREWIDEpB\STORE-KEYARGSB:LIST*RETRIEVE@@QPAQP@QOVB)Bc$XԆA$0F|$B:BV]FB:B:B:BYFB^Bc\BSORT-CLAUSEB؃DOMAIN-LISTB:\AVL-TREEÀDOMAINBB|NEW-ELEMENTB`CSORT-ORDERÁSORT-ELEMENT%ALREADY-SORTED-PSORT-ELEMENTBB|\Bo\BqBwB(BC*PROVIDE-WARNING-MESSAGES*B|BBBBy\,NUMBERP,STRINGPATOMB\ASClGTGTElGElINCREASINGDESDESClDECREASINGlLTLTElLEBlWARNING - BBl is not an attribute nor a recognized sort keyword          This element will be ignored,ERROR - No attributes specified in the sort clause -->         Sort can not proceedBaB-TEMP-GENSYMBBK*READ-FROM-STRINGAPPENDINSERT-AVL-LISTBPUTPB\DESDESClDECREASINGlLTLTElLEB͒QۂQB5QS5SQI=ISGRGQQP	QCGQQP	CcQCABQGQ
BAQPP	QQQGQPP	FQGQF
PGQPPIHHBPQPRQQBQCQQBQBPPPEQJCQKJSJ
CD@QKSBQQQEQJ@JKJEQ@QP EQQQBQEQJ!EQP FQ"PP	Q#OBcMAPTUPLEN@F0$B:BV]FB:B:B:BYFB^B\CDBFUNCTIONRELATIONB:B:\Bo\	BqBtBvBwBBBBBB=Map a function on all the tuples in a relation using MAPCAR.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation.B BB-pBbG7595F>BfBhjFUNCTIONPB|BҬERROR - Illegal function definitionBBBBURPPTP	PPJC@PJCAրQ
J!BJ!B\PRQRAAсQPCBBQCSCBCCAOBMAPTF@F,$B:BV]FB:B:B:BYFB^B\BBB:B:\Bo\BqBtBwBBBBBB=Map a function on all the tuples in a relation using MAPC.

   DBFUNCTION  - Function to be applied to each and every tuple.
   RELATION    - Name of the relation.B BB-pBbG7635F>BfBhBB|BҬERROR - Illegal function definitionBBBBURPPTP	PPJC@PJCAրQ
J!BJ!B\PRQRQP@@S@OBÁPRINT-RELATION@F$B:BV]FB:B:B:BYFB^B\BB2BB3B4B5B6B=B7BBBBB8B<BBBB
BB9BBEB?B:B:\BB5B6B=B7BBBBB8B<BBBB
BB9BBEB?\B=
Same as Retrieve without a where clause and all attributes are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved. \BAB=BBBCiINDEX-NAMEBDBEBFBGBHBIBJBKBLBMBNBOBQBSBU@@QPAQ@QOBBOPRINTRELB:

@F$B:BV]FB:B:B:BYFB^B:\B`B2BB3B4B5B6B=B7BBBBB8B<BB:BBB
BB9BBEB?B:B:\BB5B6B=B7BBBBB8B<BB:BBB
BB9BBEB?\B=쿪Same as Retrieve except that all tuples are retrieved.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved. \BAB=BBBCBBDBEBFBGBH)PROJECTBIBJBKBLBMBNBOBQBSB;BEBTBU@@QPAQPP@Q	OB:CATTR-CALCF@F)$B:BV]FB:B:B:BYFB^B\CCALC-LISTBB:\ÁNEW-CALC-LISTNEW-CALC-ELEMENTÀRESULTÁRESULT-ELEMENTB:CX\Bo\BqBtPUSHBwBBBBBFBByB|QQQP+7QAÁQP AQCBBAQ5QDDSEÁQP	PAACBQCQ
B@QAQ
@DQ@BQ@QOBB)d@F;$B:BV]FB:B:B:BYFB^B\BBgB:\BB:B:B:ÀATTR%\Bo\PROG2BwBqBtBvBkB\lLTLTElLElDECREASINGDESCDESlGTGTElGElINCREASINGASCBB\lLTlLELTElDECREASINGDESCDESÀDBGTPB|By\lGTlGEGTElINCREASINGASCBlWARNING - BB, is neither a valid quick-sort keyword nor an attribute.AрQCBJBQDCSD@RDQPP8CWPPDQQP@QDQ	P

@$CWPPDQQP@QDQD5DQCDQQPPDQPCBCC@OBBU@F$B:BV]FB:B:B:BYFB^BU\B`B2BB3B4B5B6B=B7BBBBB8B<BB:BBB
BB9BBEB;B?B:B:\BB5B6B=B7BBBBB8B<BB:BBB
BB9BBEB;B?\B=Retrieve some tuples from a relation satisying a where clause.

   RELATION-NAME        - Name of the relation whose tuples are to be retrieved.
   WHERE                - Criterion to be used in selecting the tuples.
   PROJECT              - List of attributes to be projected in the result.
   INTO                 - If the result is to be inserted in a relation, specify the name of that relation.
                          If the above relation is not defined, RTMS defines it with the following keywords.
   DIRECTORY            - Save directory for this relation.
   DOCUMENTATION        - Documentation for this relation.
   FORMAT               - List of print widths for the attributes in this relation.
   IMPLEMENTATION-TYPE  - Name of the implementation type to be used.
   INDEX-NAME           - Name of the index to use in the retrieval.
   KEY                  - List of the resultant attributes to form the key for this relation.
   STORAGE-STRUCTURE    - Name of the storage-structure.
   WIDE                 - If T, result is printed out in Attribute: value format rather than as a table.
   NUMBER               - If WIDE is T, this keyword specifies the number of attributes per line.
   OUTPUT               - If the result is to be sent to a file, specify the file-name.
   PRINT                - If NIL, the result is not printed.
   QPRINT               - If T, the result is printed without formatting.
   QUICK-SORT           - Specifies the attributes to sort the result on.
   SORT                 - If any domain-specific, user-defined sort mechanism is to be used, this keyword
                          can be used.
   STREAM               - Specify the window to which the output is to be sent, if it is different than the
                          the *standard-output* or RTMS-interface.
   TUPLES               - If T, the resultant tuples are returned.
   UNIQUE               - If T, only unique tuples are retrieved.  \BAB=BBBCBBDBEBFBGBHBBIBJBKBLBMBNBOBPBQBSB@@QPAQ@QO BUB~i톀AhF$B:BV]FB:B:B:BYFB^B~\B`BdBaBeBbB:\
BgNEW-ATTRBhBkPROJECT-ELEMENTÁNEW-ATTR-PART2BgBbB:Bl\Bo\BtBBBBqBwB%BkBBBBBlWARNING - BBҬ is not an attribute of the l relation,WARNING - Improperly specified project element e.BpBl          , is an attribute of the l relation.FBByB|B͒Q@@QFQGFSAA5"AQQP	AQB]BAQ]GA5AQ	
PAQPQPA
~	PASPvASQPn	PAQP	PASPQP[AW5*GASQPQCASQPCckQCPGSC]CAWQPPAEDÂQASEQB]B.AWQPAQB]BG PASAWB]BAWAÂ]GAQQPQCAQQPCcQCPGSC]CFGFTBQBCQCQ@@QHHSIÂQPIQ]HQBQCQO8B~B\	)	PF$B:BV]FB:B:B:BYFB^B\\BB4\BC*PKG-NAME*B:\B:B:B:Bm\Bo\BqBtBvBBBl:BBKBvP@рQBAAQBSCC7PQPCQCQCABB@OGB\BYL@F\$B:BV]FB:B:B:BYFB^BY\BBaBhB:\BELEMENTB:B:B:BB:À%TUPLEATT-LISTVAL-LISTB:B:B:Bl\Bo\UNLESSBBBqBtBvBwEQUALBB|҃PARSE-WHEREB\jMAKUNBOUNDBBBBBB*NREVERSEBтQDCCQDSEE5EW5	ESPPEWBEQCCDDBQQDCCCCSCDSDCSCDQFFFSGQGQIHHS	ISHIHJJтQLK*KQLSMM5MQ
	CM
MWQPMW	MWAMSMMS
	AQBAQCKLLJQ@]@FźLLтQJFFQJSEE5EQESCFJJLQ@Q@ÁQQO\BYB[<pB<F$B:BV]FB:B:B:BYFB^B[\B`BBBaBhBBBBbBBB:\TEMPBgCOLD-VALUESBiB:BlATTDBC%ATTRIBUTEB:B:ATTR-RELCATTR-INTOÀTEMP-D\Bo\BBBBqBtBBw*VALIDITY-CHECKING*BÂ*SYSTEM-ATTRIBUTE-KEY*Ã*SYSTEM-ATTRIBUTE-ATTRIBUTES*B#B$B]\lATTRIBUTESBB`BB|B`SYSTEM-ATTRIBUTE\,DOMAIN-FUNCTIONDEFAULT-VALUEDOCBPÁATTRIBUTE-NAMEB҃DOMpBTDEFBAANYPBy\BBBHBBBC\BCBD\BDBBB=\B=B@\B@\BAÀDEFREL\,DOMAIN-FUNCTIONANYPBBERROR - The attribute BB in relation  and the attribute , in the output relation l have different domain predicates.ERROR - The output relation  does not have all the attributes required to insert the retrieved tuples.  has  as attributes and the retrieve call requires  attributes in the relation l to be projected.BÀINSERT	PP
PPPPQB@Q@A@QDHDSEFPPPPPPPQPPE5EQEW5EWBFAQE5EQESPFSPFWPE5F[	AQE5EQESPPAE5ESEQC]CDŸPQBQDH	HQCQPHQGRGPQBQCQBQAQPPQBQ P!PQBQ"PQ#P$PQBQ%P&PQBP'PQBJ(R@S@ÊCQC|_Q@QJIVISJSLKMK5KSKKQQPEPP)PPPPPQPPKQBPP)PPPPPQPPL5LQLSBMrMQ*P+,-P.KQ/0P.Q/1P.LQ/2P.Q/3P.RIJIJ,4P.Q/5P.Q/6P.@Q/7P.Q/8P.Q/9P.RPPBځQ:PQ;BSBWOB[BZ0@hF$B:BV]FB:B:B:BYFB^BZ\BB:\
B:B:BBBBRESULT-TABLEB:BチHASH-BUCKET\Bo\BqBtBwB\F
B\BTESTBX*MAKE-HASH-TABLEBpB\lMEMBER-EQLpBT,PUTHASH\F\BBZBPPFQGGSHIHQFQIHQIQHQHQI]HQHQFQG	P
PCFQOBZB@F$B:BV]FB:B:B:BYFB^B\BCYB:\B:B:B\Bo\BwBBQ\OB1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\BW6\BJ=\B憀\Bz(\B{\B:}n\Bx\BZi\B{Ĳ\B2=\B.ً\B-i\B~z\B<p\B`sN\B|\B	aM*\Bw[\Bv(̢\Bt*j\Bq=#y soon.*
;;
(if (null (do ((sort-element sort-clause (cdr sort-element)))
      ((null sort-element) t)
    (if (null (setf sort-element% (validate-sym (car sort-element) t)))
(return-from sort-list nil))
    (cond ((member sort-element% attribute-list :test 'string-equal)
   ;;
   ;;1  Determine the domain for this attribute*
   ;;
   (setf domain (nth (- (length domain-list)
(length (member sort-element% attribute-list
:test 'string-equal)))
     domain-list))
   (setf key-list (append key-list (list sort-element%)))
   (cond ((not (member domain '("NUMBERP" "STRINGP" "ATOM") :tesLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540827. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "LISP" :NAME "SAVE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2753699838. :AUTHOR "REL3" :LENGTH-IN-BYTES 19595. :LENGTH-IN-BLOCKS 20. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;;; -*- Mode:Common-Lisp; Package:RTMS; Fonts:(*CODE-FONT* *COMMENT-FONT* *STRING-FONT*); Base:10 -*-
;;; Copyright (c) by Texas Instruments, Incorporated
;;; All rights reserved
;1;; SAVE*
;1;;*
;1;; This file contains the following Explorer extensions to CommonLisp Standard as Indicated in the June 1985 Explorer Lisp *
;1;; Reference*
;1;;     fs:directory-list*
;1;;     dump-forms-to-file*
;1;;     deff*
;;;     errset
;1;;*
;1;; The following function contains flavor references and thus are incompatable with CommonLisp. Their removal will not *
;1;; effect the functionality of RTMS.*
;1;;     save-flavor-hash*
;1;;     save-flavor-heap*
;1;;     save-flavor-avl*
;1;;*
;;;   Change History
;;;  Change History
;;;   03.31.87   MRR   Fixed SAVE-RELATION for saving Command files.
;;;   04.02.87   MRR   Fixed several Save functions to allow saving to remote hosts.

(defun save-flavor-hash (relation pathname rel-definition)
   (dump-forms-to-file pathname `(,rel-definition
  (setf var1 ',(getp relation 'entry-point))
  (putp ',relation var1 'entry-point))))

(defun save-flavor-heap (relation pathname rel-definition)
  (dump-forms-to-file pathname `(,rel-definition
 (setf var1 ',(getp relation 'entry-point))
 (putp ',relation var1 'entry-point))))

(defun save-flavor-avl (relation pathname rel-definition)
  (dump-forms-to-file pathname `(,rel-definition
 (setf var1 ',(getp relation 'entry-point))
 (putp ',relation var1 'entry-point))))

(defun save-list-avl (relation pathname rel-definition)
  (dump-forms-to-file pathname `((setf var1 ',(getp relation 'entry-point))
 ,rel-definition
 (putp ',relation var1 'entry-point))))

(defun save-list-hash (relation pathname rel-definition)
   (dump-forms-to-file pathname `((setf var1 ',(getp relation 'entry-point))
  ,rel-definition
  (putp ',relation var1 'entry-point))))

(defun save-list-heap (relation pathname rel-definition)
  (dump-forms-to-file pathname `((setf var1 ',(getp relation 'entry-point))
 ,rel-definition
 (putp ',relation var1 'entry-point))))

(defun save-struct-avl (relation pathname rel-definition)
   (dump-forms-to-file pathname `(,rel-definition
  (setf var1 ',(getp relation 'entry-point))
  (putp ',relation var1 'entry-point))))

(defun save-struct-hash (relation pathname rel-definition)
   (dump-forms-to-file pathname `(,rel-definition
  (setf var1 ',(getp relation 'entry-point))
  (putp ',relation var1 'entry-point))))

(defun save-struct-heap (relation pathname rel-definition)
  (dump-forms-to-file pathname `(,rel-definition
 (setf var1 ',(getp relation 'entry-point))
 (putp ',relation var1 'entry-point))))

(deff save-db 'save-database)

(defun save-database (database-name &rest1 *keyword-list
      &key &optional directory &allow-other-keys
      &aux keys temp-dir pathname temp-rel (error-flag nil))
  "Save all system relations and the user-defined, modified relations.

   DATABASE-NAME    - Name of the database to be saved.
   DIRECTORY 2        *- Name of the directory in which it is to be saved."
  directory temp-rel
  (block save-database
  (setf keys (copy-list keyword-list))
  (if (not (active-database))
      (return-from save-database nil))
  (if (null (setf database-name (validate-sym database-name t)))
      (return-from save-database nil))
  (if *transaction-on*
      (progn
(setf *transaction-forms-postponed* (append *transaction-forms-postponed*
    (list `(save-database ',database-name ',keys))))
(return-from save-database database-name)))

  (cond ((not (equal *active-db* database-name))
 (cond (*provide-error-messages*
(format *standard-output* "~%ERROR - Only the current database may be (or needs to be) saved.")
(format *standard-output* "~%        The current database is ~s" *active-db*)))
 (return-from save-database nil)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  ;;
  ;;1 Prepare the keyword-list for use*
  ;;1 Note: Keywords need to be added to allow the user to specify the type of format in which the relations should be saved. This will be
   *;1; done later...*
  ;;
  (setf keyword-list (get-keyword-value-prereq '(dir) keyword-list))
  ;;1form the path. If database-name is given it has to be the active database.*
  (setf pathname (concatenate 'string (setf temp-dir (get-directory keyword-list)) database-name ".2X*LD"))
  ;;
  ;;1  If the directory specified is not the save directory for this database, mark all relations as modified so that all of the relations will be
   *;1; stored in the new directory*
  ;;
  (cond ((not (equal *save-directory* temp-dir))
 (delete-or-modify 'system-relation t t '("MODIFIEDP") '(t))
 (delete-or-modify 2'*system-relation t t '("SAVE-DIRECTORY") (list temp-dir));mrr 04.02.87
 (setf *save-directory* temp-dir)))
  ;;1for each relation in the database call saverel It will be saverel-qfasl soon. Save the database definition.*
  (cond ((errset (fs:directory-list temp-dir) nil);mrr 04.02.87
 (dump-forms-to-file pathname (list (list 'setf  '*system-relation-base-implementation*
  *system-relation-base-implementation*)
    (list 'setf '*system-relation-storage-structure*
  *system-relation-storage-structure*)
    (list 'define-database* database-name
  (list 'dir temp-dir 'doc *database-documentation*
'env *environment-name*)))))
(t
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - Directory ~s does not exist" temp-dir))
 (return-from save-database nil)))
  (mapt (function (lambda (tuple &aux temp-rel temp-dir)
    (setf temp-dir (car (project-list (list tuple) *system-relation-attributes*
      '("RELATION-NAME" "SAVE-DIRECTORY"))))
    (setf temp-rel (read-from-string (concatenate 'string *pkg-name* (car temp-dir)))
  temp-dir (cadr temp-dir))
    (unless (errset (fs:directory-list temp-dir) nil);mrr 04.02.87
      (if *provide-error-messages*
  (format *standard-output* "~%ERROR - Directory ~s does not exist" temp-dir))
      (setf error-flag t)
      (return-from save-database nil))
    (save-relation temp-rel 'dir temp-dir)))
'system-relation)
  (if *provide-status-messages*
      (format *standard-output* "~%The ~s database has been saved in ~s" database-name temp-dir))
  (if error-flag
      (return-from save-database nil)
    (return-from save-database database-name))))

(deff save-env 'save-environment)

(defun save-environment (envname &rest keyword-list
 &key &optional directory &allow-other-keys
 &aux pathname dir keys rel-imp rel-sto)
  "Save an environment.

   ENVNAME   - Name of the environment to be saved.
   DIRECTORY - Name of the directory in which it is to be saved."
  directory
  (block save-environment
  (if (not (setf envname (validate-sym envname t)))
      (return-from save-environment nil))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
  (setf keys (copy-list keyword-list))
  (cond (*transaction-on*
 (setf *transaction-forms-postponed* (append *transaction-forms-postponed*
     (list `(save-environment ',envname ',keys))))
 (return-from save-environment envname)))
  (setf keyword-list (get-keyword-value-prereq '(dir) keyword-list))
  (setf pathname (concatenate 'string (setf dir (get-directory keyword-list)) "rtms-environment-" envname
      ".XLD"))
  (unless (errset (fs:directory-list dir) nil);mrr 04.02.87
    (if *provide-error-messages*
        (format *standard-output* "~%ERROR - The ~s directory does not exist" dir))
    (return-from save-environment nil))
  (setf rel-imp (subseq *relation-implementation* 0 (search "-" *relation-implementation*))
rel-sto (subseq *relation-implementation* (+ (search "-" *relation-implementation*) 1)))
  (unwind-protect
      (dump-forms-to-file pathname (list (list 'define-environment `(quote ,envname) `(quote auto-save)
       `(quote ,*auto-save-relations*) `(quote directory)
       `(quote ,*save-directory*) `(quote errors)
       `(quote ,*provide-error-messages*) `(quote para)
       `(quote ,*parameter-checking*) `(quote rel-imp) `(quote ,rel-imp)
       `(quote rel-sto) `(quote ,rel-sto) `(quote status)
       `(quote ,*provide-status-messages*) `(quote sys-imp)
       `(quote ,*system-relation-base-implementation*) `(quote sys-sto)
       `(quote ,*system-relation-storage-structure*) `(quote validity)
       `(quote ,*validity-checking*) `(quote warnings)
       `(quote ,*provide-warning-messages*))))
    nil)
    (return-from save-environment envname)))

(deff save-rel 'save-relation)

(defun save-relation (relation-name &rest keyword-list
      &key &optional directory save type &allow-other-keys
      &aux insert-routine pathname templist keys on-disk? modp dir attributes imp ss
      temp-message key tuple-format doc temp qtrieve-var save-type always-save temp-dir)
   "Save a relation if it is modified.

    RELATION-NAME - Name of the relation to be saved.
    DIRECTORY     - Name of the directory in which it is to be saved.
    SAVE          - If T, saves the relation even if the relation is not modified.
    TYPE          - Two types of save are allowed: COMMAND and 2XL*D. This keyword can be used to
                    specify the type."
   directory save type
   (block save-relation
 (if (not (active-database))
     (return-from save-relation nil))
 (if (null (setf relation-name (validate-sym relation-name t)))
     (return-from save-relation nil))
 (setf keys (copy-list keyword-list))
 (cond (*transaction-on*
(setf *transaction-forms-postponed* (append *transaction-forms-postponed*
    (list `(save-relation ',relation-name ',keys))))
(return-from save-relation relation-name)))
  (setf keyword-list (do ((keyword-list keyword-list (car keyword-list)))
 ((or (null keyword-list)(not (listp (car keyword-list)))) keyword-list)))
 (setf keyword-list (get-keyword-value-prereq '(type dir save) keyword-list))
  (setf qtrieve-var (cadr (get-relation relation-name '("RELATION-NAME" "MODIFIEDP" "SAVE-DIRECTORY"
"ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE"
"KEY" "TUPLE-FORMAT" "DOC" "2DISK"*) t t)))
  (cond ((not qtrieve-var)
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
     relation-name *active-db*))
 (return-from save-relation nil)))
  ;;
  ;;1The relation is defined and (if saved) also restored.*
  ;;
  (setf modp (second qtrieve-var)
dir (third qtrieve-var)
attributes (fourth qtrieve-var)
imp (fifth qtrieve-var)
ss (sixth qtrieve-var)
key (seventh qtrieve-var)
tuple-format (nthcdr 7 qtrieve-var)
doc (second tuple-format)
on-disk? (third tuple-format)
tuple-format (first tuple-format))
  ;;
  ;;1LATER.... If the keyword for save-format is QFASL or data save it in that fashion. check if the relation provided is a valid dbms object*
  ;;1See if the TYPE has been provided.*
  ;;
 (setf save-type (or (car (get-keyword-value '(type) keyword-list)) 'xld)
       always-save (car (get-keyword-value '(save) keyword-list)))
  ;;
  ;;1Dump-forms-to-file has a bug for hash tables. Until that is fixed we will have to avoid QFASL format for hash storage structure.*
  ;;
  (cond ((equal save-type  'xld)
 (return-from save-relation (saverel-qfasl relation-name keyword-list)))
((not (equal save-type 'command))
 (if *provide-error-messages*
     (format *standard-output* "~%ERROR - ~s is an unrecognized save type ." save-type))
 (return-from save-relation nil)))
  ;;
  ;;1create a pathname to access the file where this relation is stored*
  ;;
  (setf temp-dir (get-directory keyword-list dir))
  (unless (errset (fs:directory-list temp-dir) nil);mrr 04.02.87
   (if *provide-error-messages*
       (format *standard-output* "~%ERROR - Directory ~s does not exist" temp-dir))
 (return-from save-relation nil))
  (cond ((not (equal temp-dir dir))
 (delete-or-modify 'system-relation t
   (list 'string-equal (concatenate 'string *pkg-name* "RELATION-NAME"2)*
 (string-upcase relation-name))
   '("SAVE-DIRECTORY") (list temp-dir))
 (delete-or-modify 'system-relation t
   '(string-equal (concatenate 'string *pkg-name* "RELATION-NAME"2)* "SYSTEM-RELATION")
   '("MODIFIEDP") '(t))))
  (setf pathname (concatenate 'string temp-dir *active-db* "-" relation-name "." (string save-type)));mrr 03.31.87
  (setf templist nil)
  (cond ((and (not modp) (not always-save) (equal temp-dir dir))
 (if *provide-status-messages*
     (format *standard-output* "~%The relation ~S has not been modified" relation-name))
 (return-from save-relation relation-name)))
  (if on-disk?
      (load-relation relation-name 'dir dir))
  (unwind-protect
      (progn
(setf pathname (open pathname :direction :output));mrr 03.31.87
(format pathname "~&(SETF *non-qfasl-restore* T)")
(if (not (member relation-name *system-relations* :test 'string-equal))
    (format pathname "~&(DEFREL-RESTORE ~S ~S ~S)"
    relation-name attributes (list 'imp imp 'modifiedp nil 'sto ss 'key key
   'tuple-format tuple-format 'doc doc 'dir dir)))

(if (and (not (member relation-name *system-relations* :test 'string-equal)) (string-equal ss "hash"))
    (format pathname "~&(PUTP '~S (make-hash-table :test 'equal) '~S)" relation-name 'entry-point))
(setf temp nil)
(mapt (function (lambda (%tuple)
  (setf temp (cons %tuple temp))))
      relation-name)
(if temp
    (progn
      (setf insert-routine (read-from-string (concatenate 'string "INSERT-" imp "-" ss)))
      (format pathname  "~&(~S '~S '~S '~S '~S)" insert-routine relation-name attributes (reverse temp)
      key relation-name)))
(format pathname "~&(SETF *non-qfasl-restore* NIL)")
(close pathname)
(delete-or-modify 'system-relation t
  (list 'string-equal (concatenate 'string *pkg-name* "RELATION-NAME"2)*
(string-upcase relation-name))
  '("MODIFIEDP") '(nil))
(cond ((not (member relation-name *system-relations* :test 'string-equal))
       (setf temp-message *provide-status-messages*
     *provide-status-messages* nil)
       (save-system-relations)
       (setf *provide-status-messages* temp-message)))
(if *provide-status-messages*
    (format *standard-output* "~%The relation ~s has been saved in the directory ~s"
    relation-name temp-dir)))
    nil)
 (return-from save-relation relation-name)))

(defun saverel-qfasl (relation keyword-list
      &aux keys rel-definition pathname temp-dir card mod dir attributes imp ss key tuple-format
      doc qtrieve-var temp-message on-disk?)
  (block saverel-qfasl
(setf keys (copy-list keyword-list))
(if *transaction-on*
    (progn
      (setf *transaction-forms-postponed* (append *transaction-forms-postponed*
  (list `(saverel-qfasl ',relation ',keys))))
      (return-from saverel-qfasl relation)))
        (setf keyword-list (get-keyword-value-prereq '(dir type save) keyword-list))
        (setf qtrieve-var (cadr (get-relation relation '("RELATION-NAME" "MODIFIEDP"  "SAVE-DIRECTORY"
 "ATTRIBUTES" "IMPLEMENTATION-TYPE" "STORAGE-STRUCTURE"
 "KEY" "TUPLE-FORMAT" "DOC" "CARDINALITY") t t)))
(cond ((not qtrieve-var)
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - The relation ~S is not defined in the database ~S"
   relation *active-db*))
       (return-from saverel-qfasl nil)))
;;1The relation might be defined and restored.*
(setf mod (second qtrieve-var) dir (third qtrieve-var)
      attributes (fourth qtrieve-var)
      imp (fifth qtrieve-var) ss (sixth qtrieve-var)
      key (seventh qtrieve-var)
      tuple-format (nthcdr 7 qtrieve-var) doc (second tuple-format)
      card (third tuple-format) on-disk? (fourth tuple-format) tuple-format (first tuple-format))
(setf temp-dir (get-directory keyword-list dir))
(unless (errset (fs:directory-list temp-dir) nil);mrr 04.02.87
       (if *provide-error-messages*
   (format *standard-output* "~%ERROR - The ~s directory does not exist" temp-dir))
       (return-from saverel-qfasl nil))
(cond ((not (equal temp-dir dir))
       (delete-or-modify 'system-relation t (list 'string-equal 'relation-name `(quote ,relation))
'("SAVE-DIRECTORY") (list temp-dir))
       (delete-or-modify 'system-relation t '(string-equal relation-name "SYSTEM-RELATION")
'("MODIFIEDP") '(t))))
;;1check if it is modified*
(cond ((and (not mod)(equal temp-dir dir))
       (if *provide-status-messages*
   (format *standard-output*
   "~%The relation ~S has not been modified and thus does not need to be saved"
   relation))
 (return-from saverel-qfasl relation)))
(setf pathname (concatenate 'string temp-dir *active-db* "-" relation ".XLD"))

1;; Form the relation definition.*
1;;*
1;; In QFASL we have to save every bit of information (eg. cardinality) because the tuples are restored automatically*
;1; (without INSERT).*
(setf rel-definition (list 'defrel-restore relation attributes
   (list 'imp imp 'cardinality card 'modifiedp nil 'sto ss 'key key
 'tuple-format tuple-format 'doc doc 'dir dir)))
(if on-disk?
    (load-relation relation 'dir dir))
(unwind-protect
    (progn
      (funcall (find-symbol (concatenate 'string "SAVE-" imp "-" ss) *pkg-string*) relation pathname
       rel-definition)
      (delete-or-modify 'system-relation t (list 'string-equal 'relation-name `(quote ,relation))
'("MODIFIEDP") '(nil))
      (cond ((not (member relation *system-relations* :test 'string-equal))
     (setf temp-message *provide-status-messages*
   *provide-status-messages* nil)
     (save-system-relations)
     (setf *provide-status-messages* temp-message)))
      (if *provide-status-messages*
  (format *standard-output* "~%The relation ~s has been saved in the directory ~s"
  relation temp-dir)))
  nil)
(return-from saverel-qfasl relation)))


(defun save-system-relations (&rest ignore &aux pathname)
  (block save-system-relations
;;
;;1If no system relation is modified, we do not want to save the database definition.*
;;
(if (not (member '(t) (qtrieve 'system-relation *system-relation-attributes* '("MODIFIEDP")
  *system-relation-key* '(member relation-name *system-relations*
 :test 'string-equal))))
    (return-from save-system-relations t))
;;
;;1For each system relation in the database call saverel*
;;
(unless (errset (fs:directory-list *save-directory*) nil);mrr 04.02.87
  (if *provide-error-messages*
   (format *standard-output* "~%ERROR - The ~s directory does not exist" *save-directory*))
       (return-from save-system-relations nil))
(mapcar (function (lambda (sys-rel)
    (save-relation sys-rel 'dir *save-directory*)))
*system-relations*)
(setf pathname (concatenate 'string *save-directory* *active-db* ".2XL*D"))
(dump-forms-to-file pathname (list (list 'setf '*system-relation-base-implementation*
 *system-relation-base-implementation*)
   (list 'setf '*system-relation-storage-structure*
 *system-relation-storage-structure*)
   (list 'define-database* *active-db*
 (list 'dir *save-directory* 'doc *database-documentation*
       'env *environment-name*))))
(return-from save-system-relations t)))
G2BwBqBtBvBkB\lLTLTElLElDECREASINGDESCDESlGTGTElGElINCREASINGASCBB\lLTlLELTElDECREASINGDESCDESÀDBGTPB|By\lGTlGEGTElINCREASINGASCBlWARNING - BB, is neither a valid quick-sort keyword nor an attribute.AрQCBJBQDCSD@RDQPP8CWPPDQQP@QDQ	P

@$CWPPDQQP@QDQD5DQCDQQPPDQPCBCC@OBBU@F$B:BV]FB:B:B:BYFB^BU\B`B2BB3B4B5B6B=B7BBBBB8B<BB:BBB
BB9BBEB;B?B:B:\BB5B6B=B7BBBBB8B<BB:BBB
BB9BBEB;B?\B=Retrieve some tuples from a relation satisying a where clause.

   RELATION-NAME        - Name of the reLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540830. :SYSTEM-TYPE :LOGICAL :VERSION 2. :TYPE "XLD" :NAME "SAVE" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :NOT-BACKED-UP T :CREATION-DATE 2760360526. :AUTHOR "REL3" :LENGTH-IN-BYTES 6527. :LENGTH-IN-BLOCKS 13. :BYTE-SIZE 16.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              pp2\COMPILE-DATA\SW-MFG,GODZILLA^FF\p,COMPILER,VERSION\FFpB),OPTIMIZE-SWITCHQFASL-SOURCE-FILE-UNIQUE-ID1\plFSMAKE-FASLOAD-PATHNAME\QUOTEB$\B8NIL\B8\RTMS\B8SAVE\B8LISP\B8FBASEF
FONTS\*CODE-FONT**COMMENT-FONT**STRING-FONT*)PACKAGERTMSMODECOMMON-LISPSAVE-FLAVOR-HASH	FF$B:pTICLART-Q]FB:B:B:jTFpSYSlDEBUG-INFO-STRUCTBP\RELATION*PATHNAMEÁREL-DEFINITIONB:B:\)MACROS-EXPANDED\pB\XR-BQ-LIST*pB\lXR-BQ-LISTSETFVAR1B8ENTRY-POINTGETPҪLIST҃PUTP\Bk\B8BlLIST*pBTlDUMP-FORMS-TO-FILEQQPPPQP	PPQ
POuBPSAVE-FLAVOR-HEAP	FF$B:BV]FB:B:B:BYFB^Bv\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQQPPPQP	PPQ
POBvSAVE-FLAVOR-AVL	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQQPPPQP	PPQ
POBÁSAVE-LIST-AVL	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQPPPQPQ	PPQ
POBÁSAVE-LIST-HASH	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQPPPQPQ	PPQ
POBÁSAVE-LIST-HEAP	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQPPPQPQ	PPQ
POBSAVE-STRUCT-AVL	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQQPPPQP	PPQ
POBSAVE-STRUCT-HASH	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQQPPPQP	PPQ
POBSAVE-STRUCT-HEAP	FF$B:BV]FB:B:B:BYFB^B\B`BaBbB:B:\Bd\BgBiBjBkB8BlBmBnBo\Bk\B8BlBrBtQQPPPQP	PPQ
POBÁSAVE-DATABASEOSAVE-DBB<X솀`<|F$B:BV]FB:B:B:BYFB^B\ÁDATABASE-NAME&RESTKEYWORD-LIST&KEYj&OPTIONALjDIRECTORYj&ALLOW-OTHER-KEYSB:\\BB:pB\lLEX-PARENT-ENV-REGpB\LEX-ENV-B-REGpB\LEX-CURRENT-VECTOR-REGpB\LEX-ALL-VECTORS-REGBKEYSTEMP-DIRBaCERROR-FLAGB:BB:B:\Bd\pBTlCONDITION-BIND-IFpBTCONDITION-BINDpBTCATCH-CONTINUATION-IFpBTlCATCH-CONTINUATIONpBTERRSETPROGBiBjINTERNAL-FEF-OFFSETS\F8iVARIABLES-USED-IN-LEXICAL-CLOSURES\Exit block SAVE-DATABASEBDOCUMENTATIONSave all system relations and the user-defined, modified relations.

   DATABASE-NAME    - Name of the database to be saved.
   DIRECTORY         - Name of the directory in which it is to be saved.plEH*CONDITION-HANDLERS*C*PROVIDE-STATUS-MESSAGES*C*ENVIRONMENT-NAME**DATABASE-DOCUMENTATION*у*SYSTEM-RELATION-STORAGE-STRUCTURE*Ä*SYSTEM-RELATION-BASE-IMPLEMENTATION**SAVE-DIRECTORY**PROVIDE-ERROR-MESSAGES*у*ACTIVE-DB*Ã*TRANSACTION-FORMS-POSTPONED**TRANSACTION-ON*\iDIRECTORYpB\STORE-KEYARGSF&jCOPY-LISTACTIVE-DATABASE҃VALIDATE-SYMBB8BnpB\,*APPENDTERPRI,ERROR - Only the current database may be (or needs to be) saved.WRITE-STRING,        The current database is PRIN1\DIRGET-KEYWORD-VALUE-PREREQSTRINGÁGET-DIRECTORYҬ.XLDCONCATENATESYSTEM-RELATION\lMODIFIEDP\BYDELETE-OR-MODIFY\SAVE-DIRECTORYp,G8924FERRORpB\ERRSET-HANDLERpB4DIRECTORY-LISTBjB BDEFINE-DATABASE*B6DOCENVBtlERROR - Directory , does not exist\FF
\)INTERNALBMAPTҬThe  database has been saved in @@QPFKKPU@QGۚQPPPQPGQP+
PPP@QLSLLS5LQ@P@Q@P@Q HÀQ!P"I	PH+#P$P%P&#P'PHQ&HQ	(P)PT*P+P(PJCMPJCNHQ,J!BJ!B\\IQ-P.PP-P/PP0PQ1PHQ2PP3PP4

5PHQ6Pw7P8PC#P9	:PQ;PHQJeQJ\PO[BBUW@\F8$B:BV]FB:B:B:BYFB^BU\ÀTUPLEB:\B:B:BTEMP-RELBB:B:\Bd\BB	BBBUNLESSBjiLEXICAL-PARENT-DEBUG-INFOBBB"C*PKG-NAME*у*SYSTEM-RELATION-ATTRIBUTES*Bn\RELATION-NAMESAVE-DIRECTORYPROJECT-LISTB8B;*READ-FROM-STRINGpBCG8933F[BGBIBKB0lERROR - Directory B2B4, does not existB6ÁSAVE-RELATIONQPP	BD
PPDSCDWDPPTPPPJCEPJCFDQJ!BJ!B\\PDQPPXCQPDQOxBUSAVE-ENVIRONMENTOySAVE-ENVBy:U䆀`:hF$B:BV]FB:B:B:BYFB^By\ENVNAMEBBBBBBB:\
BBBaB6BREL-IMPREL-STOBB:B:\Bd\	BB	BBBBiBiBBjBlSave an environment.

   ENVNAME   - Name of the environment to be saved.
   DIRECTORY - Name of the directory in which it is to be saved.BC*PROVIDE-WARNING-MESSAGES*у*VALIDITY-CHECKING*BB Bу*PARAMETER-CHECKING*B!Â*AUTO-SAVE-RELATIONS*C*RELATION-IMPLEMENTATION*B"B$B%\B'B)B-B+ByB8BnB/\B6B7B8B9lrtms-environment-.XLDB;pBCG9006FBGBIBKB0ҬERROR - The B2B4l directory does not existl-pB\,SEARCH*SUBSEQFCDEFINE-ENVIRONMENT\B8CAUTO-SAVE\B8B\B8ÀERRORS\B8PARA\B8B\B8B\B8ÀSTATUS\B8SYS-IMP\B8SYS-STO\B8VALIDITY\B8WARNINGSBt@@QPAQR@QGSGGS5GQ@DPPPQPDQP@Q@P@QCPQPBP PT!P"PPJCHPJCICQ#J!BJ!B\\
$%P&CQ'(P&RPJ)PP*+EP)PP*k+F,PJUBQ-PPQ.PPP/PP
P0PPP1PP	P2PPEQ3PPFQ4PPP5PPP6PPP7PPP8PPPJ9]ZOByBwOwSAVE-RELBw^^@F$B:BV]FB:B:B:BYFB^Bw\	ÁRELATION-NAMEBBBBBSAVETYPEBB:\\BB:BBBBBBBÁINSERT-ROUTINEBaTEMPLISTBON-DISK?MODPB6CATTRIBUTESIMPCSSTEMP-MESSAGEKEYTUPLE-FORMATBMTEMPQTRIEVE-VARCSAVE-TYPEALWAYS-SAVEBBB:B:\Bd\BB	BBBBiFIRST*SEVENTHSIXTHFIFTHFOURTHTHIRDSECONDBBiBjB\FSB\BB,Save a relation if it is modified.

    RELATION-NAME - Name of the relation to be saved.
    DIRECTORY     - Name of the directory in which it is to be saved.
    SAVE          - If T, saves the relation even if the relation is not modified.
    TYPE          - Two types of save are allowed: COMMAND and XLD. This keyword can be used to
                    specify the type. BC*SYSTEM-RELATIONS*BBkB#B"B$B%\B'SAVETYPEB)B,B-B+BwB8BnB/\BB6BB7\
RELATION-NAMElMODIFIEDPSAVE-DIRECTORYlATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATDOCDISKGET-RELATIONB0ERROR - The relation B2B4, is not defined in the database \BCGET-KEYWORD-VALUE҃XLD\BÁSAVEREL-QFASLCOMMAND,ERROR - , is an unrecognized save type .B9pBCG9052FXBGBIBKlERROR - Directory , does not existB<STRING-EQUALB8RELATION-NAMEB;STRING-UPCASE\SAVE-DIRECTORYB@\B\B;\B8B8BkRELATION-NAME,SYSTEM-RELATION\lMODIFIEDP\BYl-l.B8The relation  has not been modifiedB6ÁLOAD-RELATIONFiDIRECTIONOUTPUTOPEN~&(SETF *non-qfasl-restore* T)FORMATpB\MEMBER-TESTҬ~&(DEFREL-RESTORE ~S ~S ~S)BCMODIFIEDPSTOBBBMhashpB\STRING-EQUAL*,~&(PUTP '~S (make-hash-table :test 'equal) '~S)Bl\FF\BVBwBX,INSERT-Bq~&(~S '~S '~S '~S '~S)*REVERSE,~&(SETF *non-qfasl-restore* NIL)CLOSE\B:ÂSAVE-SYSTEM-RELATIONSl has been saved in the directory @@QPFRQR@QL
PPPQPLQ
@Q\S\\S5\Q@P@Q@QPBX		PQPPRXWNX[OXQBPXUBQXYBRXQBBTJXQ
CUUWVU[MUSUP@QB PY!P@QBZYQ &Q@Q"YQ#&
	$PYQ%PR@QOQ&['P(PT)P*P'PJC]PJC^[Q+J!BJ!B\\
	,P[Q-PR[QO+.P/P0PP1P2Q34P[Q5.P6P7P8P50P[QP9PQ:PYQ;J2JKNZ[QO+
<PQ=PMQ>POQ?@PJUJQAPBPCJDPEQP/PFJQGPQPQHPQQIPJPRQKPTQLPUQMPVQ>POQJEQP/PF	RQNPOJQPPQQPEWRPSPCQTW0PUPQQ9PRQ2VIJQWPIQQPQWQXTQQJEJQYPEJQZ.P/P0PP1P2Q37P[P5QP/PFPS\SQ	<PQ]P[Q]ZO*BwB @LF$B:BV]FB:B:B:BYFB^B \À%TUPLEB:\B:B:B\Bd\BjBjBQ\O7B BAz5AF$B:BV]FB:B:B:BYFB^B\B`BB:\BBbBaBCARDMODB6BBBBBBMBBBB:B:\Bd\BB	BBBBiBBBBBBBBiBjABBу*PKG-STRING*BB#B"B$B%B+BB8BnB/\B6BBB7\
RELATION-NAMElMODIFIEDPSAVE-DIRECTORYlATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATDOCCARDINALITYBB0ERROR - The relation B2B4, is not defined in the database B9pBCG9151FBGBIBKҬERROR - The l directory does not existB<BB\SAVE-DIRECTORYB@\BB,SYSTEM-RELATION\lMODIFIEDP\BYThe relation l has not been modified and thus does not need to be savedB8l-.XLDB;ÁDEFREL-RESTOREBCARDINALITYBBBBBMB6BFpSAVE-FIND-SYMBOL\B:BB(l has been saved in the directory Q@
PPPQP@Q
PQQPBM		PQPPRMWEM[FMQBGMUBHMYBIMQBBJJMQ
CKKWLK[DKQBOKSKQFQCPPTPPPJCPPJCQCQJ!BJ!B\\
	 PCQ!PRCQF+"P#P$PPQ%PCQ&"P'P(P)P&ECQF+
*PQ+P,PCQP-PQ.P/B0PQGQ1PHQ2PDQ3P4PIQ5PJQ6PKQ7PLQ8PFQJAOQ8PFQ9:PJU,P;PHQ-PIQ/P<QQBQAQQ"P#P$PPQ(P=P&QP#P>PN?NQ	*PQ@PCQ]uZOlBB(*/`*FY$B:BV]FB:B:B:BYFB^B(\BIGNOREB:\BuBaB:B:B:B:\Bd\
BjBpZLC,DO-NAMEDpBTINHIBIT-STYLE-WARNINGSBB	BBBBiBBBBB B#BB"B!Â*SYSTEM-RELATION-KEY*Bl\BYB<\lMODIFIEDP\MEMBERBBTEST\B8BQTRIEVEpBCG9212FxBGBIBKBnB0ҬERROR - The B2B4l directory does not existB6BwB8.XLDB;BjB BBLBMBNBtPPPPPPSPPTPPPJCBPJCCPJ!BJ!B\\

PPPRCC	PED	DQESPPCDEE PPP!P"A#P$PP#P%PP&PPPP'PP(PP)SO
B(1\pB\,FASL-RECORD-FILE-MACROS-EXPANDED\B8\\DEFUN'\pBTDEFFb\B}(̢\B{*j\B{\B:}n\Bx\BZi\B{Ĳ\B2=\Bz(\Bi6\Bj[\B=#\B-i\B~z\B<p\B	`sN\B|\Bi.ً\BgNogn
(setf pathname (open pathname :direction :output));mrr 03.31.87
(format pathname "~&(SETF *non-qfasl-restore* T)")
(if (not (member relation-name *system-relations* :test 'string-equal))
    (format pathname "~&(DEFREL-RESTORE ~S ~S ~S)"
    relatLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540834. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "STARTER-KIT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846954. :AUTHOR "REL3" :LENGTH-IN-BYTES 10293. :LENGTH-IN-BLOCKS 11. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;;; -*- Mode:LISP; Package:RTMS; Base:10 -*-;


;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (b)(3)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (c) 1985, Texas Instruments Incorporated.  All Rights Reserved.
;;; Copyright (c) 1986, Texas Instruments Incorporated.  All Rights Reserved.


;
(PKG-GOTO 'RTMS)

;
;  Define an environment which will silence any messages
;
(DEFINE-ENVIRONMENT 'silent-status 'status NIL 'validity 'NIL)
;
;  Define the database
;
(DEFINE-DATABASE 'micro-parts
 'doc "Contains all of the parts which are available from RTMS Micro"
 'dir "rtms;")

;
;  Define the parts relation
;
(DEFINE-RELATION 'parts
 '(number (dom numberp
    format 6
    doc "The RTMS micro part number")
   name (dom stringp
    format 25
    doc "The name of the part")
   qoh (dom numberp
   format 8
   doc "Quantity of parts On Hand")
   price (dom numberp
     format 10
     doc "The cost to the user of the part"))
                 'doc "A complete listing of the parts available from RTMS micro")

;
;  Define the SUPPLIERS relation
;
(DEFINE-RELATION 'suppliers
 '(number (dom numberp
    format 6
    doc "The RTMS micro part number")
   supplier-number (dom numberp
       format 16
       doc "The suppliers part number")
   supplier-name (dom stringp
     format 29
     doc "The name of the supplier")
   primary-source (dom anyp
      format 14
                 doc "T or NIL if this supplier is the primary source of the part")
   address (dom stringp
       format 35
       doc "The address of the supplier")
   cost-function (dom listp
     format 10
     doc "The individual suppliers cost function"))
  'doc "A listing of the suppliers of the parts which are available from RTMS Micro")


;
;  Insert the tuples into the parts relation
;
(SETQ parts-tuples '((3 "System Unit" 30 2200)
(4 "System Power Cable" 55 22)
(12 "Keyboard" 33 259)
(7 "Keyboard Cable" 42 18)
(1 "Monochrome Monitor" 15 389)
(2 "Color Monitor" 32 545)
(5 "Monitor Power Cable" 48 15)
(6 "Monitor to System Cable" 32 20)
(13 "Floppy Disk Drive" 65 249)
(15 "Hard Disk Drive" 20 1500)
(14 "Streaming Tape Drive" 8 895)
(11 "Printer" 35 525)
(9 "Printer Cable" 36 24)
(10 "Optical Mouse System" 27 295)
(8 "Optical Mouse Cable" 30 8)))
(INSERT 'parts 'tuple (NREVERSE parts-tuples))

;
;  Insert the Suppliers tuples
;
(SETQ suppliers-tuples '((3 3 "RTMS Micro" Yes "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (4 4 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (12 12 "RTMS Micro" Yes "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (7 7 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (1 1 "RTMS Micro" Yes "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (2 2 "RTMS Micro" Yes "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (5 5 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (6 6 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (13 13 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (15 15 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (14 14 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (11 11 "RTMS Micro" Yes "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (9 9 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (10 10 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
         (8 8 "RTMS Micro" No "1486 Micro Drive, Dallas, TX"
    (lambda (price quantity) (* price quantity)))
 (3 1 "Chaparral Computer Systems" No
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (1 2 "Chaparral Computer Systems" No
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (2 3 "Chaparral Computer Systems" No
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (13 4 "Chaparral Computer Systems" Yes
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (14 5 "Chaparral Computer Systems" Yes
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (15 6 "Chaparral Computer Systems" Yes
       "1212 Runner Road, Denver, CO"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .75))
(T (* price quantity .50))))
 )
 (4 1 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (5 2 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (6 3 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (7 4 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (8 5 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (9 6 "Raven Micro Systems" Yes
 "26 Cable Springs, Boston, MA"
(lambda (price quantity)
  (cond ((< quantity 10)
 (* price quantity .95))
((< quantity 100)
 (* price quantity .90))
((< quantity 1000)
 (* price quantity .80))
(T (* price quantity .70))))
 )
 (1 10 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (2 20 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (10 30 "Peripheral Products" Yes "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (11 40 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (12 50 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (13 60 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (14 70 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 (15 80 "Peripheral Products" No "86 South Lane, Atlanta, GA"
    (lambda (price quantity)
      (cond ((< quantity 2000)
     (* quantity (* (- 1.0 (* (quotient quantity 2000.0) * 0.5)) price)))
    (T (* quantity price .5)))))
 ))
(INSERT 'suppliers 'tuple (NREVERSE suppliers-tuples) )
;
;  Turn back on validity and status message output
;
(DEFINE-ENVIRONMENT 'Micro-Parts 'status T 'validity T)
BjBjBQ\O7B BAz5AF$B:BV]FB:B:B:BYFB^B\B`BB:\BBbBaBCARDMODB6BBBBBBMBBBB:B:\Bd\BB	BBBBiBBBBBBBBiBjABBу*PKG-STRING*BB#B"B$B%B+BB8BnB/\B6BBB7\
RELATION-NAMElMODIFIEDPSAVE-DIRECTORYlATTRIBUTESIMPLEMENTATION-TYPElSTORAGE-STRUCTUREKEYTUPLE-FORMATDOCCARDINALITYBB0ERROR - The relation B2B4, is not defined in the database B9pBCG9151FBGBIBKҬERROR - The l directory does not existB<BB\SAVE-DIRECTORYB@\BB,SYSTEM-RELATION\lMODIFIEDP\BYThe relation l has not been modified and thus does not need to be savedB8l-.XLDB;ÁDEFREL-RESTOREBCARDINALLMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540837. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "STARTER-KIT-DESTROY" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846960. :AUTHOR "REL3" :LENGTH-IN-BYTES 669. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)

;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (b)(3)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (C) 1985, Texas Instruments Incorporated. All rights reserved.


(DEFINE-ENVIRONMENT 'rtms-micro 'status nil)
(DESTROY-DATABASE (ACTIVE-DATABASE))
(DEFINE-ENVIRONMENT 'rtms-micro 'status T)
                                                                                                                                                                                                                                                                                                                                                                   LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540840. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "STARTER-KIT-INSERT" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846965. :AUTHOR "REL3" :LENGTH-IN-BYTES 691. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)

;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (b)(3)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (C) 1985, Texas Instruments Incorporated. All rights reserved.
;;; Copyright (C) 1896, Texas Instruments Incorporated. All rights reserved.

((20 "Basic Manual" 32 18)
 (21 "How to Operate the Computer" 27 20))
                                                                                                                                                                                                                                                                                                                                             LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540843. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "STARTER-KIT-PL" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846970. :AUTHOR "REL3" :LENGTH-IN-BYTES 1815. :LENGTH-IN-BLOCKS 2. :BYTE-SIZE 8.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;;; -*- Mode:LISP; Package:RTMS; Base:10 -*-;

;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (b)(3)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (C) 1985, Texas Instruments Incorporated. All rights reserved.
;;; Copyright (C) 1896, Texas Instruments Incorporated. All rights reserved.
(define-relation 'price-list '(number (dom numberp
       doc "The RTMS Micro part number"
       format 6)
       s-number (dom numberp
 doc "The suppliers part number"
 format 8)
       supplier-name (dom stringp
      doc "The name of the supplier for this part"
      format 30)
       price (dom numberp
      doc "The cost of the part per 100"
      format 10)))
(insert 'price-list 'tuples '((3 100 "RTMS Micro" 1295)
      (3 101 "RTMS Micro" 1595)
      (3 102 "RTMS Micro" 1795)
      (3 1 "Chaparral Computer Systems" 1395)
      (3 2 "Chaparral Computer Systems" 1695)
      (1 103 "RTMS Micro" 250)
      (1 104 "RTMS Micro" 300)
      (1 10 "Chaparral Computer Systems" 200)
      (1 20 "Chaparral Computer Systems" 275)
      (1 100 "Peripheral Products" 185)
      (1 102 "Peripheral Products" 200)
      (1 104 "Peripheral Products" 250)
      (13 200 "RTMS Micro" 100)
      (13 201 "RTMS Micro" 150)
      (13 400 "Chaparral Computer Systems" 125)
      (13 402 "Chaparral Computer Systems" 175)
      (13 500 "Peripheral Products" 110)))
                doc "T or NIL if this supplier is the primary source of the part")
   address (dom stringp
       format 35
       doc "The address of the supplier")
   cost-function (dom listp
     format 10
   LMFL#!C(:HOST "SW-MFG" :BACKUP-DATE 2760540846. :SYSTEM-TYPE :LOGICAL :VERSION 1. :TYPE "LISP" :NAME "STARTER-KIT-SET" :DIRECTORY ("RTMS-DIR") :SOURCE-PATTERN "( :DIRECTORY (\"RTMS-DIR\") :NAME :WILD :TYPE :WILD :VERSION :NEWEST)" :CHARACTERS T :NOT-BACKED-UP T :CREATION-DATE 2749846974. :AUTHOR "REL3" :LENGTH-IN-BYTES 787. :LENGTH-IN-BLOCKS 1. :BYTE-SIZE 8.)

;;;                           RESTRICTED RIGHTS LEGEND

;;;Use, duplication, or disclosure by the Government is subject to
;;;restrictions as set forth in subdivision (b)(3)(ii) of the Rights in
;;;Technical Data and Computer Software clause at 52.227-7013.
;;;
;;;                     TEXAS INSTRUMENTS INCORPORATED.
;;;                              P.O. BOX 2909
;;;                           AUSTIN, TEXAS 78769
;;;                                 MS 2151
;;;
;;; Copyright (C) 1985, Texas Instruments Incorporated. All rights reserved.
;;; Copyright (C) 1896, Texas Instruments Incorporated. All rights reserved.

(RETRIEVE 'parts 'into 'set-rel-2 'project '(number name qoh) 'where '(<= number 10))
(RETRIEVE 'parts 'into 'set-rel-1 'project '(number name) 'where '(>= number 7))
